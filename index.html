<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Lsinger&#39; s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Lsinger&#39; s blog">
<meta property="og:locale">
<meta property="article:author" content="Lsinger">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;default&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Lsinger' s blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lsinger' s blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Lsinger' s blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lsinger</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-23 01:42:24 / Modified: 01:43:40" itemprop="dateCreated datePublished" datetime="2021-06-23T01:42:24+08:00">2021-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Internet/" itemprop="url" rel="index"><span itemprop="name">Internet</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h1><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="包头"><a href="#包头" class="headerlink" title="包头"></a>包头</h2><p><img src="https://static001.geekbang.org/resource/image/64/bf/642947c94d6682a042ad981bfba39fbf.jpg" alt="img"></p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><ul>
<li><p>TCP 提供可靠交付，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达</p>
</li>
<li><p>序号和确认序号，可以解决顺序问题</p>
</li>
<li><p>如果没有收到就应该重新发送，直到送达，可以解决不丢包的问题</p>
</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://static001.geekbang.org/resource/image/c0/08/c067fe62f49e8152368c7be9d91adc08.jpg" alt="img"></p>
<ul>
<li>一开始，客户端和服务端都处于 CLOSED 状态</li>
<li>先是服务端主动监听某个端口，处于 LISTEN 状态</li>
<li>然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态</li>
<li>服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态</li>
<li>客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态</li>
<li>服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态</li>
</ul>
<h3 id="为什么三次握手？"><a href="#为什么三次握手？" class="headerlink" title="为什么三次握手？"></a>为什么三次握手？</h3><ul>
<li>包是可能丢的，所以起码一来一回</li>
<li>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误<ul>
<li>A 和 B 原来建立了连接，做了简单通信后，结束了连接</li>
<li>A 建立连接的时候，请求包重复发了几次，有的请求包绕了一大圈又回来了</li>
<li>B 会认为这也是一个正常的的请求的话，因此建立了连接，但这个连接不会进行下去但也不会终结</li>
<li>因而两次握手肯定不行</li>
</ul>
</li>
<li>超过三次，也不能保证就真的可靠了，只要双方的消息都有去有回，就基本可以了</li>
<li>在大部分情况下，A 和 B 建立了连接之后，A 会马上发送数据的，一旦 A 发送数据，则很多问题都得到了解决</li>
</ul>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p><img src="https://static001.geekbang.org/resource/image/bf/13/bf1254f85d527c77cc4088a35ac11d13.jpg" alt="img"></p>
<ul>
<li><p>一方应用程序调用 close，我们称该方为主动关闭方，该端的 TCP 发送一个 FIN 包，表示需要关闭连接，然后进入 FIN_WAIT_1 状态</p>
</li>
<li><p>接着，接收到这个 FIN 包的对端执行被动关闭，被动关闭方进入 CLOSE_WAIT 状态</p>
<ul>
<li>这个 FIN 由 TCP 协议栈处理，TCP 协议栈为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，应用程序可以通过 read 调用来感知这个 FIN 包</li>
<li>这个 EOF 会被放在已排队等候的其他已接收的数据之后，这就意味着接收端应用程序需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达</li>
</ul>
</li>
<li><p>接下来，被动关闭方将读到这个 EOF，于是，应用程序也调用 close 关闭它的套接字，这导致它的 TCP 也发送一个 FIN 包，之后进入 LAST_ACK 状态。</p>
</li>
<li><p>最终，主动关闭方接收到对方的 FIN 包，并确认这个 FIN 包，进入 TIME_WAIT 状态</p>
</li>
<li><p>接收到 ACK 的被动关闭方则进入 CLOSED 状态</p>
</li>
<li><p>经过 2MSL 时间之后，主动关闭方也进入 CLOSED 状态</p>
</li>
</ul>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul>
<li><p>一种情况是，A 说完“不玩了”之后，直接跑路，是会有问题的，因为 B 还没有发起结束，而如果 A 跑路，B 就算发起结束，也得不到回答，B 就不知道该怎么办了</p>
</li>
<li><p>A 说完“不玩了”，B 直接跑路，也是有问题的，因为 A 不知道 B 是还有事情要处理，还是过一会儿会发送结束</p>
</li>
<li><p>同时断开时，如果主机在FIN_WAIT1状态下首先收到对端主机的FIN包的话，那么该主机在确认已经收到了对端主机全部的Data数据包后，就响应一个ACK给对端主机，然后自己进入CLOSEING状态，主机在CLOSEING状态下收到自己的FIN包的ACK包的话，那么就进入TIME WAIT 状态。于是TCP的主机两端同时发起FIN包进行断开连接，那么两端主机可能出现完全一样的状态转移 FIN_WAIT1——&gt;CLOSEING——-&gt;TIME_WAIT，也就会Client和Server最后同时进入TIME_WAIT状态</p>
</li>
<li><p>常用的三个状态是</p>
<ul>
<li>ESTABLISHED表示正在通信 </li>
<li>TIME_WAIT表示主动关闭</li>
<li>CLOSE_WAIT表示被动关闭</li>
</ul>
</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li><p>如果服务器出现了异常，很大的可能是出现了以下两种情况</p>
<ul>
<li>服务器保持了大量的TIME_WAIT状态</li>
<li>服务器保持了大量的CLOSE_WAIT状态 </li>
</ul>
</li>
<li><p>Linux系统中分给每个用户的文件句柄数是有限的，而TIME_WAIT和CLOSE_WAIT这两种状态如果一直被保持，那么意味着对应数目的通道(此处应理解为socket，一般一个socket会占用服务器端一个端口，服务器端的端口最大数是65535)一直被占用，一旦达到了上限，则新的请求就无法被处理，接着就是大量Too Many Open Files异常，然后tomcat、nginx、apache崩溃</p>
</li>
</ul>
<h4 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h4><h5 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h5><ul>
<li><p>TCP 连接终止时，主机 1 先发送 FIN 报文，主机 2 进入 CLOSE_WAIT 状态，并发送一个 ACK 应答</p>
</li>
<li><p>同时，主机 2 通过 read 调用获得 EOF，并将此结果通知应用程序进行主动关闭操作，发送 FIN 报文</p>
</li>
<li><p>在对方关闭连接后，程序里没有检测到，或者程序里本身就已经忘了这个时候需要关闭连接，于是这个资源就一直被程序占用着</p>
</li>
</ul>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ul>
<li>关闭正在运行的程序，这个需要视业务情况而定</li>
<li>尽快的修改程序里的bug，然后测试提交到线上服务器</li>
<li>服务端接口耗时较长，客户端主动断开了连接，此时，服务端就会出现 close_wait</li>
<li>如果代码不规范的话，在收到对方发起的fin后，自己根本就不会给人家发fin，反正close_wait基本就是自己这边的问题了</li>
</ul>
<h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><h5 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h5><ul>
<li><p>主机 1 在 TIME_WAIT 停留持续时间是固定的，是最长分节生命期 MSL（maximum segment lifetime）的两倍，一般称之为 2MSL</p>
<ul>
<li>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</li>
</ul>
</li>
<li><p>只有发起连接终止的一方会进入 TIME_WAIT 状态 </p>
</li>
</ul>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭<ul>
<li>如果主机 1 的 ACK 报文没有传输成功，那么主机 2 就会重新发送 FIN 报文</li>
<li>如果主机 1 没有维护 TIME_WAIT 状态，而直接进入 CLOSED 状态，它就失去了当前状态的上下文，只能回复一个 RST 操作，从而导致被动关闭方出现错误</li>
<li>现在主机 1 知道自己处于 TIME_WAIT 的状态，就可以在接收到 FIN 报文之后，重新发出一个 ACK 报文，使得主机 2 可以进入正常的 CLOSED 状态</li>
</ul>
</li>
<li>和连接“化身”和报文迷走有关系，为了让旧连接的重复分节在网络中自然消失<ul>
<li>如果主机1直接关闭，端口就直接空出来了，但是 主机 2不知道，主机 2 原来发过的很多包很可能还在路上，如果主机 1的端口被一个新的应用占用了，这个新的应用会收到上个连接中主机 2发过来的包，虽然序列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来主机 2发送的所有的包都死翘翘，再空出端口来</li>
</ul>
</li>
</ul>
<h5 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h5><ul>
<li>经过 2MSL 这个时间，足以让两个方向上的分组都被丢弃，使得原来连接的分组在网络中都自然消失，再出现的分组一定都是新化身所产生的</li>
<li>这个时间要足够长，长到如果 B 没收到 ACK 的话，“B 说不玩了”会重发的，A 会重新发一个 ACK 并且足够时间到达 B</li>
<li>2MSL 的时间是从主机 1 接收到 FIN 后发送 ACK 开始计时的</li>
<li>如果在 TIME_WAIT 时间内，因为主机 1 的 ACK 没有传输到主机 2，主机 1 又接收到了主机 2 重发的 FIN 报文，那么 2MSL 时间将重新计时</li>
<li>MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃</li>
</ul>
<h5 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h5><ul>
<li>内存资源占用，这个目前看来不是太严重，基本可以忽略</li>
<li>对端口资源的占用，一个 TCP 连接至少消耗一个本地端口</li>
<li>端口资源也是有限的，一般可以开启的端口为 32768～61000 ，也可以通过net.ipv4.ip_local_port_range指定，如果 TIME_WAIT 状态过多，会导致无法创建新连接 </li>
</ul>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><ul>
<li><p>优化内核参数</p>
<ul>
<li>调低 TCP_TIMEWAIT_LEN，重新编译系统这个方法是一个不错的方法</li>
<li>缺点是需要“一点”内核方面的知识，能够重新编译内核</li>
<li>这个不是大多数人能接受的方式</li>
</ul>
</li>
<li><p>net.ipv4.tcp_tw_reuse</p>
<ul>
<li>如果是安全可控的，可以复用处于 TIME_WAIT 的套接字为新的连接所用</li>
<li>只适用于连接发起方（C/S 模型中的客户端）</li>
<li>对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用</li>
<li>前提是打开对 TCP 时间戳的支持，即net.ipv4.tcp_timestamps=1（默认即为 1）</li>
<li>为了保证 TCP 的高可用，引入了新的 TCP 选项，两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。由于引入了时间戳，我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃</li>
</ul>
</li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>在对于包的确认中，同时会携带一个窗口 Advertised window，如果接收方实在处理的太慢，导致缓存中没有空间了，可以通过确认信息修改窗口的大小</li>
<li>甚至可以设置为 0，则发送方将暂时停止发送，此时发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小</li>
</ul>
<h3 id="糊涂窗口综合症-SWS-Silly-Window-Syndrome）"><a href="#糊涂窗口综合症-SWS-Silly-Window-Syndrome）" class="headerlink" title="糊涂窗口综合症 SWS(Silly Window Syndrome）"></a>糊涂窗口综合症 SWS(Silly Window Syndrome）</h3><h4 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h4><ul>
<li><p>少量的数据将通过连接进行交换，而不是满长度的报文段</p>
</li>
<li><p>该现象可发生在两端中的任何一端</p>
<ul>
<li>接收方通告一个小的窗口（而不是一直等到有大的窗口时才通告）</li>
<li>发送方发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）</li>
</ul>
</li>
</ul>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><ul>
<li><p>接收方不通告小窗口</p>
<ul>
<li>通常的算法是接收方不通告一个比当前窗口大的窗口（可以为0），直到窗口可以增加一个报文段大小或者可以接收方缓存空间的一半</li>
</ul>
</li>
<li><p>发送方，不应发送小的报文段，由Nagle算法控制何时发送</p>
<ul>
<li>可以发送一个满长度的报文段</li>
<li>可以发送至少是接收方通告窗口大小一半的报文段</li>
<li>某一 ACK 不是目前期盼的</li>
<li>该链接禁用 Nagle 算法</li>
</ul>
</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li><p>通过窗口 cwnd 大小来控制的，防止把网络塞满，导致包丢失和超时重传</p>
</li>
<li><p>这里有一个公式 LastByteSent - LastByteAcked &lt;= min {cwnd, rwnd} ，是拥塞窗口和滑动窗口共同控制发送的速度</p>
<ul>
<li>通道的容量 = 带宽 × 往返延迟</li>
<li>如果我们设置发送窗口，使得发送但未确认的包为为通道的容量，就能够撑满整个管道</li>
</ul>
</li>
<li><p>一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个</p>
</li>
<li><p>每收到一个确认 cwnd 加一，指数性的增长</p>
</li>
<li><p>直到 ssthresh 为 65535 个字节，当超过这个值的时候慢下来</p>
</li>
<li><p>每收到一个确认 cwnd 增加 1/cwnd，我们接着上面的过程来，变成了线性增长</p>
</li>
<li><p>直到有一天，水满则溢，出现了拥塞，这个时候将 sshresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动</p>
<ul>
<li>拥塞的一种表现形式是丢包，需要超时重传</li>
<li>但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿</li>
</ul>
</li>
<li><p>快速重传算法</p>
<ul>
<li>当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传</li>
<li>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，cwnd 减半为 cwnd/2，然后 sshthresh = cwnd</li>
<li>当三个包返回的时候，cwnd = sshthresh + 3，还在比较高的值，呈线性增长</li>
</ul>
</li>
<li><p>为了优化这两个问题，后来有了 TCP BBR 拥塞算法</p>
</li>
</ul>
<h2 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li><p>TCP  协议是基于字节流的传输层协议，其中不存在消息和数据包的概念</p>
</li>
<li><p>当应用层协议通过 TCP 协议传输数据时，实际上待发送的数据先被写入了 TCP 协议的缓冲区，等待缓冲区中数据超过最大数据段（MSS）或者上一个数据段被 ACK 时才会发送缓冲区中的数据</p>
</li>
<li><p>可能会导致应用层协议多次写入的数据被合并或者拆分发送</p>
</li>
<li><p>应用层协议没有使用基于长度或者基于终结符的消息边界，导致多个消息的粘连</p>
</li>
<li><p>当接收方从  TCP 协议栈中读取数据时会发现不相关的数据出现在了同一个数据段中，应用层协议可能没有办法对它们进行拆分和重组</p>
</li>
<li><p>UDP  是有消息边界的，每个 UDP 数据包都表示一个完整的消息，所以不会出现粘包</p>
<ul>
<li>应用层的数据包大小应该尽可肯能接近 UDP 的最大负荷，可以充分利用带宽</li>
</ul>
</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>不停轮询</p>
<ul>
<li>看能不能反序列包头，再拆包头反序列化出包体长度值</li>
<li>比较跟收到的包体的是否一致</li>
<li>然后取出包体，再尝试反序列化</li>
</ul>
</li>
<li><p>使用基于长度或者基于终结符的消息边界</p>
</li>
</ul>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li><p>流媒体的协议</p>
<ul>
<li>对于丢包，其实对于视频播放来讲，有的包可以丢，有的包不能丢，因为视频的连续帧里面，有的帧重要，有的不重要，如果必须要丢包，隔几个帧丢一个，其实看视频的人不会感知，但是如果连续丢帧，就会感知了，因而在网络不好的情况下，应用希望选择性的丢帧</li>
</ul>
</li>
<li><p>游戏对实时要求较为严格的情况下，采用自定义的可靠 UDP 协议，自定义重传策略，能够把丢包产生的延迟降到最低 </p>
</li>
</ul>
<h2 id="可靠-UDP（Google-的-QUIC-协议）"><a href="#可靠-UDP（Google-的-QUIC-协议）" class="headerlink" title="可靠 UDP（Google 的 QUIC 协议）"></a>可靠 UDP（Google 的 QUIC 协议）</h2><ul>
<li><p>自定义连接机制</p>
<ul>
<li>面向连接</li>
<li>一条 TCP 连接是由四元组标识的，分别是源 IP、源端口、目的 IP、目的端口</li>
<li>一旦一个元素发生变化时，就需要断开重连，重新连接</li>
<li>在移动互联情况下，当手机信号不稳定或者在 WIFI 和 移动网络切换时，都会导致重连，从而进行再次的三次握手，导致一定的时延</li>
<li>基于 UDP，就可以在 QUIC 自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个 64 位的随机数作为 ID 来标识，而且 UDP 是无连接的，所以当 IP 或者端口变化的时候，只要 ID 不变，就不需要重新建立连接</li>
</ul>
</li>
<li><p>自定义重传机制</p>
<ul>
<li>前面我们讲过，TCP 为了保证可靠性，通过使用序号和应答机制，来解决顺序问题和丢包问题</li>
<li>任何一个序号的包发过去，都要在一定的时间内得到应答，否则一旦超时，就会重发这个序号的包</li>
<li>这个超时是通过采样往返时间 RTT 不断调整的，在 TCP 里面超时的采样存在不准确的问题</li>
<li>QUIC 也有个递增的序列号，任何一个序列号的包只发送一次，下次就要加一了，RTT 计算相对准确</li>
<li>QUIC 定义了一个 offset 概念<ul>
<li>发送的数据在这个数据流里面有个偏移量 offset，可以通过 offset 查看数据发送到了哪里，这样只要这个 offset 的包没有来，就要重发</li>
<li>QUIC 的 ACK 是基于 offset 的，每个 offset 的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空档会等待到来或者重发即可</li>
<li>如果来了，按照 offset 拼接成一个流</li>
</ul>
</li>
</ul>
</li>
<li><p>无阻塞的多路复用</p>
<ul>
<li>有了自定义的连接和重传机制，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求</li>
<li>但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖</li>
</ul>
</li>
<li><p>自定义流量控制</p>
<ul>
<li>TCP 的流量控制是通过滑动窗口协议</li>
<li>QUIC 的流量控制也是通过 window_update，来告诉对端它可以接受的字节数</li>
<li>但是 QUIC 的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个 stream 控制窗口</li>
<li>窗口的起始位置为当前收到的最大 offset，从这个 offset 到当前的 stream 所能容纳的最大缓存，是真正的窗口大小</li>
<li>整个连接的窗口，需要对于所有的 stream 的窗口做一个统计</li>
</ul>
</li>
</ul>
<h1 id="TCP-v-s-UDP"><a href="#TCP-v-s-UDP" class="headerlink" title="TCP v.s. UDP"></a>TCP v.s. UDP</h1><ul>
<li><p>TCP 是面向连接的，UDP 是面向无连接的</p>
<ul>
<li>所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性</li>
</ul>
</li>
<li><p>TCP 提供可靠交付，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达；UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达</p>
</li>
<li><p>TCP 是面向字节流的，发送的时候发的是一个流，没头没尾；UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收</p>
</li>
<li><p>TCP 是可以有拥塞控制的；UDP 就不会，应用让我发，我就发，管它洪水滔天</p>
</li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="输入网址后发生了什么"><a href="#输入网址后发生了什么" class="headerlink" title="输入网址后发生了什么"></a>输入网址后发生了什么</h2><ul>
<li><p>浏览器会将 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 这个域名发送给 DNS 服务器，让它解析为 IP 地址</p>
</li>
<li><p>HTTP 是基于 TCP 协议的，要先建立 TCP 连接了</p>
</li>
<li><p>构建HTTP请求</p>
<ul>
<li><p>在 HTTP 头里面，Cache-control 是用来控制缓存的</p>
<ul>
<li>当客户端发送的请求中包含 max-age 指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源</li>
<li>当指定 max-age 值为 0，那么缓存层通常需要将请求转发给应用集群</li>
</ul>
</li>
<li><p>If-Modified-Since 也是一个关于缓存的</p>
<ul>
<li>如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源</li>
<li>如果没有更新，服务端会返回“304 Not Modified”的响应，那客户端就不用下载了，也会节省带宽</li>
</ul>
</li>
</ul>
</li>
</ul>
<p> <img src="https://static001.geekbang.org/resource/image/85/c1/85ebb0396cbaa45ce00b505229e523c1.jpeg" alt="img">  </p>
<ul>
<li><p>发送 HTTP 请求</p>
<ul>
<li>HTTP 协议是基于 TCP 协议的，所以它通过 stream 二进制流的方式传给对方</li>
</ul>
</li>
<li><p>TCP 层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址），将这两个信息放到 IP 头里面，交给 IP 层进行传输</p>
</li>
<li><p>IP 层需要查看目标地址和自己是否是在同一个局域网</p>
<ul>
<li>如果是，就发送 ARP 协议来请求这个目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放入 MAC 头，发送出去即可</li>
<li>如果不在同一个局域网，就需要发送到网关，还要需要发送 ARP 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC 头，发送出去</li>
</ul>
</li>
<li><p>网关收到包发现 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，将包发给下一跳路由器</p>
</li>
<li><p>这样路由器一跳一跳终于到达目标的局域网</p>
</li>
<li><p>最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上。于是，在这个局域网上发送 ARP，获得这个目标地址的 MAC 地址，将包发出去</p>
</li>
<li><p>目标的机器发现 MAC 地址符合，就将包收起来</p>
</li>
<li><p>发现 IP 地址符合，根据 IP 头中协议项，知道自己上一层是 TCP 协议，于是解析 TCP 的头，里面有序列号，需要看一看这个序列包是不是我要的</p>
<ul>
<li>如果是就放入缓存中然后返回一个 ACK</li>
<li>如果不是就丢弃</li>
</ul>
</li>
<li><p>TCP 头里面还有端口号，HTTP 的服务器正在监听这个端口号，目标机器就知道是 HTTP 服务器这个进程想要这个包，于是将包发给 HTTP 服务器</p>
</li>
<li><p>HTTP 服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端</p>
</li>
<li><p>HTTP 返回的构建 </p>
</li>
</ul>
<p> <img src="https://static001.geekbang.org/resource/image/6b/63/6bc37ddcb4e7a61ca3275790820f2263.jpeg" alt="img">  </p>
<ul>
<li><p>构造好了返回的 HTTP 报文，接下来就是把这个报文发送出去 </p>
</li>
<li><p>交给 Socket 去发送，还是交给 TCP 层，让 TCP 层将返回的 HTML，也分成一个个小的段，并且保证每个段都可靠到达</p>
</li>
<li><p>这些段加上 TCP 头后会交给 IP 层，然后把刚才的发送过程反向走一遍</p>
</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><ul>
<li><p>HTTP规定了新的协议名“https”，默认端口号 443</p>
</li>
<li><p>其他的什么请求 - 应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用 HTTP</p>
</li>
<li><p>HTTP 不是安全的，而且攻击者可以通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%A3%E8%81%BD">监听</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a>等手段，获取网站帐户和敏感信息等</p>
</li>
<li><p>HTTPS 在 TCP 和 HTTP 之间插入一个安全层，让 HTTP 运行在了安全的 SSL/TLS 协议上，所有经过安全层的数据都会被加密或者解密</p>
</li>
</ul>
<h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><ul>
<li>非对称加密速度太慢，所以一般实现都是，使用非对称加密加密密钥，然后使用新的密钥进行对称加密的通讯 </li>
<li>机密性由对称加密保证，完整性由摘要算法保证，身份认证和不可否认由非对称加密保证</li>
</ul>
<h2 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h2><p><img src="https://static001.geekbang.org/resource/image/77/af/77c852ff2202b2b7bb3299a96a0f4aaf.png" alt="img"></p>
<ul>
<li><p>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random</p>
</li>
<li><p>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和数字证书，而公钥正是包含在数字证书中的</p>
</li>
<li><p>在浏览器端验证了证书</p>
</li>
<li><p>浏览器生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据</p>
</li>
<li><p>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息</p>
</li>
<li><p>服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥</p>
</li>
<li><p>有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了</p>
</li>
</ul>
<h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><ul>
<li><p>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化</p>
</li>
<li><p>SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层）</p>
</li>
<li><p>目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1/1.0、SSLv3/v2）都已经被认为是不安全的</p>
</li>
<li><p>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术</p>
</li>
<li><p>浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）</p>
<ul>
<li>ECDHE-RSA-AES256-GCM-SHA384</li>
<li>其实 TLS 的密码套件命名非常规范，格式很固定，基本的形式是“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”</li>
<li>“握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数</li>
</ul>
</li>
<li><p>OpenSSL，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能</p>
</li>
</ul>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><ul>
<li><p>本地证书是用来做双向认证的，服务器用客户端的证书来验证客户端的证书</p>
</li>
<li><p>通常我们上网是单向认证，只验证服务器的身份，客户端（也就是用户）的身份不用证书验证</p>
</li>
</ul>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><h3 id="数字证书申请"><a href="#数字证书申请" class="headerlink" title="数字证书申请 "></a>数字证书申请 <img src="https://static001.geekbang.org/resource/image/f5/a6/f569c80f8f4b25b3bf384037813cdca6.png" alt="img"></h3><h3 id="浏览器验证证书"><a href="#浏览器验证证书" class="headerlink" title="浏览器验证证书"></a>浏览器验证证书</h3><ul>
<li><p>浏览器需要验证证书的有效期、证书是否被 CA 吊销、证书是否是合法的 CA 机构颁发的 </p>
</li>
<li><p>验证极客时间的数字证书是否是 CA 机构颁发的</p>
<p><img src="https://static001.geekbang.org/resource/image/ae/08/ae7dbe9f8785441721deb1f7b316f708.png" alt="img"> </p>
</li>
<li><p>浏览器是怎么获取到 CA 公钥</p>
<ul>
<li>部署 HTTP 服务器的时候，除了部署当前的数字证书之外，还需要部署 CA 机构的数字证书，CA 机构的数字证书包括了 CA 的公钥，以及 CA 机构的一些基础信息</li>
<li>然后在建立 HTTPS 链接时，服务器会将这两个证书一同发送给浏览器，于是浏览器就可以获取到 CA 的公钥了</li>
</ul>
</li>
<li><p>证明 CA 的合法性，妥协的方案是，直接在操作系统中内置这些 CA 机构的数字证书</p>
</li>
<li><p>CA 机构众多，因此操作系统不可能将每家 CA 的数字证书都内置进操作系统</p>
</li>
<li><p>数字证书链</p>
<ul>
<li>就要了解我们的CA机构也是分两种类型的，中间CA(Intermediates CAs)和根CA(Root CAs)，通常申请者都是向中间CA去申请证书的，而根CA作用就是给中间CA做认证，通常，一个根CA会认证很多中间的CA，而这些中间CA又可以去认证其它的中间CA</li>
<li>浏览器的做法很简单，它会查找系统的根证书，如果这个根证书在操作系统里面，那么浏览器就认为这个根证书是合法的，如果验证的根证书不在操作系统里面，那么就是不合法的</li>
<li>而操作系统里面这些内置的根证书也不是随便内置的，这些根CA都是通过WebTrust国际安全审计认证</li>
</ul>
</li>
<li><p>流程</p>
<ul>
<li>首先 CA 使用 Hash 函数来计算极客时间提交的明文信息，并得出信息摘要</li>
<li>然后 CA 再使用它的私钥对信息摘要进行加密，加密后的密文就是 CA 颁给极客时间的数字签名</li>
<li>浏览器接收到数字证书之后，会对数字证书进行验证<ul>
<li>首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A</li>
<li>然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B</li>
<li>对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的</li>
<li>同时浏览器还会验证证书相关的域名信息、有效时间等信息</li>
</ul>
</li>
</ul>
</li>
<li><p>内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书</p>
</li>
<li><p>这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性</p>
</li>
<li><p>通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法</p>
</li>
</ul>
<p>## WebSocket</p>
<p>* “WebSocket”是一种基于 TCP 的轻量级网络通信协议，在地位上是与 HTTP“平级”的</p>
<p>* 是为了解决 HTTP “请求 - 应答”通信模式的缺陷而诞生的，因为这种“半双工”的通信模式，虽然可以双向收发数据，但同一时刻只能一个方向上有动作，传输效率低。更关键的一点，它是一种“被动”通信模式，服务器只能“被动”响应客户端的请求，无法主动向客户端发送数据</p>
<p>* 通常是通过轮询也就是不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果，反复发送无效查询请求耗费了大量的带宽和 CPU 资源</p>
<p>* 这就导致 HTTP 难以应用在动态页面、即时消息、网络游戏等要求“实时通信”的领域</p>
<p>* WebSocket 是一个真正“全双工”的通信协议，与 TCP 一样，客户端和服务器都可以随时向对方发送数据，一旦后台有新的数据，就可以立即“推送”给客户端，不需要客户端轮询，“实时通信”的效率也就提高了</p>
<p>* 服务发现方面，WebSocket 延用了 HTTP 的 URI 格式，引入“ws”和“wss”，分别表示明文和加密的 WebSocket 协议</p>
<p>* WebSocket 的默认端口也选择了 80 和 443</p>
<p>* WebSocket 采用了二进制帧结构长度不固定，最少 2 个字节，最多 14 字节</p>
<p>* WebSocket 的帧头就四个部分：“结束标志位 + 操作码 + 帧长度 + 掩码</p>
<p>* WebSocket 也要有一个握手过程，然后才能正式收发数据</p>
<p> * 利用了 HTTP 本身的“协议升级”特性，“伪装”成 HTTP，这样就能绕过浏览器沙盒、网络防火墙等等限制</p>
<p> * WebSocket 的握手是一个标准的 HTTP GET 请求，但要带上两个协议升级的专用头字段，为了防止普通的 HTTP 消息被“意外”识别成 WebSocket，握手消息还增加了两个额外的认证用头字段</p>
<p>  * “Connection: Upgrade”，表示要求协议“升级”；</p>
<p>  * “Upgrade: websocket”，表示要“升级”成 WebSocket 协议</p>
<p>  * Sec-WebSocket-Key：一个 Base64 编码的 16 字节随机数，作为简单的认证密钥</p>
<p>  * Sec-WebSocket-Version：协议的版本号，当前必须是 13</p>
<p>* 服务器收到 HTTP 请求报文，看到上面的四个字段，就知道这不是一个普通的 GET 请求，而是 WebSocket 的升级请求，于是就不走普通的 HTTP 处理流程，而是构造一个特殊的“101 Switching Protocols”响应报文，通知客户端，接下来就不用 HTTP 了，全改用 WebSocket 协议通信</p>
<p> * 响应报文也是有特殊格式的，要用字段“Sec-WebSocket-Accept”验证客户端请求报文，同样也是为了防止误连接</p>
<p>* 使用场景</p>
<p> * IM通信，实时互动，回调响应，数据实时同步</p>
<p>## Web 安全</p>
<p>### XSS 漏洞</p>
<p>* 通过 XSS 漏洞，黑客可以在 Web 应用中嵌入自己的 JavaScript 脚本，从而篡改 Web 应用在用户浏览器上的行为</p>
<p>* 通过 XSS，黑客一方面可以模拟用户，直接在 Web 应用中进行发博关注等互动行为</p>
<p>* 另一方面，也可以通过 JavaScript 脚本，窃取到用户的 Cookie 信息。窃取到 Cookie 之后，黑客就能够在不知道密码的情况下，绕过登录认证环节，直接获得用户身份。</p>
<p><img src="https://static001.geekbang.org/resource/image/7d/f5/7d77973b1623717cd519b0d3f8b7d4f5.jpg" alt="img"> </p>
<p>### SQL 注入漏洞</p>
<p>* 通过 SQL 注入漏洞，黑客可以利用所谓的“万能密码”，直接对登录环节进行破解。通过“万能密码”，黑客可以将原本的登录认证 SQL 语句进行篡改，使其变成一个恒为真的表达式，让应用误以为黑客输入的是正确的用户名和密码。这样，黑客就能破解登录认证环节，直接获得用户身份。</p>
<p><img src="https://static001.geekbang.org/resource/image/dc/28/dca53475b9ec945b9bd3dd30f37b6328.jpg" alt="img"> </p>
<p>* ### CSRF 漏洞</p>
<p>* 最后一个是 CSRF 漏洞。通过 CSRF 漏洞，黑客能够直接对用户的浏览器进行控制。当黑客在自己的网页中，向其他网页发起跨域请求的时候，浏览器会自动带上对应网页的 Cookie 等信息。因此只要用户之前进行过认证，并且已经将登录凭证保存在浏览器中，黑客就能以用户的身份发起未授权的操作请求。</p>
<p><img src="https://static001.geekbang.org/resource/image/5c/70/5c0e68d5766befd701ab3f3fae3eea70.jpg" alt="img"> </p>
<h1 id="Domain-Name-System-DNS"><a href="#Domain-Name-System-DNS" class="headerlink" title="Domain Name System, DNS"></a>Domain Name System, DNS</h1><h2 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h2><ul>
<li>将主机名到IP地址转换的目录服务</li>
<li>DNS 服务器，一定要设置成高可用、高并发和分布式的<ul>
<li>每个人上网，都需要访问它，一旦它出了故障，整个互联网都将瘫痪</li>
<li>另外，上网的人分布在全世界各地，如果大家都去同一个地方访问某一台服务器，时延将会非常大</li>
</ul>
</li>
<li>因此 DNS 服务器是树状的层次结构<ul>
<li>根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址</li>
<li>顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址</li>
<li>权威 DNS 服务器 ：返回相应主机的 IP 地址</li>
</ul>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/89/4d/890ff98fde625c6a60fb71yy22d8184d.jpg" alt="img"></p>
<h2 id="DNS-解析流程"><a href="#DNS-解析流程" class="headerlink" title="DNS 解析流程"></a>DNS 解析流程</h2><p><img src="https://static001.geekbang.org/resource/image/71/e8/718e3a1a1a7927302b6a0f836409e8e8.jpg" alt="img"></p>
<ul>
<li>为了提高 DNS 的解析性能，很多网络都会就近部署 DNS 缓存服务器</li>
<li>电脑客户端会发出一个 DNS 请求，问 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 的 IP 是啥啊，并发给本地域名服务器 (本地 DNS)<ul>
<li>那本地域名服务器 (本地 DNS) 是什么呢？如果是通过 DHCP 配置，本地 DNS 由你的网络服务商（ISP），如电信、移动等自动分配，它通常就在你网络服务商的某个机房</li>
<li>本地 DNS 收到来自客户端的请求</li>
<li>可以想象这台服务器上缓存了一张域名与之对应 IP 地址的大表格</li>
<li>如果能找到 <a target="_blank" rel="noopener" href="http://www.163.com,它就直接返回/">www.163.com，它就直接返回</a> IP 地址</li>
</ul>
</li>
<li>如果没有，本地 DNS 会去问它的根域名服务器：“老大，能告诉我 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 的 IP 地址吗？”<ul>
<li>根域名服务器是最高层次的，全球共有 13 套</li>
<li>它不直接用于域名解析，它发现请求的后缀是 .com，返回相应的顶级域名服务器的地址”</li>
</ul>
</li>
<li>本地 DNS 转向问顶级域名服务器：“老二，你能告诉我 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 的 IP 地址吗？”<ul>
<li>顶级域名服务器就是大名鼎鼎的比如 .com、.net、 .org 这些一级域名，它负责管理二级域名，比如 163.com</li>
<li>顶级域名服务器说：“我给你负责 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到。”</li>
</ul>
</li>
<li>本地 DNS 转向问权威 DNS 服务器：“您好，<a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 对应的 IP 是啥呀？”<ul>
<li>163.com 的权威 DNS 服务器，它是域名解析结果的原出处</li>
<li>为啥叫权威呢？就是我的域名我做主</li>
<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS</li>
</ul>
</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接</li>
</ul>
<h1 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h1><ul>
<li><p>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序</p>
</li>
<li><p>字节序分为两类：Big-Endian 和 Little-Endian</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/663581/1602998743124-f28edbdb-e49f-4648-837f-b8880e11f5c8.png" alt="img"></p>
</li>
</ul>
<ul>
<li>Little-Endian<ul>
<li>就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端</li>
</ul>
</li>
<li>Big-Endian<ul>
<li>就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</li>
</ul>
</li>
<li>网络字节序<ul>
<li>TCP/IP各层协议将字节序定义为 Big-Endian（这与主机序相反），因此TCP/IP协议中使用的字节序通常称之为网络字节序</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/12/RPC-%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/12/RPC-%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">RPC 远程过程调用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-12 21:01:04" itemprop="dateCreated datePublished" datetime="2021-06-12T21:01:04+08:00">2021-06-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-14 22:20:36" itemprop="dateModified" datetime="2021-06-14T22:20:36+08:00">2021-06-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Distributed-System/" itemprop="url" rel="index"><span itemprop="name">Distributed System</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li>RPC 框架有明显朝着更高层次（不仅仅负责调用远程服务，还管理远程服务）与插件化方向发展的趋势<ul>
<li>不再选择自己去解决表示数据、传递数据和表示方法这三个问题</li>
<li>而是将全部或者一部分问题设计为扩展点，实现核心能力的可配置</li>
<li>再辅以外围功能，如负载均衡、服务注册、可观察性等方面的支持</li>
</ul>
</li>
</ul>
<h1 id="常见框架-协议"><a href="#常见框架-协议" class="headerlink" title="常见框架/协议"></a>常见框架/协议</h1><ul>
<li>RMI（Sun/Oracle）</li>
<li>Thrift（Facebook/Apache）</li>
<li>Dubbo（阿里巴巴 /Apache）</li>
<li>gRPC（Google）</li>
<li>Motan2（新浪）</li>
<li>Finagle（Twitter）</li>
<li>brpc（百度）</li>
<li>.NET Remoting（微软）</li>
<li>Arvo（Hadoop）</li>
<li>JSON-RPC 2.0（公开规范，JSON-RPC 工作组）</li>
</ul>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Remote Procedure Call，即远程过程调用，是帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul>
<li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法</li>
<li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑</li>
<li>RPC只是服务（进程）之间简化调用的一种方式，使得开发者聚焦于业务本身，而对于服务间通信的各种细节交给框架处理，分布式系统的服务调用可以采用任何一种通信方式，比如http、socket等等</li>
</ul>
<h1 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>发起调用请求的那一方叫做调用方</li>
<li>被调用的一方叫做服务提供方</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><ul>
<li>RPC 是一个远程调用，那肯定就需要通过<strong>网络来传输数据</strong>，并且 RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输</li>
<li>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象</li>
<li>对象是肯定没法直接在网络中传输的，需要提前把它转成可传输的二进制，并且要求转换算法是可逆的</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><p>我们把数据格式的约定内容叫做“协议”</p>
</li>
<li><p>大多数的协议会分成两部分，分别是数据头和消息体</p>
<ul>
<li>数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息</li>
<li>消息体主要是请求的业务参数信息和扩展属性等</li>
</ul>
</li>
</ul>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><ul>
<li><p>根据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来</p>
</li>
<li><p>同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象</p>
</li>
<li><p>服务提供方再根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用</p>
</li>
<li><p>然后把执行结果序列化后，回写到对应的 TCP 通道里面</p>
</li>
<li><p>调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用</p>
</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul>
<li><p>RPC 框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面</p>
</li>
<li><p>该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用</p>
</li>
<li><p>并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验</p>
</li>
</ul>
<h1 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h1><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><ul>
<li>相对于 HTTP 的用处，RPC 更多的是负责应用间的通信，所以<strong>性能</strong>要求相对更高</li>
<li>对于要求高性能的 RPC 来说，HTTP 协议基本很难满足需求，所以 RPC 会选择设计更<strong>紧凑</strong>的私有协议<ul>
<li>HTTP 协议的<strong>数据包大小</strong>相对请求数据本身要大很多，又需要加入很多无用的内容，比如换行符号、回车符等</li>
<li>HTTP 协议属于无状态协议，客户端无法对请求和响应进行关联，每次请求都需要重新建立连接，响应完成后再关闭连接</li>
</ul>
</li>
</ul>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="协议头"><a href="#协议头" class="headerlink" title="协议头"></a>协议头</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p>RPC 每次发请求发的大小都是不固定的，所以我们的协议必须能让接收方正确地读出不定长的内容</p>
</li>
<li><p>我们可以先固定一个长度（比如 4 个字节）用来保存整个请求数据大小，这样收到数据的时候，我们先读取固定长度的位置里面的值，值的大小就代表协议体的长度，接着再根据值的大小来读取协议体的数据</p>
</li>
<li><p>需要把序列化方式单独拿出来，类似协议长度一样用固定的长度存放</p>
</li>
<li><p>这些需要固定长度存放的参数我们可以统称为“协议头”，这样整个协议就会拆分成两部分：协议头和协议体</p>
<ul>
<li><p>在协议头里面，我们除了会放协议长度、序列化方式，还会放一些像协议标示、消息 ID、消息类型这样的参数</p>
</li>
<li><p>协议体一般只放请求接口方法、请求的业务参数值和一些扩展属性</p>
<p><img src="https://static001.geekbang.org/resource/image/ac/2b/ac5f5236d972608fdb24c6eefce7e82b.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h4 id="可扩展的协议"><a href="#可扩展的协议" class="headerlink" title="可扩展的协议"></a>可扩展的协议</h4><ul>
<li><p>关键在于让协议头支持可扩展，扩展后协议头的长度就不能定长了</p>
</li>
<li><p>需要一个固定的写入协议头的长度</p>
</li>
<li><p>整体协议就变成了三部分内容</p>
<ul>
<li>固定部分</li>
<li>协议头内容</li>
<li>协议体内容</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/2a/72/2a202f980458baca9fc50c53275c6772.jpg" alt="img"></p>
</li>
</ul>
<h4 id="如何实现请求跟响应关联"><a href="#如何实现请求跟响应关联" class="headerlink" title="如何实现请求跟响应关联"></a>如何实现请求跟响应关联</h4><ul>
<li><p>RPC 为了吞吐量，会异步并发发送请求，等待应答</p>
</li>
<li><p>以 Dubbo 为例，消费者发送请求时，使用 AtomicLong 自增，产生一个 消息 ID</p>
<ul>
<li>由于 Dubbo 底层 IO 操作是异步的，Dubbo 发送请求之后，需要阻塞等待消费者返回信息</li>
<li>消费者会将消息 ID 保存到 Map 结构中</li>
<li>为了保证请求响应可以一一对应，需要提供者返回的响应信息带上请求者消息 ID</li>
<li>通过响应的消息 ID和  Map 存储数据，就能找到对应的请求</li>
</ul>
</li>
</ul>
<h1 id="如何表示数据-序列化"><a href="#如何表示数据-序列化" class="headerlink" title="如何表示数据-序列化"></a>如何表示数据-序列化</h1><h2 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h2><ul>
<li>无论是将参数传递给另外一个进程，还是从另外一个进程中取回执行结果，都会涉及应该如何表示的问题</li>
<li>因为涉及到跨语言调用，即使是只支持同一种语言的 RPC 协议，在不同硬件指令集、不同操作系统下，也完全可能有不一样的表现细节，比如数据宽度、字节序的差异等</li>
<li>将交互双方涉及的数据，转换为某种事先约定好的中立数据流格式来传输，将数据流转换回不同语言中对应的数据类型来使用，这其实就是序列化与反序列化</li>
<li>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象</li>
<li>对象是不能直接在网络中传输的，所以我们需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，这个过程我们一般叫做“序列化”</li>
<li>服务提供方就可以正确地从二进制数据中分割出不同的请求，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象，这个过程我们称之为“反序列化”</li>
</ul>
<h2 id="常用序列化"><a href="#常用序列化" class="headerlink" title="常用序列化"></a>常用序列化</h2><h3 id="JDK-原生序列化"><a href="#JDK-原生序列化" class="headerlink" title="JDK 原生序列化"></a>JDK 原生序列化</h3><ul>
<li>我们可以看到，JDK 自带的序列化机制对使用者而言是非常简单的</li>
<li>序列化具体的实现是由 ObjectOutputStream 完成的，而反序列化的具体实现是由 ObjectInputStream 完成的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        String home = System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">        String basePath = home + <span class="string">&quot;/Desktop&quot;</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(basePath + <span class="string">&quot;student.dat&quot;</span>);</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setNo(<span class="number">100</span>);</span><br><span class="line">        student.setName(<span class="string">&quot;TEST_STUDENT&quot;</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        oos.writeObject(student);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(basePath + <span class="string">&quot;student.dat&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        Student deStudent = (Student) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(deStudent);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>序列化过程就是在读取对象数据的时候，不断加入一些特殊分隔符，这些特殊分隔符用于在反序列化过程中截断用</p>
<ul>
<li>头部数据用来声明序列化协议、序列化版本，用于高低版本向后兼容</li>
<li>对象数据主要包括类名、签名、属性名、属性类型及属性值，当然还有开头结尾等数据，除了属性值属于真正的对象值，其他都是为了反序列化用的元数据</li>
<li>存在对象引用、继承的情况下，就是递归遍历“写对象”逻辑</li>
</ul>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul>
<li>JSON 是典型的 Key-Value 方式，没有数据类型，是一种文本型序列化框架</li>
<li>如果 RPC 框架选用 JSON 序列化，服务提供者与服务调用者之间传输的数据量要相对较小，否则将严重影响性能</li>
</ul>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>JSON 进行序列化的额外空间开销比较大，对于大数据量服务这意味着需要巨大的内存和磁盘开销</li>
<li>JSON 没有类型，但像 Java 这种强类型语言，需要通过反射统一解决，所以性能不会太好</li>
</ul>
<h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>Hessian 是动态类型、二进制、紧凑的，并且可跨语言移植的一种序列化框架</li>
<li>Hessian 协议要比 JDK、JSON 更加紧凑，性能上要比 JDK、JSON 序列化高效很多，而且生成的字节数也更小</li>
</ul>
<h4 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>Hessian 官方版本对 Java 里面一些常见对象的类型不支持<ul>
<li>Linked 系列，LinkedHashMap、LinkedHashSet 等，但是可以通过扩展 CollectionDeserializer 类修复</li>
<li>Locale 类，可以通过扩展 ContextSerializerFactory 类修复</li>
<li>Byte/Short 反序列化的时候变成 Integer</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setNo(<span class="number">101</span>);</span><br><span class="line">student.setName(<span class="string">&quot;HESSIAN&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把student对象转化为byte数组</span></span><br><span class="line">ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">Hessian2Output output = <span class="keyword">new</span> Hessian2Output(bos);</span><br><span class="line">output.writeObject(student);</span><br><span class="line">output.flushBuffer();</span><br><span class="line"><span class="keyword">byte</span>[] data = bos.toByteArray();</span><br><span class="line">bos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//把刚才序列化出来的byte数组转化为student对象</span></span><br><span class="line">ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(data);</span><br><span class="line">Hessian2Input input = <span class="keyword">new</span> Hessian2Input(bis);</span><br><span class="line">Student deStudent = (Student) input.readObject();</span><br><span class="line">input.close();</span><br><span class="line"></span><br><span class="line">System.out.println(deStudent);</span><br></pre></td></tr></table></figure>

<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><ul>
<li>Protobuf 是 Google 公司内部的混合语言数据标准，是一种轻便、高效的结构化数据存储格式，可以用于结构化数据序列化，支持 Java、Python、C++、Go 等语言</li>
<li>Protobuf 使用的时候需要定义 IDL（Interface description language），然后使用不同语言的 IDL 编译器，生成序列化工具类</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>序列化后体积相比 JSON、Hessian 小很多</li>
<li>IDL 能清晰地描述语义，所以足以帮助并保证应用程序之间的类型不会丢失，无需类似 XML 解析器</li>
<li>序列化反序列化速度很快，不需要通过反射获取类型</li>
<li>消息格式升级和兼容性不错，可以做到向后兼容</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // IDL 文件格式</span></span><br><span class="line"><span class="comment"> * synax = &quot;proto3&quot;;</span></span><br><span class="line"><span class="comment"> * option java_package = &quot;com.test&quot;;</span></span><br><span class="line"><span class="comment"> * option java_outer_classname = &quot;StudentProtobuf&quot;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * message StudentMsg &#123;</span></span><br><span class="line"><span class="comment"> * //序号</span></span><br><span class="line"><span class="comment"> * int32 no = 1;</span></span><br><span class="line"><span class="comment"> * //姓名</span></span><br><span class="line"><span class="comment"> * string name = 2;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line">StudentProtobuf.StudentMsg.Builder builder = StudentProtobuf.StudentMsg.newBuilder();</span><br><span class="line">builder.setNo(<span class="number">103</span>);</span><br><span class="line">builder.setName(<span class="string">&quot;protobuf&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把student对象转化为byte数组</span></span><br><span class="line">StudentProtobuf.StudentMsg msg = builder.build();</span><br><span class="line"><span class="keyword">byte</span>[] data = msg.toByteArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//把刚才序列化出来的byte数组转化为student对象</span></span><br><span class="line">StudentProtobuf.StudentMsg deStudent = StudentProtobuf.StudentMsg.parseFrom(data);</span><br><span class="line"></span><br><span class="line">System.out.println(deStudent);</span><br></pre></td></tr></table></figure>

<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>Protobuf 非常高效，但是对于具有反射和动态能力的语言来说，这样用起来很费劲，这一点就不如 Hessian</p>
</li>
<li><p>比如用 Java 的话，这个预编译过程不是必须的，可以考虑使用 Protostuff</p>
</li>
<li><p>Protostuff 不需要依赖 IDL 文件，可以直接对 Java 领域对象进行反 / 序列化操作</p>
</li>
<li><p>Protostuff 在效率上跟 Protobuf 差不多，生成的二进制格式和 Protobuf 是完全相同的，可以说是一个 Java 版本的 Protobuf 序列化框架</p>
</li>
<li><p>Protostuff 不支持单纯的 Map、List 集合对象，需要包在对象里面</p>
</li>
</ul>
<h3 id="Thrift，Avro"><a href="#Thrift，Avro" class="headerlink" title="Thrift，Avro"></a>Thrift，Avro</h3><h2 id="如何选择序列化框架"><a href="#如何选择序列化框架" class="headerlink" title="如何选择序列化框架"></a>如何选择序列化框架</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><img src="https://static001.geekbang.org/resource/image/b4/a5/b42e44968c3fdcdfe2acf96377f5b2a5.jpg" alt="img"></p>
<ul>
<li>安全性应该放在第一位去考虑，如果序列化存在安全漏洞，那么线上的服务就很可能被入侵</li>
<li>通用性和兼容性，会直接关系到服务调用的稳定性和可用率的<ul>
<li>序列化协议在版本升级后的兼容性是否很好</li>
<li>是否支持更多的对象类型</li>
<li>是否是跨平台、跨语言的</li>
<li>是否有很多人已经用过并且踩过了很多的坑</li>
<li>比如某个类型为集合类的入参服务调用者不能解析了，服务提供方将入参类加一个属性之后服务调用方不能正常调用，升级了 RPC 版本后发起调用时报序列化异常了等等</li>
</ul>
</li>
<li>性能和效率，序列化与反序列化过程是 RPC 调用的一个必须过程，那么序列化与反序列化的性能和效率势必将直接关系到 RPC 框架整体的性能和效率</li>
<li>空间开销，也就是序列化之后的二进制数据的体积大小，由于 RPC 是远程调用，那么网络传输的速度将直接关系到请求响应的耗时<ul>
<li>序列化后的字节数据体积越小，网络传输的数据量就越小，传输数据的速度也就越快</li>
</ul>
</li>
</ul>
<h3 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h3><ul>
<li>我们首选的还是 Hessian 与 Protobuf，因为他们在性能、时间开销、空间开销、通用性、兼容性和安全性上，都满足了我们的要求<ul>
<li>Hessian 在使用上更加方便，在对象的兼容性上更好</li>
<li>Protobuf 则更加高效，通用性上更有优势</li>
</ul>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在使用 RPC 框架的过程中，我们构造入参、返回值对象，主要记住以下几点</p>
<ul>
<li>对象要尽量简单，没有太多的依赖关系，属性不要太多，尽量高内聚</li>
<li>入参对象与返回值对象体积不要太大，更不要传太大的集合</li>
<li>尽量使用简单的、常用的、开发语言原生的对象，尤其是集合类</li>
<li>对象不要有复杂的继承关系，最好不要有父子类的情况</li>
</ul>
<h1 id="网络通信（如何传递数据）"><a href="#网络通信（如何传递数据）" class="headerlink" title="网络通信（如何传递数据）"></a>网络通信（如何传递数据）</h1><h2 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h2><ul>
<li>如何传递数据是指如何通过网络，在两个服务 Endpoint 之间相互操作、交换数据</li>
<li>这里“传递数据”通常指的是应用层协议，实际传输一般是基于标准的 TCP、UDP 等传输层协议来完成的</li>
<li>在系统内核的支持上，现在大多数系统内核都会支持阻塞 IO、非阻塞 IO 和 IO 多路复用，但像信号驱动 IO、异步 IO，只有高版本的 Linux 系统内核才会支持</li>
<li>在编程语言上，无论 C++ 还是 Java，在高性能的网络编程框架的编写上，大多数都是基于 Reactor 模式，其中最为典型的便是 Java 的 Netty 框架，而 Reactor 模式是基于 IO 多路复用的</li>
<li>在非高并发场景下，同步阻塞 IO 是最为常见的</li>
<li>在这四种常用的 IO 模型中，应用最多的、系统内核与编程语言支持最为完善的，便是阻塞 IO 和 IO 多路复用</li>
</ul>
<h2 id="常见网络IO模型"><a href="#常见网络IO模型" class="headerlink" title="常见网络IO模型"></a>常见网络IO模型</h2><ul>
<li><p>常见的网络 IO 模型分为四种：同步阻塞 IO（BIO）、同步非阻塞 IO（NIO）、IO 多路复用和异步非阻塞 IO（AIO）</p>
</li>
<li><p>在这四种 IO 模型中，只有 AIO 为异步 IO，其他都是同步 IO</p>
</li>
</ul>
<h3 id="同步阻塞-IO（BIO）"><a href="#同步阻塞-IO（BIO）" class="headerlink" title="同步阻塞 IO（BIO）"></a>同步阻塞 IO（BIO）</h3><ul>
<li>应用进程发起 IO 系统调用后，应用进程被阻塞，转到内核空间处理</li>
<li>内核开始等待数据，等待到数据之后，再将内核中的数据拷贝到用户内存中，整个 IO 处理完毕后返回进程</li>
<li>最后应用的进程解除阻塞状态，运行业务逻辑</li>
<li>系统内核处理 IO 操作分为两个阶段<ul>
<li>等待数据</li>
<li>拷贝数据。而在这两个阶段中</li>
</ul>
</li>
<li>应用进程中 IO 操作的线程会一直都处于阻塞状态，如果是基于 Java 多线程开发，那么每一个 IO 操作都要占用线程，直至 IO 操作结束</li>
</ul>
<h3 id="同步非阻塞-IO（NIO）"><a href="#同步非阻塞-IO（NIO）" class="headerlink" title="同步非阻塞 IO（NIO）"></a>同步非阻塞 IO（NIO）</h3><h4 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h4><ul>
<li>如 Java 的 NIO、Redis、Nginx 的底层实现就是此类 IO 模型的应用，经典的 Reactor 模式也是基于此类 IO 模型</li>
<li>多路就是指多个通道，也就是多个网络连接的 IO，而复用就是指多个通道复用在一个复用器上</li>
<li>多个网络连接的 IO 可以注册到一个复用器（select）上，当用户进程调用了 select，那么整个进程会被阻塞</li>
<li>内核会“监视”所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回</li>
<li>这个时候用户进程再调用 read 操作，将数据从内核中拷贝到用户进程</li>
<li>优点<ul>
<li>用户可以在一个线程内同时处理多个 socket 的 IO 请求</li>
<li>用户可以注册多个 socket，然后不断地调用 select 读取被激活的 socket，即可达到在同一个线程内同时处理多个 IO 请求的目的</li>
</ul>
</li>
</ul>
<h3 id="异步非阻塞-IO（AIO）"><a href="#异步非阻塞-IO（AIO）" class="headerlink" title="异步非阻塞 IO（AIO）"></a>异步非阻塞 IO（AIO）</h3><h2 id="如何选择网络IO模型"><a href="#如何选择网络IO模型" class="headerlink" title="如何选择网络IO模型"></a>如何选择网络IO模型</h2><ul>
<li>IO 多路复用更适合高并发的场景，可以用较少的进程（线程）处理较多的 socket 的 IO 请求，但使用难度比较高</li>
<li>高级的编程语言支持得还是比较好的<ul>
<li>比如 Java 语言有很多的开源框架对 Java 原生 API 做了封装，如 Netty 框架，使用非常简便</li>
<li>GO 语言，语言本身对 IO 多路复用的封装就已经很简洁了</li>
</ul>
</li>
<li>阻塞 IO 与 IO 多路复用相比，阻塞 IO 每处理一个 socket 的 IO 请求都会阻塞进程（线程），但使用难度较低</li>
<li>在并发量较低、业务逻辑只需要同步进行 IO 操作的场景下，阻塞 IO 已经满足了需求，并且不需要发起 select 调用，开销上还要比 IO 多路复用低</li>
<li>在 RPC 框架的实现中，在网络通信的处理上，我们会选择 IO 多路复用的方式</li>
<li>开发语言的网络通信框架的选型上，我们最优的选择是基于 Reactor 模式实现的框架，如 Java 语言，首选的框架便是 Netty 框架（Java 还有很多其他 NIO 框架，但目前 Netty 应用得最为广泛</li>
<li>在 Linux 环境下，也要开启 epoll 来提升系统性能（Windows 环境下是无法开启 epoll 的，因为系统内核不支持）</li>
</ul>
<h1 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li><p>在Java中动态代理有<strong>两种</strong>方式：</p>
<ul>
<li>JDK动态代理</li>
<li>CGLib动态代理</li>
</ul>
</li>
<li><p>JDK动态代理也有个约束：<strong>目标对象一定是要有接口的，没有接口就不能实现动态代理</strong></p>
</li>
<li><p>cglib代理也叫子类代理，<strong>从内存中构建出一个子类来扩展目标对象的功能！</strong></p>
</li>
<li><p>CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）</p>
</li>
<li><p>JDK动态代理是需要实现某个接口了，而我们类未必全部会有接口，于是CGLib代理就有了</p>
<ul>
<li>CGLib代理其生成的动态代理对象是目标类的子类</li>
<li>Spring AOP<strong>默认是使用JDK动态代理</strong>，如果代理的类<strong>没有接口则会使用CGLib代理</strong>。</li>
</ul>
</li>
<li><p>如果是<strong>单例的我们最好使用CGLib代理</strong>，如果是多例的我们最好使用JDK代理</p>
</li>
<li><p>原因：</p>
<ul>
<li>JDK在创建代理对象时的性能要高于CGLib代理，而生成代理对象的运行性能却比CGLib的低。</li>
<li>如果是单例的代理，推荐使用CGLib</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>RPC 会自动给接口生成一个代理类，当我们在项目中注入接口的时候，运行过程中实际绑定的是这个接口生成的代理类</li>
<li>这样在接口方法被调用的时候，它实际上是被生成代理类拦截到了，这样我们就可以在生成的代理类里面，加入远程调用逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要代理的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实调用对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealHello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;i&#x27;m proxy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK代理类生成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    JDKProxy(Object target) &#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] paramValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((RealHello)target).invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构建代理器</span></span><br><span class="line">        JDKProxy proxy = <span class="keyword">new</span> JDKProxy(<span class="keyword">new</span> RealHello());</span><br><span class="line">        ClassLoader classLoader = ClassLoaderUtils.getCurrentClassLoader();</span><br><span class="line">        <span class="comment">// 把生成的代理类保存到文件</span></span><br><span class="line">System.setProperty(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="comment">// 生成代理类</span></span><br><span class="line">        Hello test = (Hello) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[]&#123;Hello.class&#125;, proxy);</span><br><span class="line">        <span class="comment">// 方法调用</span></span><br><span class="line">        System.out.println(test.say());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Proxy.newProxyInstance</p>
<p><img src="https://static001.geekbang.org/resource/image/50/41/5042cf1b79e6b9233f2152e1e0aca741.jpg" alt="img"></p>
</li>
<li><p>在生成字节码的那个地方，也就是 ProxyGenerator.generateProxyClass() 方法里面是用参数 saveGeneratedFiles 来控制是否把生成的字节码保存到本地磁盘，我们需要把参数 saveGeneratedFiles 设置成 true，但这个参数的值是由 key 为“sun.misc.ProxyGenerator.saveGeneratedFiles”的 Property 来控制的，动态生成的类会保存在工程根目录下的 com/sun/proxy 目录里面。现在我们找到刚才生成的 $Proxy0.class，通过反编译工具打开 class 文件，你会看到这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.proxy.Hello;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler) &#123;</span><br><span class="line">    <span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object paramObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Boolean)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Integer)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m0, <span class="keyword">null</span>)).intValue();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m2, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      m3 = Class.forName(<span class="string">&quot;com.proxy.Hello&quot;</span>).getMethod(<span class="string">&quot;say&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> Class[] &#123; Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>) &#125;);</span><br><span class="line">      m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(noSuchMethodException.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(classNotFoundException.getMessage());</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可以看到 $Proxy0 类里面有一个跟 Hello 一样签名的 say() 方法，其中 this.h 绑定的是刚才传入的 JDKProxy 对象，所以当我们调用 Hello.say() 的时候，其实它是被转发到了 JDKProxy.invoke()</p>
</li>
<li><p>其实在 Java 领域，除了 JDK 默认的 nvocationHandler 能完成代理功能，我们还有很多其他的第三方框架也可以，比如像 Javassist、Byte Buddy 这样的框架</p>
</li>
<li><p>单纯从代理功能上来看，JDK 默认的代理功能是有一定的局限性的，它要求被代理的类只能是接口。原因是因为生成的代理类会继承 Proxy 类，但 Java 是不支持多重继承的；最大的问题是性能问题。它生成后的代理类是使用反射来完成方法调用的，而这种方式相对直接用编码调用来说，性能会降低</p>
</li>
<li><p>相对 JDK 自带的代理功能，Javassist 的定位是能够操纵底层字节码，所以使用起来并不简单，要生成动态代理类恐怕是有点复杂了。但好的方面是，通过 Javassist 生成字节码，不需要通过反射完成方法调用，所以性能肯定是更胜一筹的。在使用中，我们要注意一个问题，通过 Javassist 生成一个代理类后，此 CtClass 对象会被冻结起来，不允许再修改；否则，再次生成时会报错</p>
</li>
<li><p>Byte Buddy 则属于后起之秀，在很多优秀的项目中，像 Spring、Jackson 都用到了 Byte Buddy 来完成底层代理。相比 Javassist，Byte Buddy 提供了更容易操作的 API，编写的代码可读性更高。更重要的是，生成的代理类执行速度比 Javassist 更快</p>
</li>
</ul>
<h3 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h3><ul>
<li>既然动态代理是一种具体的技术框架，那就会涉及到选型。我们可以从这样三个角度去考虑：<ul>
<li>因为代理类是在运行中生成的，那么代理框架生成代理类的速度、生成代理类的字节码大小等等，都会影响到其性能——生成的字节码越小，运行所占资源就越小</li>
<li>还有就是我们生成的代理类，是用于接口方法请求拦截的，所以每次调用接口方法的时候，都会执行生成的代理类，这时生成的代理类的执行效率就需要很高效</li>
<li>最后一个是从我们的使用角度出发的，我们肯定希望选择一个使用起来很方便的代理类框架，比如我们可以考虑：API 设计是否好理解、社区活跃度、还有就是依赖复杂度等等</li>
</ul>
</li>
</ul>
<h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><h2 id="背景-5"><a href="#背景-5" class="headerlink" title="背景"></a>背景</h2><ul>
<li>为了高可用，在生产环境中服务提供方都是以集群的方式对外提供服务，集群里面的这些 IP 随时可能变化，我们也需要用一本“通信录”及时获取到对应的服务节点，这个获取的过程我们一般叫作“服务发现”</li>
<li>对于服务调用方和服务提供方来说，其契约就是接口，相当于“通信录”中的姓名，服务节点就是提供该契约的一个具体实例，服务 IP 集合作为“通信录”中的地址</li>
<li>服务注册：在服务提供方启动的时候，将对外暴露的接口注册到注册中心之中，注册中心将这个服务节点的 IP 和接口保存下来</li>
<li>服务订阅：在服务调用方启动的时候，去注册中心查找并订阅服务提供方的 IP，然后缓存到本地，并用于后续的远程调用</li>
<li>服务发现的本质，就是完成了接口跟服务提供者 IP 的映射</li>
</ul>
<h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><ul>
<li>在超大规模的服务集群下，注册中心所面临的挑战就是超大批量服务节点同时上下线，注册中心集群接受到大量服务变更请求，集群间各节点间需要同步大量服务节点数据，最终导致如下问题<ul>
<li>注册中心负载过高</li>
<li>各节点数据不一致</li>
<li>服务下发不及时或下发错误的服务节点列表</li>
</ul>
</li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><ul>
<li>所有的服务提供者节点都配置在同一个域名下，调用方可以通过 DNS 拿到随机的一个服务提供者的 IP，并与之建立长连接</li>
</ul>
<h4 id="缺陷-2"><a href="#缺陷-2" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>服务调用者不能及时感知到服务节点的变化</li>
</ul>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h4><ul>
<li>将域名绑定到这台负载均衡设备上，通过 DNS 拿到负载均衡的 IP</li>
<li>服务调用的时候，服务调用方就可以直接跟 VIP 建立连接，然后由 VIP 机器完成 TCP 转发</li>
</ul>
<h4 id="缺陷-3"><a href="#缺陷-3" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>搭建负载均衡设备或 TCP/IP 四层代理，需求额外成本</li>
<li>请求流量都经过负载均衡设备，多经过一次网络传输，会额外浪费些性能</li>
<li>负载均衡添加节点和摘除节点，一般都要手动添加，当大批量扩容和下线时，会有大量的人工操作和生效延迟</li>
<li>我们在服务治理的时候，需要更灵活的负载均衡策略，目前的负载均衡设备的算法还满足不了灵活的需求</li>
</ul>
<h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><h4 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h4><ul>
<li>搭建一个 ZooKeeper 集群作为注册中心集群</li>
<li>服务注册的时候只需要服务节点向 ZooKeeper 节点写入注册信息即可</li>
<li>利用 ZooKeeper 的 Watcher 机制完成服务订阅与服务下发功能</li>
</ul>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>服务平台管理端先在 ZooKeeper 中创建一个服务根路径，可以根据接口名命名（例如：/service/com.demo.xxService）</li>
<li>在这个路径再创建服务提供方目录与服务调用方目录（例如：provider、consumer），分别用来存储服务提供方的节点信息和服务调用方的节点信息</li>
<li>当服务提供方发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储该服务提供方的注册信息</li>
<li>当服务调用方发起订阅时，则在服务调用方目录中创建一个临时节点，节点中存储该服务调用方的信息，同时服务调用方 watch 该服务的服务提供方目录（/service/com.demo.xxService/provider）中所有的服务节点数据</li>
<li>当服务提供方目录下有节点数据发生变更时，ZooKeeper 就会通知给发起订阅的服务调用方</li>
</ul>
<h4 id="缺陷-4"><a href="#缺陷-4" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>ZooKeeper 本身的性能问题，当连接到 ZooKeeper 的节点数量特别多，对 ZooKeeper 读写特别频繁，且 ZooKeeper 存储的目录达到一定数量的时候，ZooKeeper 将不再稳定，CPU 持续升高，最终宕机</li>
<li>宕机之后，由于各业务的节点还在持续发送读写请求，刚一启动，ZooKeeper 就因无法承受瞬间的读写压力，马上宕机</li>
<li>ZooKeeper 的一大特点就是强一致性，ZooKeeper 集群的每个节点的数据每次发生更新操作，都会通知其它 ZooKeeper 节点同时执行更新</li>
<li>它要求保证每个节点的数据能够实时的完全一致，这也就直接导致了 ZooKeeper 集群性能上的下降</li>
<li>通常我们可以使用 ZooKeeper、etcd 或者分布式缓存（如 Hazelcast）来解决事件通知问题，但当集群达到一定规模之后，依赖的 ZooKeeper 集群、etcd 集群可能就不稳定了，无法满足我们的需求</li>
</ul>
<h3 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h3><h4 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h4><ul>
<li>RPC 框架的服务发现，在服务节点刚上线时，服务调用方是可以容忍在一段时间之后（比如几秒钟之后）发现这个新上线的节点的</li>
<li>所以可以牺牲掉 CP（强制一致性），而选择 AP（最终一致），来换取整个注册中心集群的性能和稳定性</li>
<li>注册数据可以全量缓存在每个注册中心内存中，通过消息总线来同步数据</li>
<li>当有一个注册中心节点接收到服务节点注册时，会产生一个消息推送给消息总线，再通过消息总线通知给其它注册中心节点更新数据并进行服务下发，从而达到注册中心间数据最终一致性</li>
<li>过消息总线的方式，完成注册中心集群间数据变更的通知，保证数据的最终一致性，并能及时地触发注册中心的服务下发操作</li>
</ul>
<h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><ul>
<li>当有服务上线，注册中心节点收到注册请求，服务列表数据发生变化，会生成一个消息，推送给消息总线，每个消息都有整体递增的版本</li>
<li>消息总线会主动推送消息到各个注册中心，同时注册中心也会定时拉取消息</li>
<li>获取到的消息在消息回放模块里面回放，只接受大于本地版本号的消息，小于本地版本号的消息直接丢弃，从而实现最终一致性</li>
<li>消费者订阅可以从注册中心内存拿到指定接口的全部服务实例，并缓存到消费者的内存里面</li>
<li>采用推拉模式，消费者可以及时地拿到服务实例增量变化情况，并和内存中的缓存数据进行合并</li>
<li>可以采用两级缓存，注册中心和消费者的内存缓存，通过异步推拉模式来确保最终一致性</li>
</ul>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li>服务调用方拿到的服务节点不是最新的，所以目标节点存在已经下线或不提供指定接口服务的情况<ul>
<li>在服务调用方发送请求到目标节点后，目标节点会进行合法性验证，如果指定接口服务不存在或正在下线，则会拒绝该请求</li>
<li>服务调用方收到拒绝异常后，会安全重试到其它节点</li>
</ul>
</li>
<li>例如服务节点数据的推送采用增量更新的方式，这种方式提高了注册中心“服务下发”的效率</li>
</ul>
<h1 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h1><h2 id="背景-6"><a href="#背景-6" class="headerlink" title="背景"></a>背景</h2><ul>
<li>因为有了集群，所以每次发请求前，RPC 框架会根据路由和负载均衡算法选择一个具体的 IP 地址</li>
<li>为了保证请求成功，我们就需要确保每次选择出来的 IP 对应的连接是健康的</li>
<li>调用方跟服务集群节点之间的网络状况是瞬息万变的，两者之间可能会出现闪断或者网络设备损坏等情况</li>
<li>需要让调用方实时感知到节点的状态变化，才能保证选择出来的连接一定是可用的</li>
<li>健康检测能帮助我们从连接列表里面过滤掉一些存在问题的节点，避免在发请求的时候选择出有问题的节点而影响业务</li>
</ul>
<h2 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h2><ul>
<li>应用健康状况不仅包括 TCP 连接状况，还包括应用本身是否存活，很多情况下 TCP 连接没有断开，但应用可能已经“僵死了”</li>
<li>业内常用的检测方法就是用心跳机制</li>
</ul>
<h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><ul>
<li>让每个应用实例提供一个“健康检测”的 URL，检测程序定时通过构造 HTTP 请求访问该 URL，然后根据响应结果来进行存活判断，这样就可以防止僵死状态的误判</li>
<li>正常情况下，我们大概 30S 会发一次心跳请求<ul>
<li>这个间隔一般不会太短，如果太短会给服务节点造成很大的压力</li>
<li>如果太长，又不能及时摘除有问题的节点</li>
</ul>
</li>
<li>服务方的状态一般会有三种情况<ul>
<li>健康状态：建立连接成功，并且心跳探活也一直成功</li>
<li>亚健康状态：建立连接成功，但是心跳请求连续失败</li>
<li>死亡状态：建立连接失败</li>
</ul>
</li>
<li>节点的状态并不是固定不变的，它会根据心跳或者重连的结果来动态变化</li>
<li>判断节点状态的维度<ul>
<li>心跳检测</li>
<li>业务请求的维度<ul>
<li>调用方每个接口的调用频次不一样，有的接口可能 1 秒内调用上百次，有的接口可能半个小时才会调用一次</li>
<li>服务的接口响应时间也是不一样的，有的接口可能 1ms，有的接口可能是 10s</li>
<li>可用率=某一个时间窗口内接口调用成功次数的百分比（成功次数 / 总调用次数）</li>
</ul>
</li>
</ul>
</li>
<li>减少误判<ul>
<li>把检测程序部署在多个机器里面，分布在不同的机架，甚至不同的机房</li>
<li>因为网络同时故障的概率非常低，所以只要任意一个检测程序实例访问目标机器正常，就可以说明该目标机器正常</li>
</ul>
</li>
</ul>
<h1 id="RPC-v-s-REST"><a href="#RPC-v-s-REST" class="headerlink" title="RPC v.s. REST"></a>RPC v.s. REST</h1><ul>
<li>很多人都会拿 REST 来跟 RPC 对比优劣，其实，无论是思想上、概念上，还是使用范围上，REST 与 RPC 都不完全一样，它们在本质上并不是同一个类型的东西，充其量只算是有一些相似，在应用中会有一部分功能重合的地方</li>
<li>REST 与 RPC 在思想上存在差异的核心，是抽象的目标不一样，也就是面向资源的编程思想与面向过程的编程思想之间的区别</li>
<li></li>
</ul>
<h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ul>
<li><p>你认为，RPC 使用过程中需要注意哪些问题？</p>
<ul>
<li><p>下游服务的服务能力，避免因为你的调用把别人给调挂了，要事前协商好qps等，做好限流</p>
</li>
<li><p>调用服务异常时，要考虑降级、重试等措施</p>
</li>
<li><p>核心的服务不能强依赖非核心的服务，避免核心服务因为非核心服务异常而不可用</p>
</li>
<li><p>采用rpc 开发最终要我觉得是设置合理超时时间以及重试次数</p>
<ul>
<li>因为 rpc毕竟需要走网络调用，存在网络耗时</li>
<li>超时间太短，可能导致服务提供端实际执行成功，消费端却因为超时报错结束</li>
<li>这就有可能导致数据状态不一致</li>
</ul>
</li>
<li><p>另外，整个链路的超时需要合理设置，如A-》B-〉C，A的超时时间要大于B。</p>
</li>
<li><p>重试次数也需要关注，默认情况下，如 dubbo 重试次数为2，调用失败的情况下，框架会重新调用</p>
</li>
<li><p>而有些服务不能重复调用</p>
</li>
<li><p>服务提供者应该是最熟悉自己服务的，所以服务提供者可以设置默认超时时间以及重试次数，消费者不设置，就会采用服务提供者参数设置</p>
</li>
</ul>
</li>
<li><p>RPC 与 rest 接口的区别</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/06/MySQL-%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/06/MySQL-%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">MySQL 索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-06 23:39:56" itemprop="dateCreated datePublished" datetime="2021-06-06T23:39:56+08:00">2021-06-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-12 20:56:03" itemprop="dateModified" datetime="2021-06-12T20:56:03+08:00">2021-06-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul>
<li>索引是存储引擎用于可快速找到记录的一种数据结构</li>
<li>索引是在存储引擎层，不同存储引擎的索引工作方式不同</li>
</ul>
<h1 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h1><p>MySQL支持的索引类型有三种</p>
<h2 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+ Tree 索引"></a>B+ Tree 索引</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>所有值按顺序存储，每个叶子页到根的距离相同</li>
<li>加快访问数据的速度，不需要进行全表扫描，从索引的根节点开始进行向下层查找<ul>
<li>比较节点页的值和要查找的值找合适的指针进入下层节点</li>
<li>直到找到指向被索引的数据的叶子节点</li>
</ul>
</li>
<li>所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/06/MySQL-%E7%B4%A2%E5%BC%95/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/06/MySQL-%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/06/MySQL-%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">MySQL 架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-06 21:35:04" itemprop="dateCreated datePublished" datetime="2021-06-06T21:35:04+08:00">2021-06-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-12 20:13:02" itemprop="dateModified" datetime="2021-06-12T20:13:02+08:00">2021-06-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h1><h2 id="一条-SQL-语句是如何执行的"><a href="#一条-SQL-语句是如何执行的" class="headerlink" title="一条 SQL 语句是如何执行的"></a>一条 SQL 语句是如何执行的</h2><ul>
<li>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。</li>
<li>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句<ul>
<li>查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端</li>
<li>否则执行语句</li>
</ul>
</li>
<li>分析器对语句进行词法分析和语法分析</li>
<li>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"></p>
<ul>
<li>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分</li>
<li>Server 层<ul>
<li>包括连接器、查询缓存、分析器、优化器、执行器等</li>
<li>涵盖 MySQL 的大多数核心服务功能</li>
<li>所有的内置函数（如日期、时间、数学和加密函数等）</li>
<li>所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等</li>
</ul>
</li>
<li>存储引擎层<ul>
<li>负责数据的存储和提取</li>
<li>其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎</li>
<li>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎</li>
</ul>
</li>
<li>可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表</li>
<li>从图中不难看出，不同的存储引擎共用一个 Server 层</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/06/MySQL-%E6%9E%B6%E6%9E%84/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/06/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/06/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">虚拟机类加载机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-06 21:17:07 / Modified: 21:38:05" itemprop="dateCreated datePublished" datetime="2021-06-06T21:17:07+08:00">2021-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载 Loading"></a>加载 Loading</h2><p>三层类加载器、双亲委派的类加载架构</p>
<h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/06/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">分布式事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-06 17:35:52" itemprop="dateCreated datePublished" datetime="2021-06-06T17:35:52+08:00">2021-06-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-09 22:31:09" itemprop="dateModified" datetime="2021-06-09T22:31:09+08:00">2021-06-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Distributed-System/" itemprop="url" rel="index"><span itemprop="name">Distributed System</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h1><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><ul>
<li><p>事务最终的状态只有两种，全部执行成功和全部不执行，不会停留在中间某个环节</p>
</li>
<li><p>若处理事务的任何一项操作不成功，就会导致整个事务失败</p>
</li>
<li><p>一旦操作失败，所有操作都会被取消（即回滚），使得事务仿佛没有被执行过一样</p>
</li>
</ul>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><ul>
<li><p>是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态</p>
</li>
<li><p>比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。 </p>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/05/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/05/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">JVM 垃圾回收</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-05 19:41:53" itemprop="dateCreated datePublished" datetime="2021-06-05T19:41:53+08:00">2021-06-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-06 21:37:04" itemprop="dateModified" datetime="2021-06-06T21:37:04+08:00">2021-06-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li>为什么要学习垃圾回收？<ul>
<li>需要排查内存溢出、内存泄漏问题时，垃圾回收可能成为系统达到高并发量的瓶颈</li>
</ul>
</li>
<li>哪些内存需要回收？<ul>
<li> Java堆和方法区这两个区域有很显著的不确定性，内存的分配和回收是动态的</li>
<li>Java运行区域的各个部分中，程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭，分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存回收具备确定性</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/05/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/05/%E8%B7%B3%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/05/%E8%B7%B3%E8%A1%A8/" class="post-title-link" itemprop="url">跳表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-05 19:17:55 / Modified: 19:39:57" itemprop="dateCreated datePublished" datetime="2021-06-05T19:17:55+08:00">2021-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Data-Structure/" itemprop="url" rel="index"><span itemprop="name">Data Structure</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul>
<li>我们只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫做跳表（Skip list）</li>
<li>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)</li>
<li>可以通过对链表建立一级“索引”来提高查找效率，每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做索引或索引层</li>
<li>通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历</li>
<li>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了</li>
<li>链表加多级索引的结构，就是跳表</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/05/%E8%B7%B3%E8%A1%A8/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/05/%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/05/%E5%A0%86/" class="post-title-link" itemprop="url">堆</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-05 16:48:15 / Modified: 19:39:43" itemprop="dateCreated datePublished" datetime="2021-06-05T16:48:15+08:00">2021-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Data-Structure/" itemprop="url" rel="index"><span itemprop="name">Data Structure</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul>
<li><p>满足以下两个条件</p>
<ul>
<li>堆是一个完全二叉树</li>
<li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值</li>
</ul>
</li>
<li><p>大顶堆</p>
<ul>
<li>对于每个节点的值都大于等于子树中每个节点值的堆</li>
</ul>
</li>
<li><p>小顶堆</p>
<ul>
<li>对于每个节点的值都小于等于子树中每个节点值的堆</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/05/%E5%A0%86/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/05/%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/05/%E6%A0%91/" class="post-title-link" itemprop="url">树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-05 13:46:22 / Modified: 19:39:50" itemprop="dateCreated datePublished" datetime="2021-06-05T13:46:22+08:00">2021-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Data-Structure/" itemprop="url" rel="index"><span itemprop="name">Data Structure</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点</p>
</li>
<li><p>满二叉树</p>
<p>叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点</p>
</li>
<li><p>完全二叉树</p>
<p>叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大</p>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/05/%E6%A0%91/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lsinger</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
