<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Lsinger&#39; s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Lsinger&#39; s blog">
<meta property="og:locale">
<meta property="article:author" content="Lsinger">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;default&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Lsinger' s blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lsinger' s blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Lsinger' s blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lsinger</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/07/17/LeetCode-%E6%8E%92%E5%BA%8F%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/17/LeetCode-%E6%8E%92%E5%BA%8F%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">LeetCode 排序题总结[WIP]</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-07-17 16:15:52" itemprop="dateCreated datePublished" datetime="2022-07-17T16:15:52+08:00">2022-07-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-07-18 00:25:41" itemprop="dateModified" datetime="2022-07-18T00:25:41+08:00">2022-07-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序</p>
<h2 id="排序算法分析"><a href="#排序算法分析" class="headerlink" title="排序算法分析"></a>排序算法分析</h2><h3 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h3><h4 id="1-最好情况、最坏情况、平均情况时间复杂度"><a href="#1-最好情况、最坏情况、平均情况时间复杂度" class="headerlink" title="1. 最好情况、最坏情况、平均情况时间复杂度"></a>1. 最好情况、最坏情况、平均情况时间复杂度</h4><ul>
<li>我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度</li>
<li>还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的</li>
<li>为什么要区分这三种时间复杂度呢？<ul>
<li>有些排序算法会区分，为了好对比，所以我们最好都做一下区分</li>
<li>对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现</li>
</ul>
</li>
</ul>
<h4 id="2-时间复杂度的系数、常数-、低阶"><a href="#2-时间复杂度的系数、常数-、低阶" class="headerlink" title="2. 时间复杂度的系数、常数 、低阶"></a>2. 时间复杂度的系数、常数 、低阶</h4><ul>
<li>时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶</li>
<li>但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/07/17/LeetCode-%E6%8E%92%E5%BA%8F%E9%A2%98%E6%80%BB%E7%BB%93/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/28/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/28/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Java 内存模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-28 22:03:47 / Modified: 23:44:39" itemprop="dateCreated datePublished" datetime="2021-06-28T22:03:47+08:00">2021-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>内存模型描述的是程序在 JVM 的执行过程中对数据的读写是否是按照程序的规则正确执行的</li>
<li>Java 内存模型定义了一系列规则，这些规则定义了对共享内存的写操作对于读操作的可见性</li>
<li>内存模型描述了程序执行时的可能的表现行为，只要执行的结果是满足 java 内存模型的所有规则，那么虚拟机对于具体的实现可以自由发挥</li>
<li>导致可见性的原因是缓存，导致有序性的原因是编译优化，合理的解决方案是按需禁用缓存以及编译优化</li>
<li>Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法</li>
<li>具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项 Happens-Before 规则</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/28/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/28/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/28/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" class="post-title-link" itemprop="url">服务发现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-28 21:08:21 / Modified: 21:43:19" itemprop="dateCreated datePublished" datetime="2021-06-28T21:08:21+08:00">2021-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Microservice-Architecture/" itemprop="url" rel="index"><span itemprop="name">Microservice Architecture</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件"></a>相关组件</h1><ul>
<li>老派的 ZooKeeper</li>
<li>Kubernetes 使用的 ETCD</li>
<li>阿里的微服务注册中心 Nacos</li>
<li>Spring Cloud 的 Eureka 等等</li>
</ul>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li><p>为了高可用，在生产环境中服务提供方都是以集群的方式对外提供服务，集群里面的这些 IP 随时可能变化，我们也需要用一本“通信录”及时获取到对应的服务节点，这个获取的过程我们一般叫作“服务发现”</p>
</li>
<li><p>对于服务调用方和服务提供方来说，其契约就是接口，相当于“通信录”中的姓名，服务节点就是提供该契约的一个具体实例，服务 IP 集合作为“通信录”中的地址</p>
</li>
<li><p>主要分为两部分</p>
<ul>
<li><p>服务注册</p>
<p>在服务提供方启动的时候，将对外暴露的接口注册到注册中心之中，注册中心将这个服务节点的 IP 和接口保存下来</p>
</li>
<li><p>服务订阅</p>
<p>在服务调用方启动的时候，去注册中心查找并订阅服务提供方的 IP，然后缓存到本地，并用于后续的远程调用</p>
</li>
</ul>
</li>
<li><p>服务发现的本质，就是完成了接口跟服务提供者 IP 的映射</p>
</li>
<li><p>通常我们可以使用 ZooKeeper、etcd 或者分布式缓存（如 Hazelcast）来解决事件通知问题，但当集群达到一定规模之后，依赖的 ZooKeeper 集群、etcd 集群可能就不稳定了，无法满足我们的需求</p>
</li>
</ul>
<h1 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h1><p>在超大规模的服务集群下，注册中心所面临的挑战就是超大批量服务节点同时上下线，注册中心集群接受到大量服务变更请求，集群间各节点间需要同步大量服务节点数据，最终导致如下问题</p>
<ul>
<li>注册中心负载过高</li>
<li>各节点数据不一致</li>
<li>服务下发不及时或下发错误的服务节点列表</li>
</ul>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>所有的服务提供者节点都配置在同一个域名下，调用方可以通过 DNS 拿到随机的一个服务提供者的 IP，并与之建立长连接</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>服务调用者不能及时感知到服务节点的变化</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>将域名绑定到这台负载均衡设备上，通过 DNS 拿到负载均衡的 IP</li>
<li>服务调用的时候，服务调用方就可以直接跟 VIP 建立连接，然后由 VIP 机器完成 TCP 转发</li>
</ul>
<h3 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h3><ul>
<li>搭建负载均衡设备或 TCP/IP 四层代理，需求额外成本</li>
<li>请求流量都经过负载均衡设备，多经过一次网络传输，会额外浪费些性能</li>
<li>负载均衡添加节点和摘除节点，一般都要手动添加，当大批量扩容和下线时，会有大量的人工操作和生效延迟</li>
<li>我们在服务治理的时候，需要更灵活的负载均衡策略，目前的负载均衡设备的算法还满足不了灵活的需求</li>
</ul>
<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>搭建一个 ZooKeeper 集群作为注册中心集群</li>
<li>服务注册的时候只需要服务节点向 ZooKeeper 节点写入注册信息即可</li>
<li>利用 ZooKeeper 的 Watcher 机制完成服务订阅与服务下发功能</li>
</ul>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><ul>
<li>服务平台管理端先在 ZooKeeper 中创建一个服务根路径，可以根据接口名命名（例如：/service/com.demo.xxService）</li>
<li>在这个路径再创建服务提供方目录与服务调用方目录（例如：provider、consumer），分别用来存储服务提供方的节点信息和服务调用方的节点信息</li>
<li>当服务提供方发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储该服务提供方的注册信息</li>
<li>当服务调用方发起订阅时，则在服务调用方目录中创建一个临时节点，节点中存储该服务调用方的信息</li>
<li>同时服务调用方 watch 该服务的服务提供方目录（/service/com.demo.xxService/provider）中所有的服务节点数据</li>
<li>当服务提供方目录下有节点数据发生变更时，ZooKeeper 就会通知给发起订阅的服务调用方</li>
</ul>
<h3 id="缺陷-2"><a href="#缺陷-2" class="headerlink" title="缺陷"></a>缺陷</h3><h4 id="强一致性，性能有限"><a href="#强一致性，性能有限" class="headerlink" title="强一致性，性能有限"></a>强一致性，性能有限</h4><ul>
<li><p>ZooKeeper 的一大特点就是强一致性，ZooKeeper 集群的每个节点的数据每次发生更新操作，都会通知其它 ZooKeeper 节点同时执行更新</p>
</li>
<li><p>它要求保证每个节点的数据能够实时的完全一致，这也就直接导致了 ZooKeeper 集群性能上的下降</p>
</li>
<li><p>CPU 持续升高，最终宕机</p>
<ul>
<li>当连接到 ZooKeeper 的节点数量特别多，对 ZooKeeper 读写特别频繁，且 ZooKeeper 存储的目录达到一定数量的时候，ZooKeeper 将不再稳定，CPU 持续升高，最终宕机</li>
<li>宕机之后，由于各业务的节点还在持续发送读写请求，刚一启动，ZooKeeper 就因无法承受瞬间的读写压力，马上宕机</li>
</ul>
</li>
</ul>
<h4 id="主节点宕机后，选举时间长，服务长时间不可用"><a href="#主节点宕机后，选举时间长，服务长时间不可用" class="headerlink" title="主节点宕机后，选举时间长，服务长时间不可用"></a>主节点宕机后，选举时间长，服务长时间不可用</h4><ul>
<li>Zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时剩余节点会重新进行leader选举</li>
<li>选举leader的时间大概 30~120s，且选举期间整个 Zookeeper 集群是不可用的</li>
<li>在云部署的环境下，因网络环境使Zookeeper集群失去master节点是较大概率发生的事情，虽然服务能够最终恢复，但是漫长的选举时间导致长期的服务注册不可用是不能容忍的</li>
</ul>
<h2 id="Eureke"><a href="#Eureke" class="headerlink" title="Eureke"></a>Eureke</h2><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>Eureka 在设计的时候遵循的是 <strong>AP原则</strong></li>
<li>Eureka 各个节点（服务）是平等的， 没有主从之分，几个节点  down 掉不会影响正常工作，剩余的节点（服务） 依然可以提供注册与查询服务<ul>
<li>Eureka的客户端在向某个 Eureka 注册或发现连接失败，则会自动切换到其他节点</li>
<li>只要有一台Eureka还在，就能注册可用（保 证可用性）， 只不过查询到的信息不保证是最新的（不保证强一致）</li>
</ul>
</li>
<li>节点都是临时节点，在内存里</li>
</ul>
<h3 id="多级缓存架构"><a href="#多级缓存架构" class="headerlink" title="多级缓存架构"></a>多级缓存架构</h3><h3 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h3><p>Eureka 有自我保护机制，避免服务节点被过度摘除，导致服务集群不足以承担流量的问题</p>
<ul>
<li>如果在 15 分钟内超过 85% 节点都没有正常心跳，那么 eureka 就认为客户端与注册中心出现了网络故障</li>
<li>Eureka 不再从注册列表中移除因为长时间没有收到心跳而过期的服务</li>
<li>Eureka 仍然能够接收新服务的注册和查询请求，但是不会被同步到其它节点上（即保证当前节点可用）</li>
<li>当网络稳定后，当前实例新的注册信息会被同步到其它节点中</li>
</ul>
<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>RPC 框架的服务发现，在服务节点刚上线时，服务调用方是可以容忍在一段时间之后（比如几秒钟之后）发现这个新上线的节点的</li>
<li>所以可以牺牲掉 CP（强制一致性），而选择 AP（最终一致），来换取整个注册中心集群的性能和稳定性</li>
<li>注册数据可以全量缓存在每个注册中心内存中，通过消息总线来同步数据</li>
<li>当有一个注册中心节点接收到服务节点注册时，会产生一个消息推送给消息总线，再通过消息总线通知给其它注册中心节点更新数据并进行服务下发，从而达到注册中心间数据最终一致性</li>
<li>通过消息总线的方式，完成注册中心集群间数据变更的通知，保证数据的最终一致性，并能及时地触发注册中心的服务下发操作</li>
</ul>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>当有服务上线，注册中心节点收到注册请求，服务列表数据发生变化，会生成一个消息，推送给消息总线，每个消息都有整体递增的版本</li>
<li>消息总线会主动推送消息到各个注册中心，同时注册中心也会定时拉取消息</li>
<li>获取到的消息在消息回放模块里面回放，只接受大于本地版本号的消息，小于本地版本号的消息直接丢弃，从而实现最终一致性</li>
<li>消费者订阅可以从注册中心内存拿到指定接口的全部服务实例，并缓存到消费者的内存里面</li>
<li>采用推拉模式，消费者可以及时地拿到服务实例增量变化情况，并和内存中的缓存数据进行合并</li>
<li>可以采用两级缓存，注册中心和消费者的内存缓存，通过异步推拉模式来确保最终一致性</li>
</ul>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li>服务调用方拿到的服务节点不是最新的，所以目标节点存在已经下线或不提供指定接口服务的情况<ul>
<li>在服务调用方发送请求到目标节点后，目标节点会进行合法性验证，如果指定接口服务不存在或正在下线，则会拒绝该请求</li>
<li>服务调用方收到拒绝异常后，会安全重试到其它节点</li>
</ul>
</li>
<li>例如服务节点数据的推送采用增量更新的方式，这种方式提高了注册中心“服务下发”的效率</li>
</ul>
<h1 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><ul>
<li>因为有了集群，所以每次发请求前，RPC 框架会根据路由和负载均衡算法选择一个具体的 IP 地址</li>
<li>为了保证请求成功，我们就需要确保每次选择出来的 IP 对应的连接是健康的</li>
<li>调用方跟服务集群节点之间的网络状况是瞬息万变的，两者之间可能会出现闪断或者网络设备损坏等情况</li>
<li>需要让调用方实时感知到节点的状态变化，才能保证选择出来的连接一定是可用的</li>
<li>健康检测能帮助我们从连接列表里面过滤掉一些存在问题的节点，避免在发请求的时候选择出有问题的节点而影响业务</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>nginx</li>
<li>LVS</li>
<li>Spring Cloud Ribbon</li>
</ul>
<h2 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a>基本思路</h2><ul>
<li>应用健康状况不仅包括 TCP 连接状况，还包括应用本身是否存活，很多情况下 TCP 连接没有断开，但应用可能已经“僵死了”</li>
<li>业内常用的检测方法就是用心跳机制</li>
</ul>
<h3 id="主动探测"><a href="#主动探测" class="headerlink" title="主动探测"></a>主动探测</h3><ul>
<li><p>你的 RPC 服务要打开一个端口，然后由注册中心每隔一段时间（比如 30 秒）探测这些端口是否可用，如果可用就认为服务仍然是正常的，否则就可以认为服务不可用，那么注册中心就可以把服务从列表里面删除了</p>
</li>
<li><p>让每个应用实例提供一个“健康检测”的 URL，检测程序定时通过构造 HTTP 请求访问该 URL，然后根据响应结果来进行存活判断，这样就可以防止僵死状态的误判</p>
</li>
<li><p>正常情况下，我们大概 30S 会发一次心跳请求</p>
<ul>
<li>这个间隔一般不会太短，如果太短会给服务节点造成很大的压力</li>
<li>如果太长，又不能及时摘除有问题的节点</li>
</ul>
</li>
<li><p>服务方的状态一般会有三种情况</p>
<ul>
<li>健康状态：建立连接成功，并且心跳探活也一直成功</li>
<li>亚健康状态：建立连接成功，但是心跳请求连续失败</li>
<li>死亡状态：建立连接失败</li>
</ul>
</li>
<li><p>节点的状态并不是固定不变的，它会根据心跳或者重连的结果来动态变化</p>
</li>
<li><p>判断节点状态的维度</p>
<ul>
<li>心跳检测</li>
<li>业务请求的维度<ul>
<li>可用率=某一个时间窗口内接口调用成功次数的百分比（成功次数 / 总调用次数）<ul>
<li>调用方每个接口的调用频次不一样，有的接口可能 1 秒内调用上百次，有的接口可能半个小时才会调用一次</li>
<li>服务的接口响应时间也是不一样的，有的接口可能 1ms，有的接口可能是 10s</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>减少误判</p>
<ul>
<li>把检测程序部署在多个机器里面，分布在不同的机架，甚至不同的机房</li>
<li>因为网络同时故障的概率非常低，所以只要任意一个检测程序实例访问目标机器正常，就可以说明该目标机器正常</li>
</ul>
</li>
</ul>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul>
<li>所有的 RPC 服务端都需要开放一个统一的端口给注册中心探测，你需要开放的端口很可能已经被占用，这样会造成 RPC 服务启动失败</li>
<li>如果 RPC 服务端部署的实例比较多，那么每次探测的成本也会比较高，探测的时间也比较长，这样当一个服务不可用时，可能会有一段时间的延迟，才会被注册中心探测到</li>
</ul>
<h3 id="心跳模式"><a href="#心跳模式" class="headerlink" title="心跳模式"></a>心跳模式</h3><ul>
<li>注册中心为每一个连接上来的 RPC 服务节点记录最近续约的时间，RPC 服务节点在启动注册到注册中心后，就按照一定的时间间隔（比如 30 秒），向注册中心发送心跳包</li>
<li>注册中心在接收到心跳包之后，会更新这个节点的最近续约时间</li>
<li>然后，注册中心会启动一个定时器定期检测当前时间和节点最近续约时间的差值，如果达到一个阈值（比如说 90 秒），那么认为这个服务节点不可用</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>注册中心网络故障，导致未能及时更新续约时间，所以将所有的节点摘除，从而导致了故障<ul>
<li>给注册中心增加了保护的策略：如果摘除的节点占到了服务集群节点数的 40%，就停止摘除服务节点，并且给服务的开发同学和运维同学报警处理</li>
<li>如果你使用的是 ZooKeeper 或者 ETCD 这种无保护策略的分布式一致性组件，可以考虑在客户端实现保护策略的逻辑，比如说当摘除的节点超过一定比例时，你在 RPC 客户端就不再处理变更通知，你可以依据自己的实际情况来实现</li>
</ul>
</li>
</ul>
<h1 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><ul>
<li><p>当我们的一个服务节点无法支撑现有的访问量时，我们会部署多个节点，组成一个集群，然后通过负载均衡，将请求分发给这个集群下的每个服务节点，从而达到多个服务节点共同分担请求压力的目的</p>
</li>
<li><p>同时，负载均衡服务器作为流量入口，可以对请求方屏蔽服务节点的部署细节，实现对于业务方无感知的扩容</p>
</li>
<li><p>负载均衡主要分为软负载和硬负载</p>
<ul>
<li>软负载就是在一台或多台服务器上安装负载均衡的软件，如 LVS、Nginx 等</li>
<li>硬负载就是通过硬件设备来实现的负载均衡，如 F5 服务器等</li>
</ul>
</li>
<li><p>负载均衡的算法主要有随机法、轮询法、最小连接法等</p>
</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>负载均衡服务大体上可以分为两大类：代理类和客户端类</li>
<li>一般来说，在系统接入层，使用的是代理类负载均衡，而微服务之间的内部调用，使用的是客户端负载均衡</li>
</ul>
<h3 id="代理类的负载均衡服务"><a href="#代理类的负载均衡服务" class="headerlink" title="代理类的负载均衡服务"></a>代理类的负载均衡服务</h3><ul>
<li>代理类的负载均衡服务以单独的服务方式部署，所有的请求都要先经过负载均衡服务，在负载均衡服务中选出一个合适的服务节点后，再由负载均衡服务调用这个服务节点来实现流量的分发</li>
<li>由于这类服务需要承担全量的请求，所以对于性能的要求极高</li>
<li>代理类的负载均衡服务有很多开源实现，比较著名的有 LVS、Nginx 等等</li>
<li>LVS 在 OSI 网络模型中的第四层，传输层工作，所以 LVS 又可以称为四层负载</li>
</ul>
<h4 id="HTTP-应用服务的负载均衡"><a href="#HTTP-应用服务的负载均衡" class="headerlink" title="HTTP 应用服务的负载均衡"></a>HTTP 应用服务的负载均衡</h4><ul>
<li>一般会同时部署 LVS 和 Nginx 来做 HTTP 应用服务的负载均衡</li>
<li>在入口处部署 LVS 将流量分发到多个 Nginx 服务器上，再由 Nginx 服务器分发到应用服务器上</li>
<li>LVS 是在网络栈的四层做请求包的转发，请求包转发之后，由客户端和后端服务直接建立连接，后续的响应包不会再经过 LVS 服务器，所以相比 Nginx 性能会更高，也能够承担更高的并发</li>
<li>可 LVS 缺陷是工作在四层，而请求的 URL 是七层的概念，不能针对 URL 做更细致的请求分发，而且 LVS 也没有提供探测后端服务是否存活的机制</li>
<li>Nginx 虽然比 LVS 的性能差很多，但也可以承担每秒几万次的请求，并且它在配置上更加灵活，还可以感知后端服务是否出现问题</li>
<li>因此，LVS 适合在入口处承担大流量的请求分发，而 Nginx 要部署在业务服务器之前做更细维度的请求分发</li>
<li>我给你的建议是，如果你的 QPS 在十万以内，那么可以考虑不引入 LVS 而直接使用 Nginx 作为唯一的负载均衡服务器，这样少维护一个组件，也会减少系统的维护成本</li>
</ul>
<h3 id="客户端负载均衡服务"><a href="#客户端负载均衡服务" class="headerlink" title="客户端负载均衡服务"></a>客户端负载均衡服务</h3><ul>
<li>客户端负载均衡服务，也就是把负载均衡的服务内嵌在 RPC 客户端中</li>
<li>它一般和客户端应用部署在一个进程中，提供多种选择节点的策略，最终为客户端应用提供一个最佳的、可用的服务端节点</li>
<li>这类服务一般会结合注册中心来使用，注册中心提供服务节点的完整列表，客户端拿到列表之后使用负载均衡服务的策略选取一个合适的节点，然后将请求发到这个节点上</li>
<li>RPC 的负载均衡完全由 RPC 框架自身实现，RPC 的服务调用者会与“注册中心”下发的所有服务节点建立长连接，在每次发起 RPC 调用时，服务调用者都会通过配置的负载均衡插件，自主选择一个服务节点，发起 RPC 调用请求</li>
<li>由于负载均衡机制完全是由 RPC 框架自身实现的，所以它不再需要依赖任何负载均衡设备，自然也不会发生负载均衡设备的单点问题，服务调用方的负载均衡策略也完全可配，同时我们可以通过控制权重的方式，对负载均衡进行治理</li>
<li>RPC 负载均衡策略一般包括随机权重、Hash、轮询</li>
<li>其中的随机权重策略应该是我们最常用的一种了，通过随机算法，我们基本可以保证每个节点接收到的请求流量是均匀的；同时我们还可以通过控制节点权重的方式，来进行流量控制</li>
</ul>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><h3 id="静态策略"><a href="#静态策略" class="headerlink" title="静态策略"></a>静态策略</h3><ul>
<li><p>也就是说负载均衡服务器在选择服务节点时，不会参考后端服务的实际运行的状态</p>
</li>
<li><p>常见的静态策略有几种，轮询策略、带有权重的轮询策略</p>
<ul>
<li>Nginx 提供了 ip_hash 和 url_hash 算法</li>
<li>LVS 提供了按照请求的源地址和目的地址做 Hash 的策略</li>
<li>Dubbo 也提供了随机选取策略以及一致性 Hash 的策略</li>
</ul>
</li>
<li><p>其中使用最广泛的是轮询的策略（RoundRobin，RR），这种策略会记录上次请求后端服务的地址或者序号，然后在请求时按照服务列表的顺序，请求下一个后端服务节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger lastCounter = getLastCounter();<span class="comment">//获取上次请求的服务节点的序号 </span></span><br><span class="line">List&lt;String&gt; serverList = getServerList(); <span class="comment">// 获取服务列表</span></span><br><span class="line"><span class="keyword">int</span> currentIndex = lastCounter.addAndGet(); <span class="comment">//增加序列号</span></span><br><span class="line"><span class="keyword">if</span>(currentIndex &gt;= serverList.size()) &#123;</span><br><span class="line">  currentIndex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">setLastCounter(currentIndex);</span><br><span class="line"><span class="keyword">return</span> serverList.get(currentIndex);</span><br></pre></td></tr></table></figure></li>
<li><p>轮询的策略可以做到将请求尽量平均地分配到所有服务节点上，但是，它没有考虑服务节点的具体配置情况</p>
</li>
<li><p>轮询和带有权重的轮询策略能够将请求尽量平均地分配到后端服务节点上，也就能够做到对于负载的均衡分配</p>
</li>
<li><p>在没有更好的动态策略之前，应该优先使用这两种策略，比如 Nginx 就会优先使用轮询的策略</p>
</li>
</ul>
<h3 id="动态策略"><a href="#动态策略" class="headerlink" title="动态策略"></a>动态策略</h3><ul>
<li><p>也就是说负载均衡服务器会依据后端服务的一些负载特性，来决定要选择哪一个服务节点</p>
</li>
<li><p>从调用方的角度出发，选择负载最小、资源最空闲的服务来调用，以期望能得到更高的服务调用性能，也就能最大化地使用服务器的空闲资源，请求也会响应得更迅速</p>
</li>
<li><p>在负载均衡服务器上会收集对后端服务的调用信息</p>
<ul>
<li>比如从负载均衡端到后端服务的活跃连接数<ul>
<li>Dubbo 提供的 LeastAcive 策略，就是优先选择活跃连接数最少的服务</li>
</ul>
</li>
<li>或者是调用的响应时间<ul>
<li>Spring Cloud 全家桶中的 Ribbon 提供了 WeightedResponseTimeRule 是使用响应时间给每个服务节点计算一个权重，然后依据这个权重，来给调用方分配服务节点</li>
</ul>
</li>
<li>然后从中选择连接数最少的服务，或者响应时间最短的后端服务</li>
</ul>
</li>
<li><p>在实际开发中，优先考虑使用动态的策略</p>
</li>
</ul>
<h1 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h1><h2 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h2><ul>
<li>API 网关（API Gateway）不是一个开源组件，而是一种架构模式，它是将一些服务共有的功能整合在一起，独立部署为单独的一层，用来解决一些服务治理的问题</li>
<li>可以把它看作系统的边界，它可以对出入系统的流量做统一的管控</li>
</ul>
<h2 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h2><ul>
<li>Kong是在 Nginx 中运行的 Lua 程序<ul>
<li>得益于 Nginx 的性能优势，Kong 相比于其它的开源 API 网关来说，性能方面是最好的</li>
<li>由于大中型公司对于 Nginx 运维能力都比较强，所以选择 Kong 作为 API 网关</li>
<li>无论是在性能还是在运维的把控力上，都是比较好的选择</li>
</ul>
</li>
<li>Zuul是 Spring Cloud 全家桶中的成员<ul>
<li>如果你已经使用了 Spring Cloud 中的其他组件，那么也可以考虑使用 Zuul 和它们无缝集成</li>
<li>Zuul1 因为采用同步阻塞模型，所以在性能上并不是很高效</li>
<li>而 Zuul2 推出时间不长，难免会有坑</li>
<li>但是 Zuul 的代码简单易懂，可以很好地把控</li>
<li>系统的量级达不到 Netfix 这样的级别时，所以对于 Java 技术栈的团队，使用 Zuul 也是一个不错的选择</li>
<li>Spring cloud gateway 性能比zuul好一些，并且是异步的</li>
</ul>
</li>
<li>Tyk是一种 Go 语言实现的轻量级 API 网关<ul>
<li>有着丰富的插件资源，对于 Go 语言栈的团队来说，也是一种不错的选择</li>
</ul>
</li>
</ul>
<h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li>满足某个断言（时间、cookie ），才把请求路由到某个地址上去<ul>
<li>注册到注册中心，然后拦截器拦截请求，根据配置规则解析URL转发请求，到正确的服务器上</li>
</ul>
</li>
<li>过滤器</li>
<li>熔断、降级、限流</li>
<li>请求加上参数</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty</li>
</ul>
<h3 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h3><ul>
<li>servlet是一个简单的网络IO模型，当请求进入servlet container时，servlet container就会为其绑定一个线程，在并发不高的场景下这种模型是适用的</li>
<li>一旦并发上升，线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大）严重影响请求的处理时间</li>
<li>在一些简单的业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型没有优势</li>
<li>Zuul 2.0开始，使用了Netty，并且已经有了大规模Zuul 2.0集群部署的成熟案例，但是，Springcloud官方已经没有集成改版本的计划了</li>
<li>Webflux模式替换了旧的Servlet线程模型</li>
<li>用少量的线程处理request和response io操作，这些线程称为Loop线程，而业务交给响应式编程框架处理，响应式编程是非常灵活的，用户可以将业务中阻塞的操作提交到响应式框架的work线程中执行，而不阻塞的操作依然可以在Loop线程中进行处理，大大提高了Loop线程的利用率</li>
</ul>
<h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><p>API 网关可以分为两类：一类叫做入口网关，一类叫做出口网关</p>
<h3 id="入口网关"><a href="#入口网关" class="headerlink" title="入口网关"></a>入口网关</h3><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ul>
<li>它提供客户端一个统一的接入地址，API 网关可以将用户的请求动态路由到不同的业务服务上，并且做一些必要的协议转换工作<ul>
<li>在你的系统中，你部署的微服务对外暴露的协议可能不同：有些提供的是 HTTP 服务；有些已经完成 RPC 改造，对外暴露 RPC 服务；有些遗留系统可能还暴露的是 Web Service 服务</li>
<li>API 网关可以对客户端屏蔽这些服务的部署地址以及协议的细节，给客户端的调用带来很大的便捷。另一方面，在 API 网关中</li>
</ul>
</li>
<li>API 网关还可以做一些与黑白名单相关的事情，比如针对设备 ID、用户 IP、用户 ID 等维度的黑白名单</li>
</ul>
<h4 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h4><ul>
<li>可以植入一些服务治理的策略，比如服务的熔断、降级、流量控制和分流等等</li>
</ul>
<h4 id="认证授权"><a href="#认证授权" class="headerlink" title="认证授权"></a>认证授权</h4><ul>
<li><p>客户端的认证和授权的实现，也可以放在 API 网关</p>
</li>
<li><p>不同类型的客户端使用的认证方式是不同的</p>
<ul>
<li>手机 APP 使用 Oauth 协议认证</li>
<li>HTML5 端和 Web 端使用 Cookie 认证</li>
<li>内部服务使用自研的 Token 认证方式</li>
</ul>
</li>
<li><p>这些认证方式在 API 网关上可以得到统一处理，应用服务不需要了解认证的细节</p>
</li>
</ul>
<h4 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h4><ul>
<li>在 API 网关中也可以做一些日志记录的事情，比如记录 HTTP 请求的访问日志</li>
</ul>
<h3 id="出口网关"><a href="#出口网关" class="headerlink" title="出口网关"></a>出口网关</h3><ul>
<li>在出口网关中，对调用外部的 API 做统一的认证、授权、审计以及访问控制</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>首先要考虑的是它的性能</li>
<li>API 入口网关承担从客户端的所有流量<ul>
<li>假如业务服务处理时间是 10ms，而 API 网关的耗时在 1ms，那么相当于每个接口的响应时间都要增加 10%，这对于性能的影响无疑是巨大的</li>
</ul>
</li>
<li>提升 API 网关性能的关键还是在 I/O 模型<ul>
<li>Netfix 开源的 API 网关 Zuul，在 1.0 版本的时候使用的是同步阻塞 I/O 模型</li>
<li>在 Zuul2.0 中，Netfix 团队将 servlet 改造成了一个 netty server（netty 服务），采用 I/O 多路复用的模型处理接入的 I/O 请求</li>
</ul>
</li>
</ul>
<h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><ul>
<li>API 网关的设计要注意扩展性，可以随时在网关的执行链路上增加一些逻辑，也可以随时下掉一些逻辑（也就是所谓的热插拔）<ul>
<li>API 网关中执行的动作有些是可以预先定义好的，比如黑白名单的设置，接口动态路由；有些则是需要业务方依据自身业务来定义</li>
</ul>
</li>
<li>可以把每一个操作定义为一个 filter（过滤器），然后使用“责任链模式”将这些 filter 串起来。责任链可以动态地组织这些 filter，解耦 filter 之间的关系，无论是增加还是减少 filter，都不会对其他的 filter 有任何的影响，Zuul 就是采用责任链模式<ul>
<li>Zuul1 中将 filter 定义为三类：pre routing filter（路由前过滤器）、routing filter（路由过滤器）和 after routing filter（路由后过滤器）</li>
<li>每一个 filter 定义了执行的顺序，在 filter 注册时，会按照顺序插入到 filter chain（过滤器链）中。这样 Zuul 在接收到请求时，就会按照顺序依次执行插入到 filter chain 中的 filter 了</li>
</ul>
</li>
</ul>
<h3 id="并发能力"><a href="#并发能力" class="headerlink" title="并发能力"></a>并发能力</h3><ul>
<li>为了提升网关对于请求的并行处理能力，我们一般会使用线程池来并行的执行请求</li>
<li>需要针对不同的服务做线程隔离或者保护<ul>
<li>背景<ul>
<li>如果商品服务出现问题造成响应缓慢，那么调用商品服务的线程就会被阻塞无法释放，久而久之，线程池中的线程就会被商品服务所占据，那么其他服务也会受到级联的影响</li>
</ul>
</li>
<li>如果后端的服务拆分得不多，可以针对不同的服务，采用不同的线程池</li>
<li>在线程池内部可以针对不同的服务甚至不同的接口做线程的保护<ul>
<li>比如说，线程池的最大线程数是 1000，那么可以给每个服务设置一个最多可以使用的配额。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="如何引入"><a href="#如何引入" class="headerlink" title="如何引入"></a>如何引入</h2><ul>
<li>再独立出一组网关专门做服务聚合、超时控制方面的事情，我们一般把前一种网关叫做流量网关，后一种可以叫做业务网关</li>
<li>抽取独立的服务层，专门做接口聚合的操作。这样服务层就大概分为原子服务层和聚合服务层。<ul>
<li>可以在系统和第三方支付服务，以及登陆服务之间部署出口网关服务。原先，你会在拆分出来的支付服务中完成对于第三方支付接口所需要数据的加密、签名等操作，再调用第三方支付接口完成支付请求。现在，你把对数据的加密、签名的操作放在出口网关中，这样一来，支付服务只需要调用出口网关的统一支付接口就可以了</li>
</ul>
</li>
</ul>
<h1 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h1><ul>
<li>一般可以内置于API网关或者RPC框架中</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/b7/68/b78964a2db3adc8080364e9cfc79ca68.jpg" alt="img"></p>
<h2 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h2><ul>
<li>服务路由包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用哪些服务提供者</li>
<li>路由本质是节点分组、隔离流量，打标签、分流等特性都天然适合在路由策略里做</li>
<li>灰度发布功能作为 RPC 路由功能的一个典型应用场景，可以通过路由功能完成像定点调用、黑白名单等一些高级服务治理功能</li>
<li>在 RPC 里面，不管是哪种路由策略，其核心思想都是让请求按照我们设定的规则发送到目标节点上，从而实现流量隔离的效果</li>
</ul>
<h2 id="组件-2"><a href="#组件-2" class="headerlink" title="组件"></a>组件</h2><ul>
<li>Dubbo</li>
<li>Zuul</li>
</ul>
<h2 id="常见策略"><a href="#常见策略" class="headerlink" title="常见策略"></a>常见策略</h2><h3 id="IP-路由策略"><a href="#IP-路由策略" class="headerlink" title="IP 路由策略"></a>IP 路由策略</h3><ul>
<li>用于限制可以调用服务提供方的 IP</li>
<li>在 RPC 发起真实请求的时候，有一个步骤就是从服务提供方节点集合里面选择一个合适的节点（就是我们常说的负载均衡），那我们是不是可以在选择节点前加上“筛选逻辑”，把符合我们要求的节点筛选出来</li>
<li>比如我们要求新上线的节点只允许某个 IP 可以调用，那我们的注册中心会把这条规则下发到服务调用方</li>
<li>在调用方收到规则后，在选择具体要发请求的节点前，会先通过筛选规则过滤节点集合</li>
</ul>
<h3 id="参数路由"><a href="#参数路由" class="headerlink" title="参数路由"></a>参数路由</h3><ul>
<li>更细粒度的路由方式</li>
<li>保证某个主题对象的所有请求都使用同一种应用来承接<ul>
<li>假设我们改造的是商品应用，那主题对象肯定是商品 ID，在切流量的过程中，我们必须保证某个商品的所有操作都是用新应用（或者老应用）来完成所有请求的响应</li>
</ul>
</li>
<li>我们可以给所有的服务提供方节点都打上标签，用来区分新老应用节点</li>
<li>在服务调用方发生请求的时候，我们可以很容易地拿到请求参数，也就是我们例子中的商品 ID</li>
<li>根据注册中心下发的规则来判断当前商品 ID 的请求是过滤掉新应用还是老应用的节点</li>
<li>因为规则对所有的调用方都是一样的，从而保证对应同一个商品 ID 的请求要么是新应用的节点，要么是老应用的节点</li>
<li>相比 IP 路由，参数路由支持的灰度粒度更小，他为服务提供方应用提供了另外一个服务治理的手段。</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li>Dubbo 目前提供了三种服务路由实现，分别为条件路由 ConditionRouter、脚本路由 ScriptRouter 和标签路由 TagRouter</li>
</ul>
<h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>虽然在调用方(上游)做路由策略选择可用的提供方(下游)集群，是天然符合RPC调用机制的，但是在团队协作上却是反人性的（难以推动）</li>
<li>后期扩展时业务不需要更新部署(例如Dubbo的条件路由、脚本路由等都是可以从第三方写注册中心更新路由策略而无需业务变更)</li>
</ul>
<h1 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h1><h1 id="优雅启停"><a href="#优雅启停" class="headerlink" title="优雅启停"></a>优雅启停</h1><h2 id="背景-5"><a href="#背景-5" class="headerlink" title="背景"></a>背景</h2><ul>
<li>在服务重启的时候，对于调用方来说，这时候可能会存在以下几种情况<ul>
<li>调用方发请求前，目标服务已经下线。对于调用方来说，跟目标节点的连接会断开，这时候调用方可以立马感知到，并且在其健康列表里面会把这个节点挪掉，自然也就不会被负载均衡选中</li>
<li>调用方发请求的时候，目标服务正在关闭，但调用方并不知道它正在关闭，而且两者之间的连接也没断开，所以这个节点还会存在健康列表里面，因此该节点就有一定概率会被负载均衡选中</li>
</ul>
</li>
<li>在 Java 里面，在运行过程中，JVM 虚拟机会把高频的代码编译成机器码，被加载过的类也会被缓存到 JVM 缓存中，再次使用的时候不会触发临时加载，这样就使得“热点”代码的执行不用每次都通过解释，从而提升执行速度</li>
<li>在 Java 里面，在运行过程中，JVM 虚拟机会把高频的代码编译成机器码，被加载过的类也会被缓存到 JVM 缓存中，再次使用的时候不会触发临时加载，这样就使得“热点”代码的执行不用每次都通过解释，从而提升执行速度，但是这些“临时数据”，都在我们应用重启后就消失了</li>
<li>刚重启的服务提供方因为没有预跑就承担了大流量</li>
</ul>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p><img src="https://static001.geekbang.org/resource/image/a1/50/a15be58b32195422bd5a18dba0e68050.jpg" alt="img"></p>
<ul>
<li>整个关闭过程中依赖了两次 RPC 调用<ul>
<li>一次是服务提供方通知注册中心下线操作</li>
<li>一次是注册中心通知服务调用方下线节点操作</li>
</ul>
</li>
<li>注册中心通知服务调用方都是异步的，我们在“服务发现”一讲中讲过在大规模集群里面，服务发现只保证最终一致性，并不保证实时性，所以注册中心在收到服务提供方下线的时候，并不能成功保证把这次要下线的节点推送到所有的调用方</li>
<li>通过服务发现并不能做到应用无损关闭</li>
</ul>
<h3 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h3><p><img src="https://static001.geekbang.org/resource/image/77/cc/7752081ec658f1d56ac4219f1c07fbcc.jpg" alt="img"></p>
<ul>
<li><p>捕获关闭事件</p>
<ul>
<li>可以通过捕获操作系统的进程信号来获取，在 Java 语言里面，对应的是 Runtime.addShutdownHook 方法，可以注册关闭的钩子</li>
</ul>
</li>
<li><p>在 RPC 启动的时候，我们提前注册关闭钩子，并在里面添加了两个处理程序，一个负责开启关闭标识，一个负责安全关闭服务对象，服务对象在关闭的时候会通知调用方下线节点</p>
</li>
<li><p>同时需要在我们调用链里面加上挡板处理器，当新的请求来的时候，会判断关闭标识，如果正在关闭，则抛出特定异常</p>
<ul>
<li>当服务提供方正在关闭，如果这之后还收到了新的业务请求，服务提供方直接返回一个特定的异常给调用方（比如 ShutdownException）<ul>
<li>这个异常就是告诉调用方“我已经收到这个请求了，但是我正在关闭，并没有处理这个请求”</li>
<li>调用方收到这个异常响应后，RPC 框架把这个节点从健康列表挪出，并把请求自动重试到其他节点</li>
<li>因为这个请求是没有被服务提供方处理过，所以可以安全地重试到其他节点，这样就可以实现对业务无损</li>
</ul>
</li>
</ul>
</li>
<li><p>关闭过程中已经在处理的请求</p>
<ul>
<li>在服务对象加上引用计数器，每开始处理请求之前加一，完成请求处理减一，通过该计数器我们就可以快速判断是否有正在处理的请求</li>
<li>根据引用计数器等待正在处理的请求全部结束之后才会真正关闭</li>
<li>考虑到有些业务请求可能处理时间长，或者存在被挂住的情况，为了避免一直等待造成应用无法正常退出，我们可以在整个 ShutdownHook 里面，加上超时时间控制</li>
<li>当超过了指定时间没有结束，则强制退出应用</li>
<li>超时时间我建议可以设定成 10s，基本可以确保请求都处理完了</li>
</ul>
</li>
<li><p>但如果只是靠等待被动调用，就会让这个关闭过程整体有点漫长，加上主动通知流程，这样既可以保证实时性，也可以避免通知失败的情况</p>
<ul>
<li>在 RPC 里面调用方跟服务提供方之间是长连接，在提供方应用内存里面维护一份调用方连接集合，当服务要关闭的时候，挨个去通知调用方去下线这台机器</li>
<li>这样整个调用链路就变短了，对于每个调用方来说就一次 RPC，可以确保调用的成功率很高</li>
</ul>
</li>
</ul>
<h3 id="优雅启动"><a href="#优雅启动" class="headerlink" title="优雅启动"></a>优雅启动</h3><h4 id="启动预热"><a href="#启动预热" class="headerlink" title="启动预热"></a>启动预热</h4><h2 id="相关组件-1"><a href="#相关组件-1" class="headerlink" title="相关组件"></a>相关组件</h2><ul>
<li>Tomcat 关闭的时候也是先从外层到里层逐层进行关闭，先保证不接收新请求，然后再处理关闭前收到的请求</li>
</ul>
<ul>
<li>如果暴力地停止服务，那么已经发送给服务端的请求，来不及处理服务就被删掉了，就会造成这部分请求失败，服务就会有波动</li>
<li>服务在退出的时候，都需要先停掉流量再停止服务，这样服务的关闭才会更平滑</li>
<li>对于 RPC 服务来说，我们可以先将 RPC 服务从注册中心的服务列表中删除掉，然后观察 RPC 服务端没有流量之后，再将服务端停掉</li>
</ul>
<p>Nginx 定期地探测后端服务的一个指定的接口，然后根据返回的状态码来判断服务是否还存活。当探测不存活的次数达到一定阈值时，就自动将这个后端服务从负载均衡服务器中摘除。</p>
<p>在这个接口中返回的 HTTP 状态码，这个返回的状态码可以存储在配置中心中，这样在变更状态码时，就不需要重启服务了（配置中心在第 33 节课中会讲到）。节点检测的功能，还能够帮助我们实现 Web 服务的优雅关闭</p>
<p>在服务刚刚启动时，可以初始化默认的 HTTP 状态码是 500，这样 Nginx 就不会很快将这个服务节点标记为可用，也就可以等待服务中依赖的资源初始化完成，避免服务初始启动时的波动。在完全初始化之后，再将 HTTP 状态码变更为 200，Nginx 经过两次探测后，就会标记服务为可用。在服务关闭时，也应该先将 HTTP 状态码变更为 500，等待 Nginx 探测将服务标记为不可用后，前端的流量也就不会继续发往这个服务节点。在等待服务正在处理的请求全部处理完毕之后，再对服务做重启，可以避免直接重启导致正在处理的请求失败的问题。这是启动和关闭线上 Web 服务时的标准姿势，你可以在项目中参考使用。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/28/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-23 01:42:24" itemprop="dateCreated datePublished" datetime="2021-06-23T01:42:24+08:00">2021-06-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-28 21:08:52" itemprop="dateModified" datetime="2021-06-28T21:08:52+08:00">2021-06-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Internet/" itemprop="url" rel="index"><span itemprop="name">Internet</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h1><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="包头"><a href="#包头" class="headerlink" title="包头"></a>包头</h2><p><img src="https://static001.geekbang.org/resource/image/64/bf/642947c94d6682a042ad981bfba39fbf.jpg" alt="img"></p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><ul>
<li><p>TCP 提供可靠交付，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达</p>
</li>
<li><p>序号和确认序号，可以解决顺序问题</p>
</li>
<li><p>如果没有收到就应该重新发送，直到送达，可以解决不丢包的问题</p>
</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://static001.geekbang.org/resource/image/c0/08/c067fe62f49e8152368c7be9d91adc08.jpg" alt="img"></p>
<ul>
<li>一开始，客户端和服务端都处于 CLOSED 状态</li>
<li>先是服务端主动监听某个端口，处于 LISTEN 状态</li>
<li>然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态</li>
<li>服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态</li>
<li>客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态</li>
<li>服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/12/RPC-%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/12/RPC-%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">RPC 远程过程调用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-12 21:01:04" itemprop="dateCreated datePublished" datetime="2021-06-12T21:01:04+08:00">2021-06-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-24 22:15:54" itemprop="dateModified" datetime="2021-06-24T22:15:54+08:00">2021-06-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Distributed-System/" itemprop="url" rel="index"><span itemprop="name">Distributed System</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li>RPC 框架有明显朝着更高层次（不仅仅负责调用远程服务，还管理远程服务）与插件化方向发展的趋势<ul>
<li>不再选择自己去解决表示数据、传递数据和表示方法这三个问题</li>
<li>而是将全部或者一部分问题设计为扩展点，实现核心能力的可配置</li>
<li>再辅以外围功能，如负载均衡、服务注册、可观察性等方面的支持</li>
</ul>
</li>
</ul>
<h1 id="常见框架-协议"><a href="#常见框架-协议" class="headerlink" title="常见框架/协议"></a>常见框架/协议</h1><ul>
<li>RMI（Sun/Oracle）</li>
<li>Thrift（Facebook/Apache）</li>
<li>Dubbo（阿里巴巴 /Apache）</li>
<li>gRPC（Google）</li>
<li>Motan2（新浪）</li>
<li>Finagle（Twitter）</li>
<li>brpc（百度）</li>
<li>.NET Remoting（微软）</li>
<li>Arvo（Hadoop）</li>
<li>JSON-RPC 2.0（公开规范，JSON-RPC 工作组）</li>
</ul>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Remote Procedure Call，即远程过程调用，是帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul>
<li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法</li>
<li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑</li>
<li>RPC只是服务（进程）之间简化调用的一种方式，使得开发者聚焦于业务本身，而对于服务间通信的各种细节交给框架处理，分布式系统的服务调用可以采用任何一种通信方式，比如http、socket等等</li>
</ul>
<h1 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>发起调用请求的那一方叫做调用方</li>
<li>被调用的一方叫做服务提供方</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><ul>
<li>RPC 是一个远程调用，那肯定就需要通过<strong>网络来传输数据</strong>，并且 RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输</li>
<li>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象</li>
<li>对象是肯定没法直接在网络中传输的，需要提前把它转成可传输的二进制，并且要求转换算法是可逆的</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><p>我们把数据格式的约定内容叫做“协议”</p>
</li>
<li><p>大多数的协议会分成两部分，分别是数据头和消息体</p>
<ul>
<li>数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息</li>
<li>消息体主要是请求的业务参数信息和扩展属性等</li>
</ul>
</li>
</ul>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><ul>
<li><p>根据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来</p>
</li>
<li><p>同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象</p>
</li>
<li><p>服务提供方再根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用</p>
</li>
<li><p>然后把执行结果序列化后，回写到对应的 TCP 通道里面</p>
</li>
<li><p>调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用</p>
</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul>
<li><p>RPC 框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面</p>
</li>
<li><p>该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用</p>
</li>
<li><p>并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验</p>
</li>
</ul>
<h1 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h1><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><ul>
<li>相对于 HTTP 的用处，RPC 更多的是负责应用间的通信，所以<strong>性能</strong>要求相对更高</li>
<li>对于要求高性能的 RPC 来说，HTTP 协议基本很难满足需求，所以 RPC 会选择设计更<strong>紧凑</strong>的私有协议<ul>
<li>HTTP 协议的<strong>数据包大小</strong>相对请求数据本身要大很多，又需要加入很多无用的内容，比如换行符号、回车符等</li>
<li>HTTP 协议属于无状态协议，客户端无法对请求和响应进行关联，每次请求都需要重新建立连接，响应完成后再关闭连接</li>
</ul>
</li>
</ul>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="协议头"><a href="#协议头" class="headerlink" title="协议头"></a>协议头</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p>RPC 每次发请求发的大小都是不固定的，所以我们的协议必须能让接收方正确地读出不定长的内容</p>
</li>
<li><p>我们可以先固定一个长度（比如 4 个字节）用来保存整个请求数据大小，这样收到数据的时候，我们先读取固定长度的位置里面的值，值的大小就代表协议体的长度，接着再根据值的大小来读取协议体的数据</p>
</li>
<li><p>需要把序列化方式单独拿出来，类似协议长度一样用固定的长度存放</p>
</li>
<li><p>这些需要固定长度存放的参数我们可以统称为“协议头”，这样整个协议就会拆分成两部分：协议头和协议体</p>
<ul>
<li><p>在协议头里面，我们除了会放协议长度、序列化方式，还会放一些像协议标示、消息 ID、消息类型这样的参数</p>
</li>
<li><p>协议体一般只放请求接口方法、请求的业务参数值和一些扩展属性</p>
<p><img src="https://static001.geekbang.org/resource/image/ac/2b/ac5f5236d972608fdb24c6eefce7e82b.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h4 id="可扩展的协议"><a href="#可扩展的协议" class="headerlink" title="可扩展的协议"></a>可扩展的协议</h4><ul>
<li><p>关键在于让协议头支持可扩展，扩展后协议头的长度就不能定长了</p>
</li>
<li><p>需要一个固定的写入协议头的长度</p>
</li>
<li><p>整体协议就变成了三部分内容</p>
<ul>
<li>固定部分</li>
<li>协议头内容</li>
<li>协议体内容</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/2a/72/2a202f980458baca9fc50c53275c6772.jpg" alt="img"></p>
</li>
</ul>
<h4 id="如何实现请求跟响应关联"><a href="#如何实现请求跟响应关联" class="headerlink" title="如何实现请求跟响应关联"></a>如何实现请求跟响应关联</h4><ul>
<li><p>RPC 为了吞吐量，会异步并发发送请求，等待应答</p>
</li>
<li><p>以 Dubbo 为例，消费者发送请求时，使用 AtomicLong 自增，产生一个 消息 ID</p>
<ul>
<li>由于 Dubbo 底层 IO 操作是异步的，Dubbo 发送请求之后，需要阻塞等待消费者返回信息</li>
<li>消费者会将消息 ID 保存到 Map 结构中</li>
<li>为了保证请求响应可以一一对应，需要提供者返回的响应信息带上请求者消息 ID</li>
<li>通过响应的消息 ID和  Map 存储数据，就能找到对应的请求</li>
</ul>
</li>
</ul>
<h1 id="如何表示数据-序列化"><a href="#如何表示数据-序列化" class="headerlink" title="如何表示数据-序列化"></a>如何表示数据-序列化</h1><h2 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h2><ul>
<li>无论是将参数传递给另外一个进程，还是从另外一个进程中取回执行结果，都会涉及应该如何表示的问题</li>
<li>因为涉及到跨语言调用，即使是只支持同一种语言的 RPC 协议，在不同硬件指令集、不同操作系统下，也完全可能有不一样的表现细节，比如数据宽度、字节序的差异等</li>
<li>将交互双方涉及的数据，转换为某种事先约定好的中立数据流格式来传输，将数据流转换回不同语言中对应的数据类型来使用，这其实就是序列化与反序列化</li>
<li>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象</li>
<li>对象是不能直接在网络中传输的，所以我们需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，这个过程我们一般叫做“序列化”</li>
<li>服务提供方就可以正确地从二进制数据中分割出不同的请求，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象，这个过程我们称之为“反序列化”</li>
</ul>
<h2 id="常用序列化"><a href="#常用序列化" class="headerlink" title="常用序列化"></a>常用序列化</h2><h3 id="JDK-原生序列化"><a href="#JDK-原生序列化" class="headerlink" title="JDK 原生序列化"></a>JDK 原生序列化</h3><ul>
<li>我们可以看到，JDK 自带的序列化机制对使用者而言是非常简单的</li>
<li>序列化具体的实现是由 ObjectOutputStream 完成的，而反序列化的具体实现是由 ObjectInputStream 完成的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        String home = System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">        String basePath = home + <span class="string">&quot;/Desktop&quot;</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(basePath + <span class="string">&quot;student.dat&quot;</span>);</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setNo(<span class="number">100</span>);</span><br><span class="line">        student.setName(<span class="string">&quot;TEST_STUDENT&quot;</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        oos.writeObject(student);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(basePath + <span class="string">&quot;student.dat&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        Student deStudent = (Student) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(deStudent);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>序列化过程就是在读取对象数据的时候，不断加入一些特殊分隔符，这些特殊分隔符用于在反序列化过程中截断用</p>
<ul>
<li>头部数据用来声明序列化协议、序列化版本，用于高低版本向后兼容</li>
<li>对象数据主要包括类名、签名、属性名、属性类型及属性值，当然还有开头结尾等数据，除了属性值属于真正的对象值，其他都是为了反序列化用的元数据</li>
<li>存在对象引用、继承的情况下，就是递归遍历“写对象”逻辑</li>
</ul>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul>
<li>JSON 是典型的 Key-Value 方式，没有数据类型，是一种文本型序列化框架</li>
<li>如果 RPC 框架选用 JSON 序列化，服务提供者与服务调用者之间传输的数据量要相对较小，否则将严重影响性能</li>
</ul>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>JSON 进行序列化的额外空间开销比较大，对于大数据量服务这意味着需要巨大的内存和磁盘开销</li>
<li>JSON 没有类型，但像 Java 这种强类型语言，需要通过反射统一解决，所以性能不会太好</li>
</ul>
<h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>Hessian 是动态类型、二进制、紧凑的，并且可跨语言移植的一种序列化框架</li>
<li>Hessian 协议要比 JDK、JSON 更加紧凑，性能上要比 JDK、JSON 序列化高效很多，而且生成的字节数也更小</li>
</ul>
<h4 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>Hessian 官方版本对 Java 里面一些常见对象的类型不支持<ul>
<li>Linked 系列，LinkedHashMap、LinkedHashSet 等，但是可以通过扩展 CollectionDeserializer 类修复</li>
<li>Locale 类，可以通过扩展 ContextSerializerFactory 类修复</li>
<li>Byte/Short 反序列化的时候变成 Integer</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setNo(<span class="number">101</span>);</span><br><span class="line">student.setName(<span class="string">&quot;HESSIAN&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把student对象转化为byte数组</span></span><br><span class="line">ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">Hessian2Output output = <span class="keyword">new</span> Hessian2Output(bos);</span><br><span class="line">output.writeObject(student);</span><br><span class="line">output.flushBuffer();</span><br><span class="line"><span class="keyword">byte</span>[] data = bos.toByteArray();</span><br><span class="line">bos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//把刚才序列化出来的byte数组转化为student对象</span></span><br><span class="line">ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(data);</span><br><span class="line">Hessian2Input input = <span class="keyword">new</span> Hessian2Input(bis);</span><br><span class="line">Student deStudent = (Student) input.readObject();</span><br><span class="line">input.close();</span><br><span class="line"></span><br><span class="line">System.out.println(deStudent);</span><br></pre></td></tr></table></figure>

<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><ul>
<li>Protobuf 是 Google 公司内部的混合语言数据标准，是一种轻便、高效的结构化数据存储格式，可以用于结构化数据序列化，支持 Java、Python、C++、Go 等语言</li>
<li>Protobuf 使用的时候需要定义 IDL（Interface description language），然后使用不同语言的 IDL 编译器，生成序列化工具类</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>序列化后体积相比 JSON、Hessian 小很多</li>
<li>IDL 能清晰地描述语义，所以足以帮助并保证应用程序之间的类型不会丢失，无需类似 XML 解析器</li>
<li>序列化反序列化速度很快，不需要通过反射获取类型</li>
<li>消息格式升级和兼容性不错，可以做到向后兼容</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // IDL 文件格式</span></span><br><span class="line"><span class="comment"> * synax = &quot;proto3&quot;;</span></span><br><span class="line"><span class="comment"> * option java_package = &quot;com.test&quot;;</span></span><br><span class="line"><span class="comment"> * option java_outer_classname = &quot;StudentProtobuf&quot;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * message StudentMsg &#123;</span></span><br><span class="line"><span class="comment"> * //序号</span></span><br><span class="line"><span class="comment"> * int32 no = 1;</span></span><br><span class="line"><span class="comment"> * //姓名</span></span><br><span class="line"><span class="comment"> * string name = 2;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line">StudentProtobuf.StudentMsg.Builder builder = StudentProtobuf.StudentMsg.newBuilder();</span><br><span class="line">builder.setNo(<span class="number">103</span>);</span><br><span class="line">builder.setName(<span class="string">&quot;protobuf&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把student对象转化为byte数组</span></span><br><span class="line">StudentProtobuf.StudentMsg msg = builder.build();</span><br><span class="line"><span class="keyword">byte</span>[] data = msg.toByteArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//把刚才序列化出来的byte数组转化为student对象</span></span><br><span class="line">StudentProtobuf.StudentMsg deStudent = StudentProtobuf.StudentMsg.parseFrom(data);</span><br><span class="line"></span><br><span class="line">System.out.println(deStudent);</span><br></pre></td></tr></table></figure>

<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>Protobuf 非常高效，但是对于具有反射和动态能力的语言来说，这样用起来很费劲，这一点就不如 Hessian</p>
</li>
<li><p>比如用 Java 的话，这个预编译过程不是必须的，可以考虑使用 Protostuff</p>
</li>
<li><p>Protostuff 不需要依赖 IDL 文件，可以直接对 Java 领域对象进行反 / 序列化操作</p>
</li>
<li><p>Protostuff 在效率上跟 Protobuf 差不多，生成的二进制格式和 Protobuf 是完全相同的，可以说是一个 Java 版本的 Protobuf 序列化框架</p>
</li>
<li><p>Protostuff 不支持单纯的 Map、List 集合对象，需要包在对象里面</p>
</li>
</ul>
<h3 id="Thrift，Avro"><a href="#Thrift，Avro" class="headerlink" title="Thrift，Avro"></a>Thrift，Avro</h3><h2 id="如何选择序列化框架"><a href="#如何选择序列化框架" class="headerlink" title="如何选择序列化框架"></a>如何选择序列化框架</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><img src="https://static001.geekbang.org/resource/image/b4/a5/b42e44968c3fdcdfe2acf96377f5b2a5.jpg" alt="img"></p>
<ul>
<li>安全性应该放在第一位去考虑，如果序列化存在安全漏洞，那么线上的服务就很可能被入侵</li>
<li>通用性和兼容性，会直接关系到服务调用的稳定性和可用率的<ul>
<li>序列化协议在版本升级后的兼容性是否很好</li>
<li>是否支持更多的对象类型</li>
<li>是否是跨平台、跨语言的</li>
<li>是否有很多人已经用过并且踩过了很多的坑</li>
<li>比如某个类型为集合类的入参服务调用者不能解析了，服务提供方将入参类加一个属性之后服务调用方不能正常调用，升级了 RPC 版本后发起调用时报序列化异常了等等</li>
</ul>
</li>
<li>性能和效率，序列化与反序列化过程是 RPC 调用的一个必须过程，那么序列化与反序列化的性能和效率势必将直接关系到 RPC 框架整体的性能和效率</li>
<li>空间开销，也就是序列化之后的二进制数据的体积大小，由于 RPC 是远程调用，那么网络传输的速度将直接关系到请求响应的耗时<ul>
<li>序列化后的字节数据体积越小，网络传输的数据量就越小，传输数据的速度也就越快</li>
</ul>
</li>
</ul>
<h3 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h3><ul>
<li>我们首选的还是 Hessian 与 Protobuf，因为他们在性能、时间开销、空间开销、通用性、兼容性和安全性上，都满足了我们的要求<ul>
<li>Hessian 在使用上更加方便，在对象的兼容性上更好</li>
<li>Protobuf 则更加高效，通用性上更有优势</li>
</ul>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在使用 RPC 框架的过程中，我们构造入参、返回值对象，主要记住以下几点</p>
<ul>
<li>对象要尽量简单，没有太多的依赖关系，属性不要太多，尽量高内聚</li>
<li>入参对象与返回值对象体积不要太大，更不要传太大的集合</li>
<li>尽量使用简单的、常用的、开发语言原生的对象，尤其是集合类</li>
<li>对象不要有复杂的继承关系，最好不要有父子类的情况</li>
</ul>
<h1 id="网络通信（如何传递数据）"><a href="#网络通信（如何传递数据）" class="headerlink" title="网络通信（如何传递数据）"></a>网络通信（如何传递数据）</h1><h2 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h2><ul>
<li>如何传递数据是指如何通过网络，在两个服务 Endpoint 之间相互操作、交换数据</li>
<li>这里“传递数据”通常指的是应用层协议，实际传输一般是基于标准的 TCP、UDP 等传输层协议来完成的</li>
<li>在系统内核的支持上，现在大多数系统内核都会支持阻塞 IO、非阻塞 IO 和 IO 多路复用，但像信号驱动 IO、异步 IO，只有高版本的 Linux 系统内核才会支持</li>
<li>在编程语言上，无论 C++ 还是 Java，在高性能的网络编程框架的编写上，大多数都是基于 Reactor 模式，其中最为典型的便是 Java 的 Netty 框架，而 Reactor 模式是基于 IO 多路复用的</li>
<li>在非高并发场景下，同步阻塞 IO 是最为常见的</li>
<li>在这四种常用的 IO 模型中，应用最多的、系统内核与编程语言支持最为完善的，便是阻塞 IO 和 IO 多路复用</li>
</ul>
<h2 id="常见网络IO模型"><a href="#常见网络IO模型" class="headerlink" title="常见网络IO模型"></a>常见网络IO模型</h2><ul>
<li><p>常见的网络 IO 模型分为四种：同步阻塞 IO（BIO）、同步非阻塞 IO（NIO）、IO 多路复用和异步非阻塞 IO（AIO）</p>
</li>
<li><p>在这四种 IO 模型中，只有 AIO 为异步 IO，其他都是同步 IO</p>
</li>
</ul>
<h3 id="同步阻塞-IO（BIO）"><a href="#同步阻塞-IO（BIO）" class="headerlink" title="同步阻塞 IO（BIO）"></a>同步阻塞 IO（BIO）</h3><ul>
<li>应用进程发起 IO 系统调用后，应用进程被阻塞，转到内核空间处理</li>
<li>内核开始等待数据，等待到数据之后，再将内核中的数据拷贝到用户内存中，整个 IO 处理完毕后返回进程</li>
<li>最后应用的进程解除阻塞状态，运行业务逻辑</li>
<li>系统内核处理 IO 操作分为两个阶段<ul>
<li>等待数据</li>
<li>拷贝数据。而在这两个阶段中</li>
</ul>
</li>
<li>应用进程中 IO 操作的线程会一直都处于阻塞状态，如果是基于 Java 多线程开发，那么每一个 IO 操作都要占用线程，直至 IO 操作结束</li>
</ul>
<h3 id="同步非阻塞-IO（NIO）"><a href="#同步非阻塞-IO（NIO）" class="headerlink" title="同步非阻塞 IO（NIO）"></a>同步非阻塞 IO（NIO）</h3><h4 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h4><ul>
<li>如 Java 的 NIO、Redis、Nginx 的底层实现就是此类 IO 模型的应用，经典的 Reactor 模式也是基于此类 IO 模型</li>
<li>多路就是指多个通道，也就是多个网络连接的 IO，而复用就是指多个通道复用在一个复用器上</li>
<li>多个网络连接的 IO 可以注册到一个复用器（select）上，当用户进程调用了 select，那么整个进程会被阻塞</li>
<li>内核会“监视”所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回</li>
<li>这个时候用户进程再调用 read 操作，将数据从内核中拷贝到用户进程</li>
<li>优点<ul>
<li>用户可以在一个线程内同时处理多个 socket 的 IO 请求</li>
<li>用户可以注册多个 socket，然后不断地调用 select 读取被激活的 socket，即可达到在同一个线程内同时处理多个 IO 请求的目的</li>
</ul>
</li>
</ul>
<h3 id="异步非阻塞-IO（AIO）"><a href="#异步非阻塞-IO（AIO）" class="headerlink" title="异步非阻塞 IO（AIO）"></a>异步非阻塞 IO（AIO）</h3><h2 id="如何选择网络IO模型"><a href="#如何选择网络IO模型" class="headerlink" title="如何选择网络IO模型"></a>如何选择网络IO模型</h2><ul>
<li>IO 多路复用更适合高并发的场景，可以用较少的进程（线程）处理较多的 socket 的 IO 请求，但使用难度比较高</li>
<li>高级的编程语言支持得还是比较好的<ul>
<li>比如 Java 语言有很多的开源框架对 Java 原生 API 做了封装，如 Netty 框架，使用非常简便</li>
<li>GO 语言，语言本身对 IO 多路复用的封装就已经很简洁了</li>
</ul>
</li>
<li>阻塞 IO 与 IO 多路复用相比，阻塞 IO 每处理一个 socket 的 IO 请求都会阻塞进程（线程），但使用难度较低</li>
<li>在并发量较低、业务逻辑只需要同步进行 IO 操作的场景下，阻塞 IO 已经满足了需求，并且不需要发起 select 调用，开销上还要比 IO 多路复用低</li>
<li>在 RPC 框架的实现中，在网络通信的处理上，我们会选择 IO 多路复用的方式</li>
<li>开发语言的网络通信框架的选型上，我们最优的选择是基于 Reactor 模式实现的框架，如 Java 语言，首选的框架便是 Netty 框架（Java 还有很多其他 NIO 框架，但目前 Netty 应用得最为广泛</li>
<li>在 Linux 环境下，也要开启 epoll 来提升系统性能（Windows 环境下是无法开启 epoll 的，因为系统内核不支持）</li>
</ul>
<h1 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li><p>在Java中动态代理有<strong>两种</strong>方式：</p>
<ul>
<li>JDK动态代理</li>
<li>CGLib动态代理</li>
</ul>
</li>
<li><p>JDK动态代理也有个约束：<strong>目标对象一定是要有接口的，没有接口就不能实现动态代理</strong></p>
</li>
<li><p>cglib代理也叫子类代理，<strong>从内存中构建出一个子类来扩展目标对象的功能！</strong></p>
</li>
<li><p>CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）</p>
</li>
<li><p>JDK动态代理是需要实现某个接口了，而我们类未必全部会有接口，于是CGLib代理就有了</p>
<ul>
<li>CGLib代理其生成的动态代理对象是目标类的子类</li>
<li>Spring AOP<strong>默认是使用JDK动态代理</strong>，如果代理的类<strong>没有接口则会使用CGLib代理</strong>。</li>
</ul>
</li>
<li><p>如果是<strong>单例的我们最好使用CGLib代理</strong>，如果是多例的我们最好使用JDK代理</p>
</li>
<li><p>原因：</p>
<ul>
<li>JDK在创建代理对象时的性能要高于CGLib代理，而生成代理对象的运行性能却比CGLib的低。</li>
<li>如果是单例的代理，推荐使用CGLib</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>RPC 会自动给接口生成一个代理类，当我们在项目中注入接口的时候，运行过程中实际绑定的是这个接口生成的代理类</li>
<li>这样在接口方法被调用的时候，它实际上是被生成代理类拦截到了，这样我们就可以在生成的代理类里面，加入远程调用逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要代理的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实调用对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealHello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;i&#x27;m proxy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK代理类生成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    JDKProxy(Object target) &#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] paramValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((RealHello)target).invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构建代理器</span></span><br><span class="line">        JDKProxy proxy = <span class="keyword">new</span> JDKProxy(<span class="keyword">new</span> RealHello());</span><br><span class="line">        ClassLoader classLoader = ClassLoaderUtils.getCurrentClassLoader();</span><br><span class="line">        <span class="comment">// 把生成的代理类保存到文件</span></span><br><span class="line">System.setProperty(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="comment">// 生成代理类</span></span><br><span class="line">        Hello test = (Hello) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[]&#123;Hello.class&#125;, proxy);</span><br><span class="line">        <span class="comment">// 方法调用</span></span><br><span class="line">        System.out.println(test.say());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Proxy.newProxyInstance</p>
<p><img src="https://static001.geekbang.org/resource/image/50/41/5042cf1b79e6b9233f2152e1e0aca741.jpg" alt="img"></p>
</li>
<li><p>在生成字节码的那个地方，也就是 ProxyGenerator.generateProxyClass() 方法里面是用参数 saveGeneratedFiles 来控制是否把生成的字节码保存到本地磁盘，我们需要把参数 saveGeneratedFiles 设置成 true，但这个参数的值是由 key 为“sun.misc.ProxyGenerator.saveGeneratedFiles”的 Property 来控制的，动态生成的类会保存在工程根目录下的 com/sun/proxy 目录里面。现在我们找到刚才生成的 $Proxy0.class，通过反编译工具打开 class 文件，你会看到这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.proxy.Hello;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler) &#123;</span><br><span class="line">    <span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object paramObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Boolean)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Integer)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m0, <span class="keyword">null</span>)).intValue();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m2, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      m3 = Class.forName(<span class="string">&quot;com.proxy.Hello&quot;</span>).getMethod(<span class="string">&quot;say&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> Class[] &#123; Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>) &#125;);</span><br><span class="line">      m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(noSuchMethodException.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(classNotFoundException.getMessage());</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可以看到 $Proxy0 类里面有一个跟 Hello 一样签名的 say() 方法，其中 this.h 绑定的是刚才传入的 JDKProxy 对象，所以当我们调用 Hello.say() 的时候，其实它是被转发到了 JDKProxy.invoke()</p>
</li>
<li><p>其实在 Java 领域，除了 JDK 默认的 nvocationHandler 能完成代理功能，我们还有很多其他的第三方框架也可以，比如像 Javassist、Byte Buddy 这样的框架</p>
</li>
<li><p>单纯从代理功能上来看，JDK 默认的代理功能是有一定的局限性的，它要求被代理的类只能是接口。原因是因为生成的代理类会继承 Proxy 类，但 Java 是不支持多重继承的；最大的问题是性能问题。它生成后的代理类是使用反射来完成方法调用的，而这种方式相对直接用编码调用来说，性能会降低</p>
</li>
<li><p>相对 JDK 自带的代理功能，Javassist 的定位是能够操纵底层字节码，所以使用起来并不简单，要生成动态代理类恐怕是有点复杂了。但好的方面是，通过 Javassist 生成字节码，不需要通过反射完成方法调用，所以性能肯定是更胜一筹的。在使用中，我们要注意一个问题，通过 Javassist 生成一个代理类后，此 CtClass 对象会被冻结起来，不允许再修改；否则，再次生成时会报错</p>
</li>
<li><p>Byte Buddy 则属于后起之秀，在很多优秀的项目中，像 Spring、Jackson 都用到了 Byte Buddy 来完成底层代理。相比 Javassist，Byte Buddy 提供了更容易操作的 API，编写的代码可读性更高。更重要的是，生成的代理类执行速度比 Javassist 更快</p>
</li>
</ul>
<h3 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h3><ul>
<li>既然动态代理是一种具体的技术框架，那就会涉及到选型。我们可以从这样三个角度去考虑：<ul>
<li>因为代理类是在运行中生成的，那么代理框架生成代理类的速度、生成代理类的字节码大小等等，都会影响到其性能——生成的字节码越小，运行所占资源就越小</li>
<li>还有就是我们生成的代理类，是用于接口方法请求拦截的，所以每次调用接口方法的时候，都会执行生成的代理类，这时生成的代理类的执行效率就需要很高效</li>
<li>最后一个是从我们的使用角度出发的，我们肯定希望选择一个使用起来很方便的代理类框架，比如我们可以考虑：API 设计是否好理解、社区活跃度、还有就是依赖复杂度等等</li>
</ul>
</li>
</ul>
<h1 id="RPC-v-s-REST"><a href="#RPC-v-s-REST" class="headerlink" title="RPC v.s. REST"></a>RPC v.s. REST</h1><ul>
<li>很多人都会拿 REST 来跟 RPC 对比优劣，其实，无论是思想上、概念上，还是使用范围上，REST 与 RPC 都不完全一样，它们在本质上并不是同一个类型的东西，充其量只算是有一些相似，在应用中会有一部分功能重合的地方</li>
<li>REST 与 RPC 在思想上存在差异的核心，是抽象的目标不一样，也就是面向资源的编程思想与面向过程的编程思想之间的区别</li>
</ul>
<h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ul>
<li><p>你认为，RPC 使用过程中需要注意哪些问题？</p>
<ul>
<li><p>下游服务的服务能力，避免因为你的调用把别人给调挂了，要事前协商好qps等，做好限流</p>
</li>
<li><p>调用服务异常时，要考虑降级、重试等措施</p>
</li>
<li><p>核心的服务不能强依赖非核心的服务，避免核心服务因为非核心服务异常而不可用</p>
</li>
<li><p>采用rpc 开发最终要我觉得是设置合理超时时间以及重试次数</p>
<ul>
<li>因为 rpc毕竟需要走网络调用，存在网络耗时</li>
<li>超时间太短，可能导致服务提供端实际执行成功，消费端却因为超时报错结束</li>
<li>这就有可能导致数据状态不一致</li>
</ul>
</li>
<li><p>另外，整个链路的超时需要合理设置，如A-》B-〉C，A的超时时间要大于B。</p>
</li>
<li><p>重试次数也需要关注，默认情况下，如 dubbo 重试次数为2，调用失败的情况下，框架会重新调用</p>
</li>
<li><p>而有些服务不能重复调用</p>
</li>
<li><p>服务提供者应该是最熟悉自己服务的，所以服务提供者可以设置默认超时时间以及重试次数，消费者不设置，就会采用服务提供者参数设置</p>
</li>
</ul>
</li>
<li><p>RPC 与 rest 接口的区别</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/06/MySQL-%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/06/MySQL-%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">MySQL 索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-06 23:39:56" itemprop="dateCreated datePublished" datetime="2021-06-06T23:39:56+08:00">2021-06-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-12 20:56:03" itemprop="dateModified" datetime="2021-06-12T20:56:03+08:00">2021-06-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul>
<li>索引是存储引擎用于可快速找到记录的一种数据结构</li>
<li>索引是在存储引擎层，不同存储引擎的索引工作方式不同</li>
</ul>
<h1 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h1><p>MySQL支持的索引类型有三种</p>
<h2 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+ Tree 索引"></a>B+ Tree 索引</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>所有值按顺序存储，每个叶子页到根的距离相同</li>
<li>加快访问数据的速度，不需要进行全表扫描，从索引的根节点开始进行向下层查找<ul>
<li>比较节点页的值和要查找的值找合适的指针进入下层节点</li>
<li>直到找到指向被索引的数据的叶子节点</li>
</ul>
</li>
<li>所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/06/MySQL-%E7%B4%A2%E5%BC%95/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/06/MySQL-%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/06/MySQL-%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">MySQL 架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-06 21:35:04" itemprop="dateCreated datePublished" datetime="2021-06-06T21:35:04+08:00">2021-06-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-12 20:13:02" itemprop="dateModified" datetime="2021-06-12T20:13:02+08:00">2021-06-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h1><h2 id="一条-SQL-语句是如何执行的"><a href="#一条-SQL-语句是如何执行的" class="headerlink" title="一条 SQL 语句是如何执行的"></a>一条 SQL 语句是如何执行的</h2><ul>
<li>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。</li>
<li>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句<ul>
<li>查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端</li>
<li>否则执行语句</li>
</ul>
</li>
<li>分析器对语句进行词法分析和语法分析</li>
<li>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"></p>
<ul>
<li>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分</li>
<li>Server 层<ul>
<li>包括连接器、查询缓存、分析器、优化器、执行器等</li>
<li>涵盖 MySQL 的大多数核心服务功能</li>
<li>所有的内置函数（如日期、时间、数学和加密函数等）</li>
<li>所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等</li>
</ul>
</li>
<li>存储引擎层<ul>
<li>负责数据的存储和提取</li>
<li>其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎</li>
<li>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎</li>
</ul>
</li>
<li>可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表</li>
<li>从图中不难看出，不同的存储引擎共用一个 Server 层</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/06/MySQL-%E6%9E%B6%E6%9E%84/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/06/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/06/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">虚拟机类加载机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-06 21:17:07 / Modified: 21:38:05" itemprop="dateCreated datePublished" datetime="2021-06-06T21:17:07+08:00">2021-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载 Loading"></a>加载 Loading</h2><p>三层类加载器、双亲委派的类加载架构</p>
<h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/06/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">分布式事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-06 17:35:52" itemprop="dateCreated datePublished" datetime="2021-06-06T17:35:52+08:00">2021-06-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-09 22:31:09" itemprop="dateModified" datetime="2021-06-09T22:31:09+08:00">2021-06-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Distributed-System/" itemprop="url" rel="index"><span itemprop="name">Distributed System</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h1><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><ul>
<li><p>事务最终的状态只有两种，全部执行成功和全部不执行，不会停留在中间某个环节</p>
</li>
<li><p>若处理事务的任何一项操作不成功，就会导致整个事务失败</p>
</li>
<li><p>一旦操作失败，所有操作都会被取消（即回滚），使得事务仿佛没有被执行过一样</p>
</li>
</ul>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><ul>
<li><p>是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态</p>
</li>
<li><p>比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。 </p>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/05/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/05/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">JVM 垃圾回收</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-05 19:41:53" itemprop="dateCreated datePublished" datetime="2021-06-05T19:41:53+08:00">2021-06-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-06 21:37:04" itemprop="dateModified" datetime="2021-06-06T21:37:04+08:00">2021-06-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li>为什么要学习垃圾回收？<ul>
<li>需要排查内存溢出、内存泄漏问题时，垃圾回收可能成为系统达到高并发量的瓶颈</li>
</ul>
</li>
<li>哪些内存需要回收？<ul>
<li> Java堆和方法区这两个区域有很显著的不确定性，内存的分配和回收是动态的</li>
<li>Java运行区域的各个部分中，程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭，分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存回收具备确定性</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/05/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lsinger</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
