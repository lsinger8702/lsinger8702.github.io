<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script><script src="/js/config.js"></script>
<meta name="description" content="网络七层协议TCP包头 可靠性 TCP 提供可靠交付，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达  序号和确认序号，可以解决顺序问题  如果没有收到就应该重新发送，直到送达，可以解决不丢包的问题   三次握手流程  一开始，客户端和服务端都处于 CLOSED 状态 先是服务端主动监听某个端口，处于 LISTEN 状态 然后客户端主动发起连接 SYN，之后处于 SYN-SEN">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://yoursite.com/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Lsinger&#39; s blog">
<meta property="og:description" content="网络七层协议TCP包头 可靠性 TCP 提供可靠交付，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达  序号和确认序号，可以解决顺序问题  如果没有收到就应该重新发送，直到送达，可以解决不丢包的问题   三次握手流程  一开始，客户端和服务端都处于 CLOSED 状态 先是服务端主动监听某个端口，处于 LISTEN 状态 然后客户端主动发起连接 SYN，之后处于 SYN-SEN">
<meta property="og:locale">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/64/bf/642947c94d6682a042ad981bfba39fbf.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/c0/08/c067fe62f49e8152368c7be9d91adc08.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/bf/13/bf1254f85d527c77cc4088a35ac11d13.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/85/c1/85ebb0396cbaa45ce00b505229e523c1.jpeg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/6b/63/6bc37ddcb4e7a61ca3275790820f2263.jpeg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/77/af/77c852ff2202b2b7bb3299a96a0f4aaf.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/f5/a6/f569c80f8f4b25b3bf384037813cdca6.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/ae/08/ae7dbe9f8785441721deb1f7b316f708.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/7d/f5/7d77973b1623717cd519b0d3f8b7d4f5.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/dc/28/dca53475b9ec945b9bd3dd30f37b6328.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/5c/70/5c0e68d5766befd701ab3f3fae3eea70.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/89/4d/890ff98fde625c6a60fb71yy22d8184d.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/71/e8/718e3a1a1a7927302b6a0f836409e8e8.jpg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/663581/1602998743124-f28edbdb-e49f-4648-837f-b8880e11f5c8.png">
<meta property="article:published_time" content="2021-06-22T17:42:24.000Z">
<meta property="article:modified_time" content="2021-06-28T13:08:52.824Z">
<meta property="article:author" content="Lsinger">
<meta property="article:tag" content="Interview">
<meta property="article:tag" content="Internet">
<meta property="article:tag" content="Basic Knowledge">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/64/bf/642947c94d6682a042ad981bfba39fbf.jpg">


<link rel="canonical" href="http://yoursite.com/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;default&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;06&#x2F;23&#x2F;%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;06&#x2F;23&#x2F;计算机网络&#x2F;&quot;,&quot;title&quot;:&quot;计算机网络&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>计算机网络 | Lsinger' s blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lsinger' s blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Lsinger' s blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.</span> <span class="nav-text">网络七层协议</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP"><span class="nav-number">2.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E5%A4%B4"><span class="nav-number">2.1.</span> <span class="nav-text">包头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">可靠性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">2.3.</span> <span class="nav-text">三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.1.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-number">2.3.2.</span> <span class="nav-text">为什么三次握手？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">2.4.</span> <span class="nav-text">四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B-1"><span class="nav-number">2.4.1.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="nav-number">2.4.2.</span> <span class="nav-text">特殊情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">2.4.3.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CLOSE-WAIT"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">CLOSE_WAIT</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0-1"><span class="nav-number">2.4.3.2.1.</span> <span class="nav-text">原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.3.2.2.</span> <span class="nav-text">解决方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TIME-WAIT"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">TIME_WAIT</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0-2"><span class="nav-number">2.4.3.3.1.</span> <span class="nav-text">原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">2.4.3.3.2.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2MSL"><span class="nav-number">2.4.3.3.3.</span> <span class="nav-text">2MSL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%B1%E5%AE%B3"><span class="nav-number">2.4.3.3.4.</span> <span class="nav-text">危害</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3"><span class="nav-number">2.4.3.3.5.</span> <span class="nav-text">解决</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">2.5.</span> <span class="nav-text">流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.5.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87-SWS-Silly-Window-Syndrome%EF%BC%89"><span class="nav-number">2.5.2.</span> <span class="nav-text">糊涂窗口综合症 SWS(Silly Window Syndrome）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0-3"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3-1"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">2.6.</span> <span class="nav-text">拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-number">2.6.1.</span> <span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B2%98%E5%8C%85"><span class="nav-number">2.7.</span> <span class="nav-text">粘包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">2.7.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.7.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UDP"><span class="nav-number">3.</span> <span class="nav-text">UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0-UDP%EF%BC%88Google-%E7%9A%84-QUIC-%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">可靠 UDP（Google 的 QUIC 协议）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-v-s-UDP"><span class="nav-number">4.</span> <span class="nav-text">TCP v.s. UDP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP"><span class="nav-number">5.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">5.1.</span> <span class="nav-text">输入网址后发生了什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTPS"><span class="nav-number">6.</span> <span class="nav-text">HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF-1"><span class="nav-number">6.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-2"><span class="nav-number">6.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B-2"><span class="nav-number">6.3.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSL-TLS"><span class="nav-number">6.4.</span> <span class="nav-text">SSL&#x2F;TLS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81"><span class="nav-number">6.5.</span> <span class="nav-text">认证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="nav-number">6.6.</span> <span class="nav-text">数字证书</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7"><span class="nav-number">6.6.1.</span> <span class="nav-text">数字证书申请 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6"><span class="nav-number">6.6.2.</span> <span class="nav-text">浏览器验证证书</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Domain-Name-System-DNS"><span class="nav-number">7.</span> <span class="nav-text">Domain Name System, DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">7.1.</span> <span class="nav-text">DNS 服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS-%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">DNS 解析流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">8.</span> <span class="nav-text">网络字节序</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lsinger</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-23 01:42:24" itemprop="dateCreated datePublished" datetime="2021-06-23T01:42:24+08:00">2021-06-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-28 21:08:52" itemprop="dateModified" datetime="2021-06-28T21:08:52+08:00">2021-06-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Internet/" itemprop="url" rel="index"><span itemprop="name">Internet</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h1><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="包头"><a href="#包头" class="headerlink" title="包头"></a>包头</h2><p><img src="https://static001.geekbang.org/resource/image/64/bf/642947c94d6682a042ad981bfba39fbf.jpg" alt="img"></p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><ul>
<li><p>TCP 提供可靠交付，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达</p>
</li>
<li><p>序号和确认序号，可以解决顺序问题</p>
</li>
<li><p>如果没有收到就应该重新发送，直到送达，可以解决不丢包的问题</p>
</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://static001.geekbang.org/resource/image/c0/08/c067fe62f49e8152368c7be9d91adc08.jpg" alt="img"></p>
<ul>
<li>一开始，客户端和服务端都处于 CLOSED 状态</li>
<li>先是服务端主动监听某个端口，处于 LISTEN 状态</li>
<li>然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态</li>
<li>服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态</li>
<li>客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态</li>
<li>服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态</li>
</ul>
<span id="more"></span>

<h3 id="为什么三次握手？"><a href="#为什么三次握手？" class="headerlink" title="为什么三次握手？"></a>为什么三次握手？</h3><ul>
<li>包是可能丢的，所以起码一来一回</li>
<li>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误<ul>
<li>A 和 B 原来建立了连接，做了简单通信后，结束了连接</li>
<li>A 建立连接的时候，请求包重复发了几次，有的请求包绕了一大圈又回来了</li>
<li>B 会认为这也是一个正常的的请求的话，因此建立了连接，但这个连接不会进行下去但也不会终结</li>
<li>因而两次握手肯定不行</li>
</ul>
</li>
<li>超过三次，也不能保证就真的可靠了，只要双方的消息都有去有回，就基本可以了</li>
<li>在大部分情况下，A 和 B 建立了连接之后，A 会马上发送数据的，一旦 A 发送数据，则很多问题都得到了解决</li>
</ul>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p><img src="https://static001.geekbang.org/resource/image/bf/13/bf1254f85d527c77cc4088a35ac11d13.jpg" alt="img"></p>
<ul>
<li><p>一方应用程序调用 close，我们称该方为主动关闭方，该端的 TCP 发送一个 FIN 包，表示需要关闭连接，然后进入 FIN_WAIT_1 状态</p>
</li>
<li><p>接着，接收到这个 FIN 包的对端执行被动关闭，被动关闭方进入 CLOSE_WAIT 状态</p>
<ul>
<li>这个 FIN 由 TCP 协议栈处理，TCP 协议栈为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，应用程序可以通过 read 调用来感知这个 FIN 包</li>
<li>这个 EOF 会被放在已排队等候的其他已接收的数据之后，这就意味着接收端应用程序需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达</li>
</ul>
</li>
<li><p>接下来，被动关闭方将读到这个 EOF，于是，应用程序也调用 close 关闭它的套接字，这导致它的 TCP 也发送一个 FIN 包，之后进入 LAST_ACK 状态。</p>
</li>
<li><p>最终，主动关闭方接收到对方的 FIN 包，并确认这个 FIN 包，进入 TIME_WAIT 状态</p>
</li>
<li><p>接收到 ACK 的被动关闭方则进入 CLOSED 状态</p>
</li>
<li><p>经过 2MSL 时间之后，主动关闭方也进入 CLOSED 状态</p>
</li>
</ul>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul>
<li><p>一种情况是，A 说完“不玩了”之后，直接跑路，是会有问题的，因为 B 还没有发起结束，而如果 A 跑路，B 就算发起结束，也得不到回答，B 就不知道该怎么办了</p>
</li>
<li><p>A 说完“不玩了”，B 直接跑路，也是有问题的，因为 A 不知道 B 是还有事情要处理，还是过一会儿会发送结束</p>
</li>
<li><p>同时断开时，如果主机在FIN_WAIT1状态下首先收到对端主机的FIN包的话，那么该主机在确认已经收到了对端主机全部的Data数据包后，就响应一个ACK给对端主机，然后自己进入CLOSEING状态，主机在CLOSEING状态下收到自己的FIN包的ACK包的话，那么就进入TIME WAIT 状态。于是TCP的主机两端同时发起FIN包进行断开连接，那么两端主机可能出现完全一样的状态转移 FIN_WAIT1——&gt;CLOSEING——-&gt;TIME_WAIT，也就会Client和Server最后同时进入TIME_WAIT状态</p>
</li>
<li><p>常用的三个状态是</p>
<ul>
<li>ESTABLISHED表示正在通信 </li>
<li>TIME_WAIT表示主动关闭</li>
<li>CLOSE_WAIT表示被动关闭</li>
</ul>
</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li><p>如果服务器出现了异常，很大的可能是出现了以下两种情况</p>
<ul>
<li>服务器保持了大量的TIME_WAIT状态</li>
<li>服务器保持了大量的CLOSE_WAIT状态 </li>
</ul>
</li>
<li><p>Linux系统中分给每个用户的文件句柄数是有限的，而TIME_WAIT和CLOSE_WAIT这两种状态如果一直被保持，那么意味着对应数目的通道(此处应理解为socket，一般一个socket会占用服务器端一个端口，服务器端的端口最大数是65535)一直被占用，一旦达到了上限，则新的请求就无法被处理，接着就是大量Too Many Open Files异常，然后tomcat、nginx、apache崩溃</p>
</li>
</ul>
<h4 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h4><h5 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h5><ul>
<li><p>TCP 连接终止时，主机 1 先发送 FIN 报文，主机 2 进入 CLOSE_WAIT 状态，并发送一个 ACK 应答</p>
</li>
<li><p>同时，主机 2 通过 read 调用获得 EOF，并将此结果通知应用程序进行主动关闭操作，发送 FIN 报文</p>
</li>
<li><p>在对方关闭连接后，程序里没有检测到，或者程序里本身就已经忘了这个时候需要关闭连接，于是这个资源就一直被程序占用着</p>
</li>
</ul>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ul>
<li>关闭正在运行的程序，这个需要视业务情况而定</li>
<li>尽快的修改程序里的bug，然后测试提交到线上服务器</li>
<li>服务端接口耗时较长，客户端主动断开了连接，此时，服务端就会出现 close_wait</li>
<li>如果代码不规范的话，在收到对方发起的fin后，自己根本就不会给人家发fin，反正close_wait基本就是自己这边的问题了</li>
</ul>
<h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><h5 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h5><ul>
<li><p>主机 1 在 TIME_WAIT 停留持续时间是固定的，是最长分节生命期 MSL（maximum segment lifetime）的两倍，一般称之为 2MSL</p>
<ul>
<li>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</li>
</ul>
</li>
<li><p>只有发起连接终止的一方会进入 TIME_WAIT 状态 </p>
</li>
</ul>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭<ul>
<li>如果主机 1 的 ACK 报文没有传输成功，那么主机 2 就会重新发送 FIN 报文</li>
<li>如果主机 1 没有维护 TIME_WAIT 状态，而直接进入 CLOSED 状态，它就失去了当前状态的上下文，只能回复一个 RST 操作，从而导致被动关闭方出现错误</li>
<li>现在主机 1 知道自己处于 TIME_WAIT 的状态，就可以在接收到 FIN 报文之后，重新发出一个 ACK 报文，使得主机 2 可以进入正常的 CLOSED 状态</li>
</ul>
</li>
<li>和连接“化身”和报文迷走有关系，为了让旧连接的重复分节在网络中自然消失<ul>
<li>如果主机1直接关闭，端口就直接空出来了，但是 主机 2不知道，主机 2 原来发过的很多包很可能还在路上，如果主机 1的端口被一个新的应用占用了，这个新的应用会收到上个连接中主机 2发过来的包，虽然序列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来主机 2发送的所有的包都死翘翘，再空出端口来</li>
</ul>
</li>
</ul>
<h5 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h5><ul>
<li>经过 2MSL 这个时间，足以让两个方向上的分组都被丢弃，使得原来连接的分组在网络中都自然消失，再出现的分组一定都是新化身所产生的</li>
<li>这个时间要足够长，长到如果 B 没收到 ACK 的话，“B 说不玩了”会重发的，A 会重新发一个 ACK 并且足够时间到达 B</li>
<li>2MSL 的时间是从主机 1 接收到 FIN 后发送 ACK 开始计时的</li>
<li>如果在 TIME_WAIT 时间内，因为主机 1 的 ACK 没有传输到主机 2，主机 1 又接收到了主机 2 重发的 FIN 报文，那么 2MSL 时间将重新计时</li>
<li>MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃</li>
</ul>
<h5 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h5><ul>
<li>内存资源占用，这个目前看来不是太严重，基本可以忽略</li>
<li>对端口资源的占用，一个 TCP 连接至少消耗一个本地端口</li>
<li>端口资源也是有限的，一般可以开启的端口为 32768～61000 ，也可以通过net.ipv4.ip_local_port_range指定，如果 TIME_WAIT 状态过多，会导致无法创建新连接 </li>
</ul>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><ul>
<li><p>优化内核参数</p>
<ul>
<li>调低 TCP_TIMEWAIT_LEN，重新编译系统这个方法是一个不错的方法</li>
<li>缺点是需要“一点”内核方面的知识，能够重新编译内核</li>
<li>这个不是大多数人能接受的方式</li>
</ul>
</li>
<li><p>net.ipv4.tcp_tw_reuse</p>
<ul>
<li>如果是安全可控的，可以复用处于 TIME_WAIT 的套接字为新的连接所用</li>
<li>只适用于连接发起方（C/S 模型中的客户端）</li>
<li>对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用</li>
<li>前提是打开对 TCP 时间戳的支持，即net.ipv4.tcp_timestamps=1（默认即为 1）</li>
<li>为了保证 TCP 的高可用，引入了新的 TCP 选项，两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。由于引入了时间戳，我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃</li>
</ul>
</li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>在对于包的确认中，同时会携带一个窗口 Advertised window，如果接收方实在处理的太慢，导致缓存中没有空间了，可以通过确认信息修改窗口的大小</li>
<li>甚至可以设置为 0，则发送方将暂时停止发送，此时发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小</li>
</ul>
<h3 id="糊涂窗口综合症-SWS-Silly-Window-Syndrome）"><a href="#糊涂窗口综合症-SWS-Silly-Window-Syndrome）" class="headerlink" title="糊涂窗口综合症 SWS(Silly Window Syndrome）"></a>糊涂窗口综合症 SWS(Silly Window Syndrome）</h3><h4 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h4><ul>
<li><p>少量的数据将通过连接进行交换，而不是满长度的报文段</p>
</li>
<li><p>该现象可发生在两端中的任何一端</p>
<ul>
<li>接收方通告一个小的窗口（而不是一直等到有大的窗口时才通告）</li>
<li>发送方发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）</li>
</ul>
</li>
</ul>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><ul>
<li><p>接收方不通告小窗口</p>
<ul>
<li>通常的算法是接收方不通告一个比当前窗口大的窗口（可以为0），直到窗口可以增加一个报文段大小或者可以接收方缓存空间的一半</li>
</ul>
</li>
<li><p>发送方，不应发送小的报文段，由Nagle算法控制何时发送</p>
<ul>
<li>可以发送一个满长度的报文段</li>
<li>可以发送至少是接收方通告窗口大小一半的报文段</li>
<li>某一 ACK 不是目前期盼的</li>
<li>该链接禁用 Nagle 算法</li>
</ul>
</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li><p>通过窗口 cwnd 大小来控制的，防止把网络塞满，导致包丢失和超时重传</p>
</li>
<li><p>这里有一个公式 LastByteSent - LastByteAcked &lt;= min {cwnd, rwnd} ，是拥塞窗口和滑动窗口共同控制发送的速度</p>
<ul>
<li>通道的容量 = 带宽 × 往返延迟</li>
<li>如果我们设置发送窗口，使得发送但未确认的包为为通道的容量，就能够撑满整个管道</li>
</ul>
</li>
<li><p>一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个</p>
</li>
<li><p>每收到一个确认 cwnd 加一，指数性的增长</p>
</li>
<li><p>直到 ssthresh 为 65535 个字节，当超过这个值的时候慢下来</p>
</li>
<li><p>每收到一个确认 cwnd 增加 1/cwnd，我们接着上面的过程来，变成了线性增长</p>
</li>
<li><p>直到有一天，水满则溢，出现了拥塞，这个时候将 sshresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动</p>
<ul>
<li>拥塞的一种表现形式是丢包，需要超时重传</li>
<li>但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿</li>
</ul>
</li>
<li><p>快速重传算法</p>
<ul>
<li>当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传</li>
<li>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，cwnd 减半为 cwnd/2，然后 sshthresh = cwnd</li>
<li>当三个包返回的时候，cwnd = sshthresh + 3，还在比较高的值，呈线性增长</li>
</ul>
</li>
<li><p>为了优化这两个问题，后来有了 TCP BBR 拥塞算法</p>
</li>
</ul>
<h2 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li><p>TCP  协议是基于字节流的传输层协议，其中不存在消息和数据包的概念</p>
</li>
<li><p>当应用层协议通过 TCP 协议传输数据时，实际上待发送的数据先被写入了 TCP 协议的缓冲区，等待缓冲区中数据超过最大数据段（MSS）或者上一个数据段被 ACK 时才会发送缓冲区中的数据</p>
</li>
<li><p>可能会导致应用层协议多次写入的数据被合并或者拆分发送</p>
</li>
<li><p>应用层协议没有使用基于长度或者基于终结符的消息边界，导致多个消息的粘连</p>
</li>
<li><p>当接收方从  TCP 协议栈中读取数据时会发现不相关的数据出现在了同一个数据段中，应用层协议可能没有办法对它们进行拆分和重组</p>
</li>
<li><p>UDP  是有消息边界的，每个 UDP 数据包都表示一个完整的消息，所以不会出现粘包</p>
<ul>
<li>应用层的数据包大小应该尽可肯能接近 UDP 的最大负荷，可以充分利用带宽</li>
</ul>
</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>不停轮询</p>
<ul>
<li>看能不能反序列包头，再拆包头反序列化出包体长度值</li>
<li>比较跟收到的包体的是否一致</li>
<li>然后取出包体，再尝试反序列化</li>
</ul>
</li>
<li><p>使用基于长度或者基于终结符的消息边界</p>
</li>
</ul>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li><p>流媒体的协议</p>
<ul>
<li>对于丢包，其实对于视频播放来讲，有的包可以丢，有的包不能丢，因为视频的连续帧里面，有的帧重要，有的不重要，如果必须要丢包，隔几个帧丢一个，其实看视频的人不会感知，但是如果连续丢帧，就会感知了，因而在网络不好的情况下，应用希望选择性的丢帧</li>
</ul>
</li>
<li><p>游戏对实时要求较为严格的情况下，采用自定义的可靠 UDP 协议，自定义重传策略，能够把丢包产生的延迟降到最低 </p>
</li>
</ul>
<h2 id="可靠-UDP（Google-的-QUIC-协议）"><a href="#可靠-UDP（Google-的-QUIC-协议）" class="headerlink" title="可靠 UDP（Google 的 QUIC 协议）"></a>可靠 UDP（Google 的 QUIC 协议）</h2><ul>
<li><p>自定义连接机制</p>
<ul>
<li>面向连接</li>
<li>一条 TCP 连接是由四元组标识的，分别是源 IP、源端口、目的 IP、目的端口</li>
<li>一旦一个元素发生变化时，就需要断开重连，重新连接</li>
<li>在移动互联情况下，当手机信号不稳定或者在 WIFI 和 移动网络切换时，都会导致重连，从而进行再次的三次握手，导致一定的时延</li>
<li>基于 UDP，就可以在 QUIC 自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个 64 位的随机数作为 ID 来标识，而且 UDP 是无连接的，所以当 IP 或者端口变化的时候，只要 ID 不变，就不需要重新建立连接</li>
</ul>
</li>
<li><p>自定义重传机制</p>
<ul>
<li>前面我们讲过，TCP 为了保证可靠性，通过使用序号和应答机制，来解决顺序问题和丢包问题</li>
<li>任何一个序号的包发过去，都要在一定的时间内得到应答，否则一旦超时，就会重发这个序号的包</li>
<li>这个超时是通过采样往返时间 RTT 不断调整的，在 TCP 里面超时的采样存在不准确的问题</li>
<li>QUIC 也有个递增的序列号，任何一个序列号的包只发送一次，下次就要加一了，RTT 计算相对准确</li>
<li>QUIC 定义了一个 offset 概念<ul>
<li>发送的数据在这个数据流里面有个偏移量 offset，可以通过 offset 查看数据发送到了哪里，这样只要这个 offset 的包没有来，就要重发</li>
<li>QUIC 的 ACK 是基于 offset 的，每个 offset 的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空档会等待到来或者重发即可</li>
<li>如果来了，按照 offset 拼接成一个流</li>
</ul>
</li>
</ul>
</li>
<li><p>无阻塞的多路复用</p>
<ul>
<li>有了自定义的连接和重传机制，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求</li>
<li>但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖</li>
</ul>
</li>
<li><p>自定义流量控制</p>
<ul>
<li>TCP 的流量控制是通过滑动窗口协议</li>
<li>QUIC 的流量控制也是通过 window_update，来告诉对端它可以接受的字节数</li>
<li>但是 QUIC 的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个 stream 控制窗口</li>
<li>窗口的起始位置为当前收到的最大 offset，从这个 offset 到当前的 stream 所能容纳的最大缓存，是真正的窗口大小</li>
<li>整个连接的窗口，需要对于所有的 stream 的窗口做一个统计</li>
</ul>
</li>
</ul>
<h1 id="TCP-v-s-UDP"><a href="#TCP-v-s-UDP" class="headerlink" title="TCP v.s. UDP"></a>TCP v.s. UDP</h1><ul>
<li><p>TCP 是面向连接的，UDP 是面向无连接的</p>
<ul>
<li>所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性</li>
</ul>
</li>
<li><p>TCP 提供可靠交付，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达；UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达</p>
</li>
<li><p>TCP 是面向字节流的，发送的时候发的是一个流，没头没尾；UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收</p>
</li>
<li><p>TCP 是可以有拥塞控制的；UDP 就不会，应用让我发，我就发，管它洪水滔天</p>
</li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="输入网址后发生了什么"><a href="#输入网址后发生了什么" class="headerlink" title="输入网址后发生了什么"></a>输入网址后发生了什么</h2><ul>
<li><p>浏览器会将 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 这个域名发送给 DNS 服务器，让它解析为 IP 地址</p>
</li>
<li><p>HTTP 是基于 TCP 协议的，要先建立 TCP 连接了</p>
</li>
<li><p>构建HTTP请求</p>
<ul>
<li><p>在 HTTP 头里面，Cache-control 是用来控制缓存的</p>
<ul>
<li>当客户端发送的请求中包含 max-age 指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源</li>
<li>当指定 max-age 值为 0，那么缓存层通常需要将请求转发给应用集群</li>
</ul>
</li>
<li><p>If-Modified-Since 也是一个关于缓存的</p>
<ul>
<li>如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源</li>
<li>如果没有更新，服务端会返回“304 Not Modified”的响应，那客户端就不用下载了，也会节省带宽</li>
</ul>
</li>
</ul>
</li>
</ul>
<p> <img src="https://static001.geekbang.org/resource/image/85/c1/85ebb0396cbaa45ce00b505229e523c1.jpeg" alt="img">  </p>
<ul>
<li><p>发送 HTTP 请求</p>
<ul>
<li>HTTP 协议是基于 TCP 协议的，所以它通过 stream 二进制流的方式传给对方</li>
</ul>
</li>
<li><p>TCP 层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址），将这两个信息放到 IP 头里面，交给 IP 层进行传输</p>
</li>
<li><p>IP 层需要查看目标地址和自己是否是在同一个局域网</p>
<ul>
<li>如果是，就发送 ARP 协议来请求这个目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放入 MAC 头，发送出去即可</li>
<li>如果不在同一个局域网，就需要发送到网关，还要需要发送 ARP 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC 头，发送出去</li>
</ul>
</li>
<li><p>网关收到包发现 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，将包发给下一跳路由器</p>
</li>
<li><p>这样路由器一跳一跳终于到达目标的局域网</p>
</li>
<li><p>最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上。于是，在这个局域网上发送 ARP，获得这个目标地址的 MAC 地址，将包发出去</p>
</li>
<li><p>目标的机器发现 MAC 地址符合，就将包收起来</p>
</li>
<li><p>发现 IP 地址符合，根据 IP 头中协议项，知道自己上一层是 TCP 协议，于是解析 TCP 的头，里面有序列号，需要看一看这个序列包是不是我要的</p>
<ul>
<li>如果是就放入缓存中然后返回一个 ACK</li>
<li>如果不是就丢弃</li>
</ul>
</li>
<li><p>TCP 头里面还有端口号，HTTP 的服务器正在监听这个端口号，目标机器就知道是 HTTP 服务器这个进程想要这个包，于是将包发给 HTTP 服务器</p>
</li>
<li><p>HTTP 服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端</p>
</li>
<li><p>HTTP 返回的构建 </p>
</li>
</ul>
<p> <img src="https://static001.geekbang.org/resource/image/6b/63/6bc37ddcb4e7a61ca3275790820f2263.jpeg" alt="img">  </p>
<ul>
<li><p>构造好了返回的 HTTP 报文，接下来就是把这个报文发送出去 </p>
</li>
<li><p>交给 Socket 去发送，还是交给 TCP 层，让 TCP 层将返回的 HTML，也分成一个个小的段，并且保证每个段都可靠到达</p>
</li>
<li><p>这些段加上 TCP 头后会交给 IP 层，然后把刚才的发送过程反向走一遍</p>
</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><ul>
<li><p>HTTP规定了新的协议名“https”，默认端口号 443</p>
</li>
<li><p>其他的什么请求 - 应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用 HTTP</p>
</li>
<li><p>HTTP 不是安全的，而且攻击者可以通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%A3%E8%81%BD">监听</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a>等手段，获取网站帐户和敏感信息等</p>
</li>
<li><p>HTTPS 在 TCP 和 HTTP 之间插入一个安全层，让 HTTP 运行在了安全的 SSL/TLS 协议上，所有经过安全层的数据都会被加密或者解密</p>
</li>
</ul>
<h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><ul>
<li>非对称加密速度太慢，所以一般实现都是，使用非对称加密加密密钥，然后使用新的密钥进行对称加密的通讯 </li>
<li>机密性由对称加密保证，完整性由摘要算法保证，身份认证和不可否认由非对称加密保证</li>
</ul>
<h2 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h2><p><img src="https://static001.geekbang.org/resource/image/77/af/77c852ff2202b2b7bb3299a96a0f4aaf.png" alt="img"></p>
<ul>
<li><p>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random</p>
</li>
<li><p>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和数字证书，而公钥正是包含在数字证书中的</p>
</li>
<li><p>在浏览器端验证了证书</p>
</li>
<li><p>浏览器生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据</p>
</li>
<li><p>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息</p>
</li>
<li><p>服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥</p>
</li>
<li><p>有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了</p>
</li>
</ul>
<h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><ul>
<li><p>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化</p>
</li>
<li><p>SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层）</p>
</li>
<li><p>目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1/1.0、SSLv3/v2）都已经被认为是不安全的</p>
</li>
<li><p>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术</p>
</li>
<li><p>浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）</p>
<ul>
<li>ECDHE-RSA-AES256-GCM-SHA384</li>
<li>其实 TLS 的密码套件命名非常规范，格式很固定，基本的形式是“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”</li>
<li>“握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数</li>
</ul>
</li>
<li><p>OpenSSL，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能</p>
</li>
</ul>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><ul>
<li><p>本地证书是用来做双向认证的，服务器用客户端的证书来验证客户端的证书</p>
</li>
<li><p>通常我们上网是单向认证，只验证服务器的身份，客户端（也就是用户）的身份不用证书验证</p>
</li>
</ul>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><h3 id="数字证书申请"><a href="#数字证书申请" class="headerlink" title="数字证书申请 "></a>数字证书申请 <img src="https://static001.geekbang.org/resource/image/f5/a6/f569c80f8f4b25b3bf384037813cdca6.png" alt="img"></h3><h3 id="浏览器验证证书"><a href="#浏览器验证证书" class="headerlink" title="浏览器验证证书"></a>浏览器验证证书</h3><ul>
<li><p>浏览器需要验证证书的有效期、证书是否被 CA 吊销、证书是否是合法的 CA 机构颁发的 </p>
</li>
<li><p>验证极客时间的数字证书是否是 CA 机构颁发的</p>
<p><img src="https://static001.geekbang.org/resource/image/ae/08/ae7dbe9f8785441721deb1f7b316f708.png" alt="img"> </p>
</li>
<li><p>浏览器是怎么获取到 CA 公钥</p>
<ul>
<li>部署 HTTP 服务器的时候，除了部署当前的数字证书之外，还需要部署 CA 机构的数字证书，CA 机构的数字证书包括了 CA 的公钥，以及 CA 机构的一些基础信息</li>
<li>然后在建立 HTTPS 链接时，服务器会将这两个证书一同发送给浏览器，于是浏览器就可以获取到 CA 的公钥了</li>
</ul>
</li>
<li><p>证明 CA 的合法性，妥协的方案是，直接在操作系统中内置这些 CA 机构的数字证书</p>
</li>
<li><p>CA 机构众多，因此操作系统不可能将每家 CA 的数字证书都内置进操作系统</p>
</li>
<li><p>数字证书链</p>
<ul>
<li>就要了解我们的CA机构也是分两种类型的，中间CA(Intermediates CAs)和根CA(Root CAs)，通常申请者都是向中间CA去申请证书的，而根CA作用就是给中间CA做认证，通常，一个根CA会认证很多中间的CA，而这些中间CA又可以去认证其它的中间CA</li>
<li>浏览器的做法很简单，它会查找系统的根证书，如果这个根证书在操作系统里面，那么浏览器就认为这个根证书是合法的，如果验证的根证书不在操作系统里面，那么就是不合法的</li>
<li>而操作系统里面这些内置的根证书也不是随便内置的，这些根CA都是通过WebTrust国际安全审计认证</li>
</ul>
</li>
<li><p>流程</p>
<ul>
<li>首先 CA 使用 Hash 函数来计算极客时间提交的明文信息，并得出信息摘要</li>
<li>然后 CA 再使用它的私钥对信息摘要进行加密，加密后的密文就是 CA 颁给极客时间的数字签名</li>
<li>浏览器接收到数字证书之后，会对数字证书进行验证<ul>
<li>首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A</li>
<li>然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B</li>
<li>对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的</li>
<li>同时浏览器还会验证证书相关的域名信息、有效时间等信息</li>
</ul>
</li>
</ul>
</li>
<li><p>内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书</p>
</li>
<li><p>这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性</p>
</li>
<li><p>通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法</p>
</li>
</ul>
<p>## WebSocket</p>
<p>* “WebSocket”是一种基于 TCP 的轻量级网络通信协议，在地位上是与 HTTP“平级”的</p>
<p>* 是为了解决 HTTP “请求 - 应答”通信模式的缺陷而诞生的，因为这种“半双工”的通信模式，虽然可以双向收发数据，但同一时刻只能一个方向上有动作，传输效率低。更关键的一点，它是一种“被动”通信模式，服务器只能“被动”响应客户端的请求，无法主动向客户端发送数据</p>
<p>* 通常是通过轮询也就是不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果，反复发送无效查询请求耗费了大量的带宽和 CPU 资源</p>
<p>* 这就导致 HTTP 难以应用在动态页面、即时消息、网络游戏等要求“实时通信”的领域</p>
<p>* WebSocket 是一个真正“全双工”的通信协议，与 TCP 一样，客户端和服务器都可以随时向对方发送数据，一旦后台有新的数据，就可以立即“推送”给客户端，不需要客户端轮询，“实时通信”的效率也就提高了</p>
<p>* 服务发现方面，WebSocket 延用了 HTTP 的 URI 格式，引入“ws”和“wss”，分别表示明文和加密的 WebSocket 协议</p>
<p>* WebSocket 的默认端口也选择了 80 和 443</p>
<p>* WebSocket 采用了二进制帧结构长度不固定，最少 2 个字节，最多 14 字节</p>
<p>* WebSocket 的帧头就四个部分：“结束标志位 + 操作码 + 帧长度 + 掩码</p>
<p>* WebSocket 也要有一个握手过程，然后才能正式收发数据</p>
<p> * 利用了 HTTP 本身的“协议升级”特性，“伪装”成 HTTP，这样就能绕过浏览器沙盒、网络防火墙等等限制</p>
<p> * WebSocket 的握手是一个标准的 HTTP GET 请求，但要带上两个协议升级的专用头字段，为了防止普通的 HTTP 消息被“意外”识别成 WebSocket，握手消息还增加了两个额外的认证用头字段</p>
<p>  * “Connection: Upgrade”，表示要求协议“升级”；</p>
<p>  * “Upgrade: websocket”，表示要“升级”成 WebSocket 协议</p>
<p>  * Sec-WebSocket-Key：一个 Base64 编码的 16 字节随机数，作为简单的认证密钥</p>
<p>  * Sec-WebSocket-Version：协议的版本号，当前必须是 13</p>
<p>* 服务器收到 HTTP 请求报文，看到上面的四个字段，就知道这不是一个普通的 GET 请求，而是 WebSocket 的升级请求，于是就不走普通的 HTTP 处理流程，而是构造一个特殊的“101 Switching Protocols”响应报文，通知客户端，接下来就不用 HTTP 了，全改用 WebSocket 协议通信</p>
<p> * 响应报文也是有特殊格式的，要用字段“Sec-WebSocket-Accept”验证客户端请求报文，同样也是为了防止误连接</p>
<p>* 使用场景</p>
<p> * IM通信，实时互动，回调响应，数据实时同步</p>
<p>## Web 安全</p>
<p>### XSS 漏洞</p>
<p>* 通过 XSS 漏洞，黑客可以在 Web 应用中嵌入自己的 JavaScript 脚本，从而篡改 Web 应用在用户浏览器上的行为</p>
<p>* 通过 XSS，黑客一方面可以模拟用户，直接在 Web 应用中进行发博关注等互动行为</p>
<p>* 另一方面，也可以通过 JavaScript 脚本，窃取到用户的 Cookie 信息。窃取到 Cookie 之后，黑客就能够在不知道密码的情况下，绕过登录认证环节，直接获得用户身份。</p>
<p><img src="https://static001.geekbang.org/resource/image/7d/f5/7d77973b1623717cd519b0d3f8b7d4f5.jpg" alt="img"> </p>
<p>### SQL 注入漏洞</p>
<p>* 通过 SQL 注入漏洞，黑客可以利用所谓的“万能密码”，直接对登录环节进行破解。通过“万能密码”，黑客可以将原本的登录认证 SQL 语句进行篡改，使其变成一个恒为真的表达式，让应用误以为黑客输入的是正确的用户名和密码。这样，黑客就能破解登录认证环节，直接获得用户身份。</p>
<p><img src="https://static001.geekbang.org/resource/image/dc/28/dca53475b9ec945b9bd3dd30f37b6328.jpg" alt="img"> </p>
<p>* ### CSRF 漏洞</p>
<p>* 最后一个是 CSRF 漏洞。通过 CSRF 漏洞，黑客能够直接对用户的浏览器进行控制。当黑客在自己的网页中，向其他网页发起跨域请求的时候，浏览器会自动带上对应网页的 Cookie 等信息。因此只要用户之前进行过认证，并且已经将登录凭证保存在浏览器中，黑客就能以用户的身份发起未授权的操作请求。</p>
<p><img src="https://static001.geekbang.org/resource/image/5c/70/5c0e68d5766befd701ab3f3fae3eea70.jpg" alt="img"> </p>
<h1 id="Domain-Name-System-DNS"><a href="#Domain-Name-System-DNS" class="headerlink" title="Domain Name System, DNS"></a>Domain Name System, DNS</h1><h2 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h2><ul>
<li>将主机名到IP地址转换的目录服务</li>
<li>DNS 服务器，一定要设置成高可用、高并发和分布式的<ul>
<li>每个人上网，都需要访问它，一旦它出了故障，整个互联网都将瘫痪</li>
<li>另外，上网的人分布在全世界各地，如果大家都去同一个地方访问某一台服务器，时延将会非常大</li>
</ul>
</li>
<li>因此 DNS 服务器是树状的层次结构<ul>
<li>根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址</li>
<li>顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址</li>
<li>权威 DNS 服务器 ：返回相应主机的 IP 地址</li>
</ul>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/89/4d/890ff98fde625c6a60fb71yy22d8184d.jpg" alt="img"></p>
<h2 id="DNS-解析流程"><a href="#DNS-解析流程" class="headerlink" title="DNS 解析流程"></a>DNS 解析流程</h2><p><img src="https://static001.geekbang.org/resource/image/71/e8/718e3a1a1a7927302b6a0f836409e8e8.jpg" alt="img"></p>
<ul>
<li>为了提高 DNS 的解析性能，很多网络都会就近部署 DNS 缓存服务器</li>
<li>电脑客户端会发出一个 DNS 请求，问 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 的 IP 是啥啊，并发给本地域名服务器 (本地 DNS)<ul>
<li>那本地域名服务器 (本地 DNS) 是什么呢？如果是通过 DHCP 配置，本地 DNS 由你的网络服务商（ISP），如电信、移动等自动分配，它通常就在你网络服务商的某个机房</li>
<li>本地 DNS 收到来自客户端的请求</li>
<li>可以想象这台服务器上缓存了一张域名与之对应 IP 地址的大表格</li>
<li>如果能找到 <a target="_blank" rel="noopener" href="http://www.163.com,它就直接返回/">www.163.com，它就直接返回</a> IP 地址</li>
</ul>
</li>
<li>如果没有，本地 DNS 会去问它的根域名服务器：“老大，能告诉我 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 的 IP 地址吗？”<ul>
<li>根域名服务器是最高层次的，全球共有 13 套</li>
<li>它不直接用于域名解析，它发现请求的后缀是 .com，返回相应的顶级域名服务器的地址”</li>
</ul>
</li>
<li>本地 DNS 转向问顶级域名服务器：“老二，你能告诉我 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 的 IP 地址吗？”<ul>
<li>顶级域名服务器就是大名鼎鼎的比如 .com、.net、 .org 这些一级域名，它负责管理二级域名，比如 163.com</li>
<li>顶级域名服务器说：“我给你负责 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到。”</li>
</ul>
</li>
<li>本地 DNS 转向问权威 DNS 服务器：“您好，<a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 对应的 IP 是啥呀？”<ul>
<li>163.com 的权威 DNS 服务器，它是域名解析结果的原出处</li>
<li>为啥叫权威呢？就是我的域名我做主</li>
<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS</li>
</ul>
</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接</li>
</ul>
<h1 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h1><ul>
<li><p>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序</p>
</li>
<li><p>字节序分为两类：Big-Endian 和 Little-Endian</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/663581/1602998743124-f28edbdb-e49f-4648-837f-b8880e11f5c8.png" alt="img"></p>
</li>
</ul>
<ul>
<li>Little-Endian<ul>
<li>就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端</li>
</ul>
</li>
<li>Big-Endian<ul>
<li>就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</li>
</ul>
</li>
<li>网络字节序<ul>
<li>TCP/IP各层协议将字节序定义为 Big-Endian（这与主机序相反），因此TCP/IP协议中使用的字节序通常称之为网络字节序</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Interview/" rel="tag"># Interview</a>
              <a href="/tags/Internet/" rel="tag"># Internet</a>
              <a href="/tags/Basic-Knowledge/" rel="tag"># Basic Knowledge</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/06/12/RPC-%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/" rel="prev" title="RPC 远程过程调用">
                  <i class="fa fa-chevron-left"></i> RPC 远程过程调用
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/06/28/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" rel="next" title="服务发现">
                  服务发现 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lsinger</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
