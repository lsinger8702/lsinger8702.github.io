<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script><script src="/js/config.js"></script>
<meta name="description" content="定义 Apache Kafka 是一款开源的消息引擎系统 消息引擎系统是一组规范。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递  术语 Kafka 属于分布式的消息引擎系统，它的主要功能是提供一套完备的消息发布与订阅解决方案 在 Kafka 中，发布订阅的对象是主题（Topic），你可以为每个业务、每个应用甚至是每类数据都创建专属的主题 向主题发布消息的客户端应用程">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka 重要概念">
<meta property="og:url" content="http://yoursite.com/2021/06/02/Kafka-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/index.html">
<meta property="og:site_name" content="Lsinger&#39; s blog">
<meta property="og:description" content="定义 Apache Kafka 是一款开源的消息引擎系统 消息引擎系统是一组规范。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递  术语 Kafka 属于分布式的消息引擎系统，它的主要功能是提供一套完备的消息发布与订阅解决方案 在 Kafka 中，发布订阅的对象是主题（Topic），你可以为每个业务、每个应用甚至是每类数据都创建专属的主题 向主题发布消息的客户端应用程">
<meta property="og:locale">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/3c/8b/3c281189cfb1d87173bc2d4b8149f38b.jpeg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/a9/72/a97eb0e0ee2b97abaf2762b6e79d5b72.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/86/e7/86a44073aa60ac33e0833e6a9bfd9ae7.jpeg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/65/ee/6593f66902b337ec666551fe2c6f5bee.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/bf/a1/bf80b6f858d5cb49f600a28f853e89a1.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/0a/77/0afb2003d8aebaee763d22dda691ca77.jpg">
<meta property="article:published_time" content="2021-06-02T14:34:29.000Z">
<meta property="article:modified_time" content="2021-06-05T11:38:17.664Z">
<meta property="article:author" content="Lsinger">
<meta property="article:tag" content="Interview">
<meta property="article:tag" content="Kafka">
<meta property="article:tag" content="Message Queue">
<meta property="article:tag" content="Distributed System">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/3c/8b/3c281189cfb1d87173bc2d4b8149f38b.jpeg">


<link rel="canonical" href="http://yoursite.com/2021/06/02/Kafka-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;default&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;06&#x2F;02&#x2F;Kafka-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;06&#x2F;02&#x2F;Kafka-重要概念&#x2F;&quot;,&quot;title&quot;:&quot;Kafka 重要概念&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Kafka 重要概念 | Lsinger' s blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lsinger' s blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Lsinger' s blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD"><span class="nav-number">2.</span> <span class="nav-text">术语</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%B1%82%E6%B6%88%E6%81%AF%E6%9E%B6%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">三层消息架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">高可用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">3.3.</span> <span class="nav-text">持久化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.4.</span> <span class="nav-text">消息模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B%EF%BC%88P2P%EF%BC%89"><span class="nav-number">3.4.1.</span> <span class="nav-text">点对点消息模型（P2P）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.4.2.</span> <span class="nav-text">发布 &#x2F; 订阅模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E9%A2%98%E4%B8%8E%E5%88%86%E5%8C%BA"><span class="nav-number">4.</span> <span class="nav-text">主题与分区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA"><span class="nav-number">4.1.</span> <span class="nav-text">分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5"><span class="nav-number">4.1.1.</span> <span class="nav-text">分区策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">自定义分区策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5%EF%BC%88-Round-robin-%E7%AD%96%E7%95%A5%EF%BC%89"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">轮询策略（ Round-robin 策略）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E7%AD%96%E7%95%A5%EF%BC%88Randomness-%E7%AD%96%E7%95%A5%EF%BC%89"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">随机策略（Randomness 策略）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E6%B6%88%E6%81%AF%E5%BB%BA%E4%BF%9D%E5%BA%8F%E7%AD%96%E7%95%A5"><span class="nav-number">4.1.1.4.</span> <span class="nav-text">按消息建保序策略</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-number">5.</span> <span class="nav-text">生产者</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">基本架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.1.1.</span> <span class="nav-text">主线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sender-%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.1.2.</span> <span class="nav-text">Sender 线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%B4%AF%E5%8A%A0%E5%99%A8-RecordAccumulator"><span class="nav-number">5.1.3.</span> <span class="nav-text">消息累加器 RecordAccumulator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF"><span class="nav-number">5.2.</span> <span class="nav-text">消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84"><span class="nav-number">5.2.1.</span> <span class="nav-text">消息结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="nav-number">5.2.2.</span> <span class="nav-text">消息发送</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E5%90%8E%E5%8D%B3%E5%BF%98"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">发后即忘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">异步</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Broker"><span class="nav-number">6.</span> <span class="nav-text">Broker</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB"><span class="nav-number">6.1.</span> <span class="nav-text">读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99"><span class="nav-number">6.2.</span> <span class="nav-text">写</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">7.</span> <span class="nav-text">消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84-Consumer-Group"><span class="nav-number">7.1.</span> <span class="nav-text">消费者组 Consumer Group</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%AA%E6%95%B0"><span class="nav-number">7.1.1.</span> <span class="nav-text">消费者个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%A7%BB"><span class="nav-number">7.1.2.</span> <span class="nav-text">消费位移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">7.1.3.</span> <span class="nav-text">消费者组状态机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Consumer-%E7%AB%AF%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">Consumer 端相关参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E5%B9%B3%E8%A1%A1"><span class="nav-number">8.</span> <span class="nav-text">重平衡</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">8.1.</span> <span class="nav-text">触发条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%8A%E7%AB%AF"><span class="nav-number">8.2.</span> <span class="nav-text">弊端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E5%B9%B3%E8%A1%A1"><span class="nav-number">8.3.</span> <span class="nav-text">如何避免重平衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B"><span class="nav-number">8.4.</span> <span class="nav-text">流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%AB%AF"><span class="nav-number">8.4.1.</span> <span class="nav-text">消费者端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Broker-%E7%AB%AF"><span class="nav-number">8.4.2.</span> <span class="nav-text">Broker 端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E7%A7%BB%E4%B8%BB%E9%A2%98"><span class="nav-number">8.4.3.</span> <span class="nav-text">位移主题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="nav-number">9.</span> <span class="nav-text">消息丢失</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B"><span class="nav-number">9.1.</span> <span class="nav-text">检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E4%BC%A0%E9%80%92"><span class="nav-number">9.2.</span> <span class="nav-text">确保消息可靠传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E9%98%B6%E6%AE%B5"><span class="nav-number">9.2.1.</span> <span class="nav-text">生产阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E9%98%B6%E6%AE%B5"><span class="nav-number">9.2.2.</span> <span class="nav-text">存储阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E9%98%B6%E6%AE%B5"><span class="nav-number">9.2.3.</span> <span class="nav-text">消费阶段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="nav-number">10.</span> <span class="nav-text">重复消费</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E8%BE%93%E4%BF%9D%E9%9A%9C"><span class="nav-number">10.1.</span> <span class="nav-text">消息传输保障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%82%E7%AD%89%E6%80%A7"><span class="nav-number">10.2.</span> <span class="nav-text">幂等性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E5%B9%82%E7%AD%89%E6%80%A7"><span class="nav-number">10.2.1.</span> <span class="nav-text">Kafka 幂等性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E5%B9%82%E7%AD%89%E6%80%A7"><span class="nav-number">10.2.2.</span> <span class="nav-text">消费端幂等性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%B9%B6%E6%A3%80%E6%9F%A5"><span class="nav-number">10.2.2.1.</span> <span class="nav-text">记录并检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F"><span class="nav-number">10.2.2.2.</span> <span class="nav-text">利用数据库的唯一约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6"><span class="nav-number">10.2.2.3.</span> <span class="nav-text">为更新数据设置前置条件</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD-%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">11.</span> <span class="nav-text">高性能&#x2F;高吞吐量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99"><span class="nav-number">11.1.</span> <span class="nav-text">磁盘顺序读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">11.2.</span> <span class="nav-text">零拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E6%9C%BA%E5%88%B6"><span class="nav-number">11.3.</span> <span class="nav-text">分区机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81"><span class="nav-number">11.4.</span> <span class="nav-text">批量发送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="nav-number">11.5.</span> <span class="nav-text">数据压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9"><span class="nav-number">11.5.1.</span> <span class="nav-text">解压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="nav-number">11.5.2.</span> <span class="nav-text">压缩算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8-1"><span class="nav-number">12.</span> <span class="nav-text">高可用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6"><span class="nav-number">12.1.</span> <span class="nav-text">副本机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="nav-number">13.</span> <span class="nav-text">事务消息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94"><span class="nav-number">14.</span> <span class="nav-text">消息队列对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">15.</span> <span class="nav-text">常见面试题</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lsinger</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/02/Kafka-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kafka 重要概念
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-02 22:34:29" itemprop="dateCreated datePublished" datetime="2021-06-02T22:34:29+08:00">2021-06-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-05 19:38:17" itemprop="dateModified" datetime="2021-06-05T19:38:17+08:00">2021-06-05</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Message-Queue/" itemprop="url" rel="index"><span itemprop="name">Message Queue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul>
<li>Apache Kafka 是一款开源的消息引擎系统</li>
<li>消息引擎系统是一组规范。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递</li>
</ul>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><ul>
<li>Kafka 属于分布式的消息引擎系统，它的主要功能是提供一套完备的消息发布与订阅解决方案</li>
<li>在 Kafka 中，发布订阅的对象是主题（Topic），你可以为每个业务、每个应用甚至是每类数据都创建专属的主题</li>
<li>向主题发布消息的客户端应用程序称为生产者（Producer），生产者程序通常持续不断地向一个或多个主题发送消息</li>
<li>订阅这些主题消息的客户端应用程序就被称为消费者（Consumer），消费者也能够同时订阅多个主题的消息</li>
<li>生产者和消费者统称为客户端（Clients）</li>
<li>可以同时运行多个生产者和消费者实例，这些实例会不断地向 Kafka 集群中的多个主题生产和消费消息</li>
<li>Kafka 的服务器端由被称为 Broker 的服务进程构成，即一个 Kafka 集群由多个 Broker 组成，Broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化</li>
<li>每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上，这个字段就是消费者位移（Consumer Offset），每个消费者有着自己的消费者位移</li>
<li>消息在分区中的位移称为分区位移，而把消费者端的位移称为消费者位移</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="三层消息架构"><a href="#三层消息架构" class="headerlink" title="三层消息架构"></a>三层消息架构</h2><ul>
<li>第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本</li>
<li>第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用</li>
<li>第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增</li>
</ul>
<span id="more"></span>

<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><ul>
<li>虽然多个 Broker 进程能够运行在同一台机器上，但更常见的做法是将不同的 Broker 分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面运行的所有 Broker 进程都挂掉了，其他机器上的 Broker 也依然能够对外提供服务</li>
<li>备份机制（Replication）<ul>
<li>把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在 Kafka 中被称为副本（Replica）</li>
<li>副本的数量是可以配置的，Kafka 定义了两类副本<ul>
<li>领导者副本（Leader Replica）<ul>
<li>对外提供服务，这里的对外指的是与客户端程序进行交互</li>
</ul>
</li>
<li>追随者副本（Follower Replica）<ul>
<li>只是被动地追随领导者副本而已，不能与外界进行交互</li>
</ul>
</li>
</ul>
</li>
<li>生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息</li>
<li>追随者副本只负责向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步</li>
<li>副本机制可以保证数据的持久化或消息不丢失，但没有解决伸缩性的问题</li>
</ul>
</li>
<li>分区机制<ul>
<li>倘若领导者副本积累了太多的数据以至于单台 Broker 机器都无法容纳了，能否把数据分割成多份保存在不同的 Broker 上</li>
<li>Kafka 中的分区机制指的是将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中</li>
<li>每个分区下可以配置若干个副本，其中只能有 1 个领导者副本和 N-1 个追随者副本</li>
</ul>
</li>
</ul>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ul>
<li>Kafka 使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件<ul>
<li>因为只能追加写入，故避免了缓慢的随机 I/O 操作，改为性能较好的顺序 I/O 写操作，这也是实现 Kafka 高吞吐量特性的一个重要手段</li>
</ul>
</li>
<li>如果你不停地向一个日志写入消息，最终也会耗尽所有的磁盘空间，因此 Kafka 必然要定期地删除消息以回收磁盘。<ul>
<li>通过日志段（Log Segment）机制</li>
<li>在 Kafka 底层，一个日志又进一步细分成多个日志段，消息被追加写到当前最新的日志段中</li>
<li>当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来</li>
<li>Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的</li>
</ul>
</li>
</ul>
<h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><ul>
<li>使用纯二进制的字节序列传输消息</li>
<li>Kafka 同时支持点对点消息和发布 / 订阅两种消息引擎模型</li>
<li>Kafka 的 Consumer Group 完美地规避了两种模型伸缩性差的问题，却同时实现了传统消息引擎系统的两大模型<ul>
<li>如果所有实例都属于同一个 Group，那么它实现的就是消息队列模型</li>
<li>如果所有实例分别属于不同的 Group，那么它实现的就是发布 / 订阅模型</li>
</ul>
</li>
</ul>
<h3 id="点对点消息模型（P2P）"><a href="#点对点消息模型（P2P）" class="headerlink" title="点对点消息模型（P2P）"></a>点对点消息模型（P2P）</h3><ul>
<li>点对点模型也叫消息队列模型，那么系统 A 发送的消息只能被系统 B 接收，其他任何系统都不能读取 A 发送的消息</li>
<li>在 Kafka 中实现这种 P2P 模型的方法就是引入了消费者组（Consumer Group）<ul>
<li>消费者组指的是多个消费者实例共同组成一个组来消费一组主题</li>
<li>这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它</li>
<li>主要是为了提升消费者端的吞吐量，多个消费者实例同时消费，加速整个消费端的吞吐量（TPS）</li>
</ul>
</li>
<li>“重平衡”（Rebalance）<ul>
<li>消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，而且更酷的是它们还能彼此协助</li>
<li>假设组内某个实例挂掉了，Kafka 能够自动检测到，然后把这个 Failed 实例之前负责的分区转移给其他活着的消费者</li>
</ul>
</li>
</ul>
<h3 id="发布-订阅模型"><a href="#发布-订阅模型" class="headerlink" title="发布 / 订阅模型"></a>发布 / 订阅模型</h3><ul>
<li>有一个主题（Topic）的概念，你</li>
<li>发送方也称为发布者（Publisher）</li>
<li>可能存在多个发布者向相同的主题发送消息</li>
<li>订阅者也可能存在多个，它们都能接收到相同主题的消息</li>
</ul>
<h1 id="主题与分区"><a href="#主题与分区" class="headerlink" title="主题与分区"></a>主题与分区</h1><ul>
<li>倘若领导者副本积累了太多的数据以至于单台 Broker 机器都无法容纳了，能否把数据分割成多份保存在不同的 Broker 上</li>
<li>Kafka 中的分区机制指的是将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中</li>
<li>每个分区下可以配置若干个副本，其中只能有 1 个领导者副本和 N-1 个追随者副本</li>
</ul>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><ul>
<li>Kafka 默认分区策略实际上同时实现了两种策略<ul>
<li>指定了 Key，那么默认实现按消息键保序策略</li>
<li>没有指定 Key，则使用轮询策略</li>
</ul>
</li>
</ul>
<h4 id="自定义分区策略"><a href="#自定义分区策略" class="headerlink" title="自定义分区策略"></a>自定义分区策略</h4><ul>
<li>需要显式地配置生产者端的参数partitioner.class，为你自己实现类的 Full Qualified Name</li>
<li>在编写生产者程序时，你可以编写一个具体的类实现org.apache.kafka.clients.producer.Partitioner接口<ul>
<li>只定义了两个方法：partition()和close()</li>
<li>通常你只需要实现最重要的 partition 方法</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster);</span><br></pre></td></tr></table></figure>

<h4 id="轮询策略（-Round-robin-策略）"><a href="#轮询策略（-Round-robin-策略）" class="headerlink" title="轮询策略（ Round-robin 策略）"></a>轮询策略（ Round-robin 策略）</h4><ul>
<li>顺序分配</li>
<li>轮询策略是 Kafka Java 生产者 API 默认提供的分区策略</li>
<li>轮询策略有非常优秀的负载均衡表现，它总是能保证消息最大限度地被平均分配到所有分区上</li>
</ul>
<h4 id="随机策略（Randomness-策略）"><a href="#随机策略（Randomness-策略）" class="headerlink" title="随机策略（Randomness 策略）"></a>随机策略（Randomness 策略）</h4><ul>
<li>随意地将消息放置到任意一个分区上</li>
<li>机策略也是力求将数据均匀地打散到各个分区，但从实际表现来看，它要逊于轮询策略，所以如果追求数据的均匀分布，还是使用轮询策略比较好</li>
<li>随机策略是老版本生产者使用的分区策略，在新版本中已经改为轮询了</li>
</ul>
<h4 id="按消息建保序策略"><a href="#按消息建保序策略" class="headerlink" title="按消息建保序策略"></a>按消息建保序策略</h4><ul>
<li>Kafka 允许为每条消息定义消息键，简称为 Key</li>
<li>它可以是一个有着明确业务含义的字符串，也可以用来表征消息元数据</li>
<li>一旦消息被定义了 Key，那么可以保证同一个 Key 的所有消息都进入到相同的分区里面</li>
</ul>
<h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><ul>
<li>整个生产者客户端由两个线程协调运行</li>
</ul>
<h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><ul>
<li>由 KafkaProducer 创建消息</li>
<li>通过可能的拦截器、序列化器、分区器的作用<ul>
<li>拦截器在发送消息前做一些准备工作，比如过滤不符合要求的消息，修改消息的内容等，统计工作</li>
<li>序列化器把对象转换成字节数组</li>
<li>分区器根据分区分配策略对消息分区</li>
</ul>
</li>
<li>缓存到消息累加器</li>
</ul>
<h3 id="Sender-线程"><a href="#Sender-线程" class="headerlink" title="Sender 线程"></a>Sender 线程</h3><ul>
<li><p>从消息累加器中双端队列的头部读取消息</p>
</li>
<li><p>消息被封装成&lt;Node, Request&gt;的形式，将 Request 请求发往各个 Node</p>
</li>
<li><p>将请求交给 NetWorkClient，由 NetWorkClient 去真正发送网络请求到 Broker</p>
<ul>
<li><p>已经发送但是还没收到响应的请求缓存到 InFlightRequests</p>
<ul>
<li>由 max.in.flight.requests.per.connection 配置每个连接最多缓存的请求数量，默认 5</li>
<li>超过该数值后不能再向这个连接发送更多的请求，除非缓存中的请求收到了响应</li>
</ul>
</li>
<li><p>NetWorkClient 负责客户端与服务端的建连、发送客户端请求、接受服务端响应</p>
<ul>
<li><p>reday()方法</p>
<p>从记录收集器获取准备完毕的节点，并连接所有准备好的节点。</p>
</li>
<li><p>send()方法</p>
<p>为每个节点创建一个客户端请求，然后将请求暂时存到节点对应的 Channel（通道）中</p>
</li>
<li><p>poll()方法</p>
<p>真正轮询网络请求，发送请求给服务端节点和接受服务端的响应</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="消息累加器-RecordAccumulator"><a href="#消息累加器-RecordAccumulator" class="headerlink" title="消息累加器 RecordAccumulator"></a>消息累加器 RecordAccumulator</h3><ul>
<li>缓存<ul>
<li>用来缓存消息以便 Sender 线程可以批量发送，减少网络传输的资源消耗以提升性能</li>
<li>缓存大小可以通过生产者客户端参数 buffer.memory 配置，默认 32MB</li>
<li>如果生产者发送消息的速度超过发送到服务器的速度，会导致生产者空间不足，send() 方法调用要么阻塞，要么抛出异常，取决于 max.block.ms 的配置，默认 60 秒</li>
</ul>
</li>
<li>结构<ul>
<li>消息累加器内部为每个分区维护了一个双端队列</li>
<li>队列的内容都是 ProducerBatch，包含一个至多个 ProducerRecord，使字节更加紧凑，同时减少网络请求的次数以提升整体的吞吐量</li>
<li>消息被追加到消息累加器的某个双端队列的尾部</li>
</ul>
</li>
<li>BufferPool<ul>
<li>通过 java.io.ByteBuffer 实现消息内存的创建和释放，频繁的创建和释放比较耗费资源，因此消息累加器内部有一个BufferPool实现ByteBuffer的复用，实现缓存的高效利用</li>
<li>只针对特定大小的ByteBuffer进行管理，batch.size 参数管理</li>
</ul>
</li>
<li>一条消息流入 RecordAccumulator 时<ul>
<li>先寻找与消息分区所对应的双端队列</li>
<li>从这个双端队列尾部获取一个 ProducerBatch，查看是否可以写入这个 ProducerRecord</li>
<li>不可以则需要创建一个新的 ProducerBatch</li>
</ul>
</li>
</ul>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><h3 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic,</span></span></span><br><span class="line"><span class="params"><span class="function">                      Integer partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                      Long timestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                      K key,</span></span></span><br><span class="line"><span class="params"><span class="function">                      V value,</span></span></span><br><span class="line"><span class="params"><span class="function">                      Iterable&lt;Header&gt; headers)</span></span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">topic - The topic the record will be appended to</span></span><br><span class="line"><span class="function">partition - The partition to which the record should be sent</span></span><br><span class="line"><span class="function">timestamp - The timestamp of the record, in milliseconds since epoch. If <span class="keyword">null</span>, the producer will assign the timestamp using System.<span class="title">currentTimeMillis</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function">key - The key that will be included in the record</span></span><br><span class="line"><span class="function">value - The record contents</span></span><br><span class="line"><span class="function">headers - the headers that will be included in the record</span></span><br></pre></td></tr></table></figure>

<h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><ul>
<li>发送消息主要有三种模式</li>
</ul>
<h4 id="发后即忘"><a href="#发后即忘" class="headerlink" title="发后即忘"></a>发后即忘</h4><ul>
<li>不关心消息是否正确到达</li>
<li>会造成消息丢失，性能最高，可靠性最低</li>
</ul>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul>
<li>利用返回的 Future 对象实现，调用 get() 方法阻塞等待 Kafka 的响应知道发送成功或者异常</li>
<li>内部是 RecordMetadata 对象，包含消息主题、分区号、分区中的偏移量、时间戳等</li>
<li>可靠性高，但性能差</li>
</ul>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul>
<li>send() 方法指定一个 Callback 的回调函数，返回响应时会调用该函数实现异步的消息确认</li>
</ul>
<h1 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h1><h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><h2 id="消费者组-Consumer-Group"><a href="#消费者组-Consumer-Group" class="headerlink" title="消费者组 Consumer Group"></a>消费者组 Consumer Group</h2><ul>
<li>Consumer Group 是 Kafka 提供的可扩展且具有容错性的消费者机制<ul>
<li>Consumer Group 下可以有一个或多个 Consumer 实例<ul>
<li>这里的实例可以是一个单独的进程，也可以是同一进程下的线程</li>
<li>在实际场景中，使用进程更为常见一些</li>
</ul>
</li>
<li>Group ID 是一个字符串，在一个 Kafka 集群中，它标识唯一的一个 Consumer Group</li>
<li>Consumer Group 下所有实例订阅的主题的单个分区<ul>
<li>只能分配给组内的某个 Consumer 实例消费</li>
<li>也可以被其他的 Group 消费</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="消费者个数"><a href="#消费者个数" class="headerlink" title="消费者个数"></a>消费者个数</h3><ul>
<li>理想情况下，Consumer 实例的数量应该等于该 Group 订阅主题的分区总数</li>
<li>小于分区个数<ul>
<li>如果你有 3 个实例，那么平均下来每个实例大约消费 2 个分区（6 / 3 = 2）</li>
</ul>
</li>
<li>大于分区个数<ul>
<li>如果你设置了 8 个实例，那么很遗憾，有 2 个实例（8 – 6 = 2）将不会被分配任何分区，它们永远处于空闲状态</li>
</ul>
</li>
</ul>
<h3 id="消费位移"><a href="#消费位移" class="headerlink" title="消费位移"></a>消费位移</h3><ul>
<li>消费者在消费的过程中需要记录自己消费了多少数据，即消费位置信息</li>
<li>对于 Consumer Group 而言，它是一组 KV 对，Key 是分区，V 对应 Consumer 消费该分区的最新位移</li>
<li>存储<ul>
<li>老版本的 Consumer Group 把位移保存在 ZooKeeper 中<ul>
<li>Apache ZooKeeper 是一个分布式的协调服务框架，Kafka 重度依赖它实现各种各样的协调管理</li>
<li>ZooKeeper 这类元框架其实并不适合进行频繁的写更新，而 Consumer Group 的位移更新却是一个非常频繁的操作</li>
</ul>
</li>
<li>在新版本的 Consumer Group 中，Kafka 社区重新设计了 Consumer Group 的位移管理方式，采用了将位移保存在 Kafka 内部主题__consumer_offsets</li>
</ul>
</li>
</ul>
<h3 id="消费者组状态机"><a href="#消费者组状态机" class="headerlink" title="消费者组状态机"></a>消费者组状态机</h3><ul>
<li>五种状态</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/3c/8b/3c281189cfb1d87173bc2d4b8149f38b.jpeg" alt="img"></p>
<ul>
<li><p>状态流转</p>
<p><img src="https://static001.geekbang.org/resource/image/a9/72/a97eb0e0ee2b97abaf2762b6e79d5b72.jpg" alt="img"></p>
</li>
</ul>
<h2 id="Consumer-端相关参数"><a href="#Consumer-端相关参数" class="headerlink" title="Consumer 端相关参数"></a>Consumer 端相关参数</h2><ul>
<li>session.timeout.ms<ul>
<li>默认值是 10 秒</li>
<li>如果 Coordinator 在 10 秒之内没有收到 Group 下某 Consumer 实例的心跳，它就会认为这个 Consumer 实例已经挂了</li>
<li>同一个group 的不同consumer 设置的session.timeout.ms 的不一样，取最大的</li>
</ul>
</li>
<li>heartbeat.interval.ms Consumer <ul>
<li>允许你控制发送心跳请求频率的参数</li>
<li>这个值设置得越小，Consumer 实例发送心跳请求的频率就越高</li>
</ul>
</li>
<li>max.poll.interval.ms <ul>
<li>用于控制 Consumer 实际消费能力对 Rebalance 的影响</li>
<li>限定了 Consumer 端应用程序两次调用 poll 方法的最大时间间隔</li>
<li>默认值是 5 分钟</li>
<li>Consumer 程序如果在 5 分钟之内无法消费完 poll 方法返回的消息，那么 Consumer 会主动发起“离开组”的请求，Coordinator 也会开启新一轮 Rebalance</li>
</ul>
</li>
</ul>
<h1 id="重平衡"><a href="#重平衡" class="headerlink" title="重平衡"></a>重平衡</h1><ul>
<li>Rebalance 本质上是一种协议，规定了一个 Consumer Group 下的所有 Consumer 如何达成一致，来分配订阅 Topic 的每个分区</li>
<li>Rebalance 就是让一个 Consumer Group 下所有的 Consumer 实例就如何消费订阅主题的所有分区达成共识的过程</li>
</ul>
<h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><p>Rebalance 的触发条件有 3 个</p>
<ul>
<li>组成员数发生变更<ul>
<li>比如有新的 Consumer 实例加入组或者离开组，抑或是有 Consumer 实例崩溃被“踢出”组</li>
</ul>
</li>
<li>订阅主题数发生变更<ul>
<li>Consumer Group 可以使用正则表达式的方式订阅主题，比如 consumer.subscribe(Pattern.compile(“t.*c”))  就表明该 Group 订阅所有以字母 t 开头、字母 c 结尾的主题</li>
<li>在 Consumer Group 的运行过程中，你新创建了一个满足这样条件的主题，那么该 Group 就会发生 Rebalance</li>
</ul>
</li>
<li>订阅主题的分区数发生变更<ul>
<li>Kafka 当前只能允许增加一个主题的分区数。当分区数增加时，就会触发订阅该主题的所有 Group 开启 Rebalance</li>
</ul>
</li>
</ul>
<h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><ul>
<li>Rebalance 影响 Consumer 端 TPS<ul>
<li>在 Rebalance 过程中，所有 Consumer 实例都会停止消费，等待 Rebalance 完成</li>
</ul>
</li>
<li>Rebalance 效率不高<ul>
<li>目前 Rebalance 的设计是所有 Consumer 实例共同参与，全部重新分配所有分区</li>
<li>更高效的做法是尽量减少分配方案的变动。例如实例 A 之前负责消费分区 1、2、3，那么 Rebalance 之后，如果可能的话，最好还是让实例 A 继续消费分区 1、2、3，而不是被重新分配其他的分区。这样的话，实例 A 连接这些分区所在 Broker 的 TCP 连接就可以继续用，不用重新创建连接其他 Broker 的 Socket 资源</li>
<li>社区于 0.11.0.0 版本推出了 StickyAssignor，即有粘性的分区分配策略。所谓的有粘性，是指每次 Rebalance 时，该策略会尽可能地保留之前的分配方案，尽量实现分区分配的最小变动。不过有些遗憾的是，这个策略目前还有一些 bug，而且需要升级到 0.11.0.0 才能使用，因此在实际生产环境中用得还不是很多</li>
</ul>
</li>
<li>Rebalance 很慢，尤其是 Group 下成员很多</li>
</ul>
<h2 id="如何避免重平衡"><a href="#如何避免重平衡" class="headerlink" title="如何避免重平衡"></a>如何避免重平衡</h2><ul>
<li>订阅主题数量发生变化和订阅主题的分区数发生变化通常都是运维的主动操作，所以它们引发的 Rebalance 大都是不可避免的</li>
<li>“不必要的” Rebalance 是“不必要的”<ul>
<li>因为未能及时发送心跳，导致 Consumer 被“踢出”Group 而引发的<ul>
<li>需要仔细地设置 session.timeout.ms 和 heartbeat.interval.ms 的值</li>
<li>推荐数值<ul>
<li>session.timeout.ms = 6s</li>
<li>heartbeat.interval.ms = 2s</li>
</ul>
</li>
<li>保证 Consumer 实例在被判定为“dead”之前，能够发送至少 3 轮的心跳请求，即 session.timeout.ms &gt;= 3 * heartbeat.interval.ms</li>
<li>将 session.timeout.ms 设置成 6s 主要是为了让 Coordinator 能够更快地定位已经挂掉的 Consumer</li>
</ul>
</li>
<li>Consumer 消费时间过长导致的<ul>
<li>max.poll.interval.ms 参数值的设置显得尤为关键</li>
<li>如果要避免非预期的 Rebalance，最好将该参数值设置得大一点，比下游最大处理时间稍长一点</li>
</ul>
</li>
</ul>
</li>
<li>恰当地设置了这几个参数，却发现还是出现了 Rebalance，建议排查一下 Consumer 端的 GC 表现，比如是否出现了频繁的 Full GC 导致的长时间停顿，从而引发了 Rebalance</li>
<li>standalone consumer不会rebalance，它的特点主要是灵活。虽然社区一直在改进rebalance的性能，但大数据量下consumer group机制依然有很多弊病（比如rebalance太慢等），所以很多大数据框架(Spark /Flink)的kafka connector并不使用group机制，而是使用standalone consumer</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>Rebalance 过程中，所有 Consumer 实例共同参与，在协调者组件的帮助下，完成订阅主题分区的分配</li>
<li>在整个过程中，所有实例都不能消费任何消息，因此它对 Consumer 的 TPS 影响很大</li>
<li>协调者 Coordinator，它专门为 Consumer Group 服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等<ul>
<li>Consumer 端应用程序在提交位移时，其实是向 Coordinator 所在的 Broker 提交位移</li>
<li>Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作</li>
<li>所有 Broker 在启动时，都会创建和开启相应的 Coordinator 组件，所有 Broker 都有各自的 Coordinator 组件</li>
</ul>
</li>
<li>Kafka 为某个 Consumer Group 确定 Coordinator 所在的 Broker 的算法有 2 个步骤<ul>
<li>确定由位移主题的哪个分区来保存该 Group 数据：partitionId=Math.abs(groupId.hashCode() % offsetsTopicPartitionCount)</li>
<li>找出该分区 Leader 副本所在的 Broker，该 Broker 即为对应的 Coordinator</li>
</ul>
</li>
<li>当 Consumer Group 完成 Rebalance 之后，每个 Consumer 实例都会定期地向 Coordinator 发送心跳请求，表明它还存活着<ul>
<li>0.10.1之前是在调用poll方法时发送的，0.10.1之后consumer使用单独的心跳线程来发送</li>
</ul>
</li>
<li>如果某个 Consumer 实例不能及时地发送这些心跳请求，Coordinator 就会认为该 Consumer 已经“死”了，从而将其从 Group 中移除，然后开启新一轮 Rebalance</li>
<li>目前 Coordinator 通知各个 Consumer 实例开启 Rebalance 的方法，就是将 REBALANCE_NEEDED 标志封装进心跳请求的响应体中</li>
</ul>
<h3 id="消费者端"><a href="#消费者端" class="headerlink" title="消费者端"></a>消费者端</h3><ul>
<li>重平衡分为两个步骤<ul>
<li>加入组，对应JoinGroup 请求</li>
<li>等待领导者消费者（Leader Consumer）分配方案，对应JSyncGroup 请求</li>
</ul>
</li>
<li>当组内成员加入组时，它会向协调者发送 JoinGroup 请求<ul>
<li>每个成员都要将自己订阅的主题上报</li>
</ul>
</li>
<li>一旦收集了全部成员的 JoinGroup 请求后，协调者会从这些成员中选择一个担任这个消费者组的领导者<ul>
<li>通常情况下，第一个发送 JoinGroup 请求的成员自动成为领导者</li>
</ul>
</li>
<li>选出领导者之后，协调者会把消费者组订阅信息封装进 JoinGroup 请求的响应体中，然后发给领导者，由领导者统一做出分配方案后</li>
<li>领导者向协调者发送 SyncGroup 请求，将刚刚做出的分配方案发给协调者，其他成员也会向协调者发送 SyncGroup 请求</li>
<li>SyncGroup 请求让协调者把领导者制定的分配方案下发给各个组内成员</li>
<li>当所有成员都成功接收到分配方案后，消费者组进入到 Stable 状态，即开始正常的消费工作</li>
</ul>
<h3 id="Broker-端"><a href="#Broker-端" class="headerlink" title="Broker 端"></a>Broker 端</h3><ul>
<li>新成员入组<ul>
<li>当协调者收到新的 JoinGroup 请求后，它会通过心跳请求响应的方式通知组内现有的所有成员，强制它们开启新一轮的重平衡</li>
</ul>
</li>
<li>组成员主动离组<ul>
<li>消费者实例所在线程或进程调用 close() 方法主动通知协调者它要退出</li>
<li>LeaveGroup 请求。协调者收到 LeaveGroup 请求后，依然会以心跳响应的方式通知其他成员</li>
</ul>
</li>
<li>组成员崩溃离组<ul>
<li>崩溃离组是指消费者实例出现严重故障，突然宕机导致的离组</li>
<li>崩溃离组是被动的，协调者通常需要等待一段时间才能感知到，这段时间一般是由消费者端参数 session.timeout.ms 控制的</li>
<li>每次consumer发送心跳时会顺带发送session timeout时间，这样Coordinator收到后会根据这个session timeout时间计算下次deadline时间，如果过了deadline还没有收到直接fail掉该consumer</li>
</ul>
</li>
<li>重平衡时协调者对组内成员提交位移的处理<ul>
<li>正常情况下，每个组内成员都会定期汇报位移给协调者</li>
<li>当重平衡开启时，协调者会给予成员一段缓冲时间，要求每个成员必须在这段时间内快速地上报自己的位移信息，然后再开启正常的 JoinGroup/SyncGroup 请求发送</li>
</ul>
</li>
</ul>
<h3 id="位移主题"><a href="#位移主题" class="headerlink" title="位移主题"></a>位移主题</h3><ul>
<li><p>__consumer_offsets 在 Kafka 源码中有个更为正式的名字，叫位移主题</p>
</li>
<li><p>新版本 Consumer 的位移管理机制其实也很简单，就是将 Consumer 的位移数据作为一条条普通的 Kafka 消息，提交到 <strong>consumer_offsets 中</strong></p>
</li>
<li><p>consumer_offsets 的主要作用是保存 Kafka 消费者的位移信息</p>
<ul>
<li>实现高持久性，还要支持高频的写操作</li>
</ul>
</li>
<li><p>位移主题有 3 种消息格式</p>
<ul>
<li>位移主题的 Key 中应该保存 3 部分内容：&lt;Group ID，主题名，分区号 &gt;</li>
<li>用于保存 Consumer Group 信息的消息<ul>
<li>用来注册 Consumer Group </li>
</ul>
</li>
<li>用于删除 Group 过期位移甚至是删除 Group 的消息<ul>
<li>tombstone 消息，即墓碑消息，也称 delete mark</li>
<li>主要特点是它的消息体是 null，即空消息体</li>
<li>一旦某个 Consumer Group 下的所有 Consumer 实例都停止了，而且它们的位移数据都已被删除时，Kafka 会向位移主题的对应分区写入 tombstone 消息，表明要彻底删除这个 Group 的信息</li>
</ul>
</li>
</ul>
</li>
<li><p>创建</p>
<ul>
<li>自动创建<ul>
<li>当 Kafka 集群中的第一个 Consumer 程序启动时，Kafka 会自动创建位移主题</li>
<li>该主题的分区数是 50，副本数是 3<ul>
<li>Broker 端参数 offsets.topic.num.partitions ，默认值是 50</li>
<li>Broker 端参数 offsets.topic.replication.factor ，默认值是 3</li>
</ul>
</li>
</ul>
</li>
<li>手动创建位移主题<ul>
<li>在 Kafka 集群尚未启动任何 Consumer 之前，使用 Kafka API 创建它</li>
</ul>
</li>
</ul>
</li>
<li><p>Kafka Consumer 提交位移的方式有两种</p>
<ul>
<li>Consumer 端有个参数叫 enable.auto.commit</li>
<li>自动提交位移<ul>
<li>Consumer 在后台默默地为你定期提交位移</li>
<li>提交间隔由一个专属的参数 auto.commit.interval.ms 来控制</li>
</ul>
</li>
<li>手动提交位移</li>
</ul>
</li>
<li><p>过期位移清除</p>
<ul>
<li><p>Kafka 只需要位移消息中的最新一条就可以了，之前的消息都是可以删除的，Kafka 必须要有针对位移主题消息特点的消息删除策略</p>
</li>
<li><p>Kafka 定期自动删除过期位移的条件就是，组要处于 Empty 状态。因此，如果你的消费者组停掉了很长时间（超过 7 天），那么 Kafka 很可能就把该组的位移数据删除了</p>
</li>
<li><p>Kafka 使用 Compact 策略来删除位移主题中的过期消息，避免该主题无限期膨胀</p>
</li>
<li><p>对于同一个 Key 的两条消息 M1 和 M2，如果 M1 的发送时间早于 M2，那么 M1 就是过期消息</p>
</li>
<li><p>Compact 的过程就是扫描日志的所有消息，剔除那些过期的消息，然后把剩下的消息整理在一起</p>
</li>
<li><p>Kafka 提供了专门的后台线程定期地巡检待 Compact 的主题，看看是否存在满足条件的可删除数据</p>
<ul>
<li>这个后台线程叫 Log Cleaner</li>
<li>很多实际生产环境中都出现过位移主题无限膨胀占用过多磁盘空间的问题，如果你的环境中也有这个问题，我建议你去检查一下 Log Cleaner 线程的状态，通常都是这个线程挂掉了导致的</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/86/e7/86a44073aa60ac33e0833e6a9bfd9ae7.jpeg" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h1 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h1><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><ul>
<li>我们可以利用消息队列的有序性来验证是否有消息丢失</li>
<li>在 Producer 端，我们给每个发出的消息附加一个连续递增的序号，然后在 Consumer 端来检查这个序号的连续性<ul>
<li>如果没有消息丢失，Consumer 收到消息的序号必然是连续递增的，或者说收到的消息，其中的序号必然是上一条消息的序号 +1</li>
<li>如果检测到序号不连续，那就是丢消息了</li>
<li>还可以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因</li>
</ul>
</li>
<li>Kafka 和 RocketMQ 这样的消息队列，它是不保证在 Topic 上的严格顺序的，只能保证分区上的消息是有序的，我们在发消息的时候必须要指定分区，在每个分区单独检测消息序号的连续性</li>
<li>如果 Producer 是多实例的，由于并不好协调多个 Producer 之间的发送顺序，所以也需要每个 Producer 分别生成各自的消息序号，并且需要附加上 Producer 的标识，在 Consumer 端按照每个 Producer 分别来检测序号的连续性<ul>
<li>Consumer 实例的数量最好和分区数量一致，做到 Consumer 和分区一一对应，这样会比较方便地在 Consumer 内检测消息序号的连续性</li>
</ul>
</li>
</ul>
<h2 id="确保消息可靠传递"><a href="#确保消息可靠传递" class="headerlink" title="确保消息可靠传递"></a>确保消息可靠传递</h2><h3 id="生产阶段"><a href="#生产阶段" class="headerlink" title="生产阶段"></a>生产阶段</h3><ul>
<li>Broker 收到消息后，会给客户端返回一个确认响应，表明消息已经收到了，客户端收到响应后，完成了一次正常消息的发送，只要 Producer 收到了 Broker 的确认响应，就可以保证消息在生产阶段不会丢失</li>
<li>例如网络抖动，导致消息压根就没有发送到 Broker 端；或者消息本身不合格导致 Broker 拒绝接收（比如消息太大了，超过了 Broker 的承受能力）等<ul>
<li>如果是因为那些瞬时错误，那么仅仅让 Producer 重试就可以了</li>
<li>如果是消息不合格造成的，那么可以调整消息格式后再次发送</li>
<li>如果你所有的 Broker 都宕机了，那么无论 Producer 端怎么重试都会失败的，此时你要做的是赶快处理 Broker 端的问题</li>
</ul>
</li>
<li>Kafka可以配置retries参数，进行自动重试，如果重试再失败，就会以异常的方式告知用户</li>
<li>在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失<ul>
<li>同步发送时，只要注意捕获异常即可</li>
<li>异步发送时，则需要在回调方法里进行检查</li>
</ul>
</li>
</ul>
<h3 id="存储阶段"><a href="#存储阶段" class="headerlink" title="存储阶段"></a>存储阶段</h3><ul>
<li>如果对消息的可靠性要求非常高，可以通过配置 Broker 参数来避免因为宕机丢消息</li>
<li>设置 acks = all<ul>
<li>acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义</li>
<li>如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”</li>
<li>这是最高等级的“已提交”定义</li>
</ul>
</li>
<li>设置 min.insync.replicas &gt; 1<ul>
<li>这依然是 Broker 端参数，制定了ISR集合中最小的副本数</li>
<li>设置成大于 1 可以提升消息持久性</li>
<li>确保 replication.factor &gt; min.insync.replicas：如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了</li>
</ul>
</li>
<li>设置 replication.factor &gt;= 3<ul>
<li>这也是 Broker 端的参数</li>
<li>将消息多保存几份</li>
<li>防止消息丢失的主要机制就是冗余</li>
</ul>
</li>
<li>刷盘策略<ul>
<li>最高级别同步刷盘</li>
<li>默认由操作系统本身来进行处理</li>
<li>机器损耗性能，应该采用多副本机制保障</li>
</ul>
</li>
</ul>
<h3 id="消费阶段"><a href="#消费阶段" class="headerlink" title="消费阶段"></a>消费阶段</h3><ul>
<li>客户端从 Broker 拉取消息后，执行用户的消费业务逻辑<ul>
<li>成功后，才会给 Broker 发送消费确认响应</li>
<li>如果 Broker 没有收到消费确认响应，下次拉消息的时候还会返回同一条消息</li>
</ul>
</li>
<li>在编写消费代码时需要注意的是，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认</li>
<li>这种处理方式可能带来的问题是消息的重复处理</li>
<li>Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式，4如果是多线程异步处理消费消息，Consumer 程序不要开启自动提交位移，而是要应用程序手动提交位移</li>
<li>Kafka提供了回溯消费的兜底功能，可以对漏掉的消息进行回补</li>
</ul>
<h1 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h1><h2 id="消息传输保障"><a href="#消息传输保障" class="headerlink" title="消息传输保障"></a>消息传输保障</h2><ul>
<li>在 MQTT 协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是<ul>
<li>At most once 至多一次<ul>
<li>消息在传递时，最多会被送达一次</li>
<li>没什么消息可靠性保证，允许丢消息</li>
<li>绝对不会重复传输</li>
</ul>
</li>
<li>At least once 至少一次<ul>
<li>消息在传递时，至少会被送达一次</li>
<li>不允许丢消息</li>
<li>但是允许有重复消息出现</li>
</ul>
</li>
<li>Exactly once 恰好一次<ul>
<li>消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><h3 id="Kafka-幂等性"><a href="#Kafka-幂等性" class="headerlink" title="Kafka 幂等性"></a>Kafka 幂等性</h3><ul>
<li>为了实现生产者的幂等性，Kafka 引入了 producer id 和序列号的概念</li>
<li>每个新生产者实例在初始化的时候都会被分配一个 producer ID</li>
<li>对于每个PID，消息发送到每一个分区都有对应的序列号，从0开始单调递增</li>
<li>生产者每发送一条消息都会将&lt;PID, 分区&gt; 对应的序列号值+1</li>
<li>broker 端也会为每一对&lt;PID, 分区&gt; 维护一个序列号<ul>
<li>只有消息的序列号比broker端的序列号大1时，broker才会接收，否则丢弃</li>
<li>如果大于1，表明有消息丢失，出现了乱序，会抛出OutOfOrderSequenceException</li>
</ul>
</li>
<li><strong>Kafka的幂等只能保证单个生产者会话中单分区的幂等</strong></li>
</ul>
<h3 id="消费端幂等性"><a href="#消费端幂等性" class="headerlink" title="消费端幂等性"></a>消费端幂等性</h3><ul>
<li>一般解决重复消息的办法是，在消费端，让我们消费消息的操作具备幂等性</li>
<li>其任意多次执行所产生的影响均与一次执行的影响相同</li>
</ul>
<h4 id="记录并检查"><a href="#记录并检查" class="headerlink" title="记录并检查"></a>记录并检查</h4><ul>
<li>记录并检查操作，也称为“Token 机制或者 GUID（全局唯一 ID）机制”</li>
<li>在执行数据更新操作之前，先检查一下是否执行过这个更新操作。具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一的 ID，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费</li>
<li>在“检查消费状态，然后更新数据并且设置消费状态”中，三个操作必须作为一组操作保证原子性，才能真正实现幂等，否则就会出现 Bug</li>
</ul>
<h4 id="利用数据库的唯一约束"><a href="#利用数据库的唯一约束" class="headerlink" title="利用数据库的唯一约束"></a>利用数据库的唯一约束</h4><ul>
<li>只要是支持类似“INSERT IF NOT EXIST”语义的存储类系统都可以用于实现幂等，比如，你可以用 Redis 的 SETNX 命令来替代数据库中的唯一约束，来实现幂等消费</li>
</ul>
<h4 id="为更新数据设置前置条件"><a href="#为更新数据设置前置条件" class="headerlink" title="为更新数据设置前置条件"></a>为更新数据设置前置条件</h4><ul>
<li>给你的数据增加一个版本号属性，每次更数据前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号 +1，一样可以实现幂等更新</li>
</ul>
<h1 id="高性能-高吞吐量"><a href="#高性能-高吞吐量" class="headerlink" title="高性能/高吞吐量"></a>高性能/高吞吐量</h1><h2 id="磁盘顺序读写"><a href="#磁盘顺序读写" class="headerlink" title="磁盘顺序读写"></a>磁盘顺序读写</h2><ul>
<li>kafka的消息是不断追加到日志文件中的，这个特性使kafka可以充分利用磁盘的顺序读写性能</li>
<li>顺序读写不需要硬盘磁头的寻道时间，只需很少的扇区旋转时间，所以速度远快于随机读写</li>
</ul>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p><img src="https://static001.geekbang.org/resource/image/65/ee/6593f66902b337ec666551fe2c6f5bee.jpg" alt="img"></p>
<ul>
<li>Kafka 使用零拷贝技术将数据直接从磁盘文件复制到网卡设备中，不需要经过应用程序，大大提高了应用程序的性能，降低了上下文切换的频率和内存拷贝次数</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/bf/a1/bf80b6f858d5cb49f600a28f853e89a1.jpg" alt="img"></p>
<ul>
<li>如果网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术，还可以再去除 Socket 缓冲区的拷贝</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/0a/77/0afb2003d8aebaee763d22dda691ca77.jpg" alt="img"></p>
<ul>
<li>Kafka 的代码调用了 Java NIO 库，具体是 FileChannel 里面的 transferTo 方法。我们的数据并没有读到中间的应用内存里面，而是直接通过 Channel，写入到对应的网络设备里。并且，对于 Socket 的操作，也不是写入到 Socket 的 Buffer 里面，而是直接根据描述符（Descriptor）写入到网卡的缓冲区里面。</li>
<li>零拷贝技术依赖于底层的 sendFile() 方法实现</li>
<li>零拷贝还使用了 PageCache 技术，读取文件时，是先把磁盘文件拷贝到 PageCache 上<ul>
<li>由于磁盘比内存的速度慢许多，所以我们应该想办法把读写磁盘替换成读写内存（“时间局部性”原理），用 PageCache 缓存最近访问的数据，当空间不足时淘汰最久未被访问的缓存（即 LRU 算法）</li>
<li>读磁盘时优先到 PageCache 中找一找，如果数据存在便直接返回，这便大大提升了读磁盘的性能</li>
<li>PageCache 使用了预读功能</li>
</ul>
</li>
<li>两次拷贝<ul>
<li>通过 DMA，从硬盘直接读到操作系统内核的读缓冲区里面</li>
<li>根据 Socket 的描述符信息，直接从读缓冲区里面，写入到网卡的缓冲区里面</li>
</ul>
</li>
</ul>
<h2 id="分区机制"><a href="#分区机制" class="headerlink" title="分区机制"></a>分区机制</h2><ul>
<li>Kafka 中的分区机制指的是将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志</li>
<li>生产者生产的每条消息只会被发送到一个分区中</li>
<li>分区的作用就是提供负载均衡的能力，为了实现系统的高伸缩性（Scalability）</li>
<li>不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理</li>
<li>可以通过添加新的节点机器来增加整体系统的吞吐量</li>
</ul>
<h2 id="批量发送"><a href="#批量发送" class="headerlink" title="批量发送"></a>批量发送</h2><ul>
<li>kafka允许进行批量发送消息，producter发送消息的时候，可以将消息缓存在本地,等到了固定条件发送到kafka<ul>
<li>等消息条数到固定条数</li>
<li>一段时间发送一次</li>
</ul>
</li>
<li>消息累加器用来缓存消息以便 Sender 线程可以批量发送，减少网络传输的资源消耗以提升性能</li>
<li>ProducerBatch，包含一个至多个 ProducerRecord，使字节更加紧凑，同时减少网络请求的次数以提升整体的吞吐量</li>
</ul>
<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><ul>
<li>Kafka可以对消息集合进行压缩，以较小的 CPU 开销带来更少的磁盘占用或更少的网络 I/O 传输</li>
<li>Kafka 的消息层次都分为两层<ul>
<li>消息集合（message set）<ul>
<li>包含若干条日志项（record item），而日志项才是真正封装消息的地方</li>
<li>Kafka 底层的消息日志由一系列消息集合日志项组成</li>
</ul>
</li>
<li>消息（message）</li>
</ul>
</li>
<li>压缩内容<ul>
<li>V1 版本中保存压缩消息的方法是把多条消息进行压缩然后保存到外层消息的消息体字段中</li>
<li>V2 版本的做法是对整个消息集合进行压缩，有更好的压缩效果</li>
</ul>
</li>
<li>压缩可能发生在两个地方<ul>
<li>生产者端<ul>
<li>生产者程序中配置 compression.type 参数即表示启用指定类型的压缩算法</li>
</ul>
</li>
<li>Broker 端<ul>
<li>大部分情况下 Broker 从 Producer 端接收到消息后仅仅是原封不动地保存而不会对其进行任何修改，有两种例外情况就可能让 Broker 重新压缩消息<ul>
<li>Broker 端指定了和 Producer 端不同的压缩算法</li>
<li>Broker 端也有一个参数叫 compression.type，这个参数的默认值是 producer</li>
</ul>
</li>
<li>Broker 端发生了消息格式转换<ul>
<li>为了兼容老版本的格式，Broker 端会对新版本消息执行向老版本格式的转换，这个过程中会涉及消息的解压缩和重新压缩</li>
<li>一般情况下这种消息格式转换对性能是有很大影响的，它还让 Kafka 丧失了引以为豪的 Zero Copy 特性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><ul>
<li>Kafka 会将启用了哪种压缩算法封装进消息集合中</li>
<li>通常来说解压缩发生在消费者程序中</li>
<li>每个压缩过的消息集合在 Broker 端写入时都要发生解压缩操作，目的就是为了对消息执行各种验证</li>
</ul>
<h3 id="压缩算法"><a href="#压缩算法" class="headerlink" title="压缩算法"></a>压缩算法</h3><ul>
<li>Kafka 支持 3 种压缩算法<ul>
<li>GZIP</li>
<li>Snappy</li>
<li>LZ4</li>
<li>Zstandard 算法（简写为 zstd）： Facebook 开源的一个压缩算法，能够提供超高的压缩比（compression ratio）</li>
</ul>
</li>
<li>压缩算法的优劣，有两个重要的指标<ul>
<li>压缩比<ul>
<li>原先占 100 份空间的东西经压缩之后变成了占 20 份空间，那么压缩比就是 5</li>
<li>显然压缩比越高越好</li>
</ul>
</li>
<li>压缩 / 解压缩吞吐量<ul>
<li>比如每秒能压缩或解压缩多少 MB 的数据</li>
<li>吞吐量也是越高越好</li>
</ul>
</li>
</ul>
</li>
<li>比较<ul>
<li>Facebook Zstandard 官网提供的一份压缩算法 benchmark 比较结果<ul>
<li>zstd 算法有着最高的压缩比，而在吞吐量上的表现只能说中规中矩</li>
<li>LZ4 算法，它在吞吐量方面则是毫无疑问的执牛耳者</li>
</ul>
</li>
<li>对于 Kafka 而言，它们的性能测试结果却出奇得一致<ul>
<li>在吞吐量方面<ul>
<li>LZ4 &gt; Snappy &gt; zstd 和 GZIP</li>
</ul>
</li>
<li>在压缩比方面<ul>
<li>zstd &gt; LZ4 &gt; GZIP &gt; Snappy</li>
</ul>
</li>
<li>物理资源<ul>
<li>使用 Snappy 算法占用的网络带宽最多，zstd 最少</li>
<li>毕竟 zstd 就是要提供超高的压缩比</li>
</ul>
</li>
<li>在 CPU 使用率方面，各个算法表现得差不多<ul>
<li>在压缩时 Snappy 算法使用的 CPU 较多一些</li>
<li>在解压缩时 GZIP 算法则可能使用更多的 CPU</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="高可用-1"><a href="#高可用-1" class="headerlink" title="高可用"></a>高可用</h1><h2 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h2><ul>
<li>越多的的副本越能保证数据的可靠性，但是副本数多也会导致磁盘、网络带宽的浪费，同时会引起性能的下降，一般而言，设置副本数为3即可满足大多数场景对可靠性的要求</li>
<li>参数 acks<ul>
<li>0<ul>
<li>发送消息后不等服务端响应</li>
</ul>
</li>
<li>1<ul>
<li>leader副本写入后就返回客户端成功提交</li>
<li>leader宕机消息会丢失</li>
</ul>
</li>
<li>-1<ul>
<li>leader副本成功写入本地日志后还要等ISR中的follower副本全部同步完成才返回客户端成功提交</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h1><h1 id="消息队列对比"><a href="#消息队列对比" class="headerlink" title="消息队列对比"></a>消息队列对比</h1><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><ul>
<li>RabbitMQ怎么保证消息的正确性</li>
<li>rocketmq和kafka两者区别</li>
<li>事务消息实现</li>
<li>kafka 的工作原理</li>
<li>怎么保证高可用、高性能</li>
<li>分区的分配策略</li>
<li>再平衡原理</li>
<li>消息丢失</li>
<li>消息重复</li>
<li>Kafka 零拷贝</li>
<li>kafka如何保证顺序</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Interview/" rel="tag"># Interview</a>
              <a href="/tags/Kafka/" rel="tag"># Kafka</a>
              <a href="/tags/Message-Queue/" rel="tag"># Message Queue</a>
              <a href="/tags/Distributed-System/" rel="tag"># Distributed System</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/12/01/12-%E6%9C%88%E6%8C%91%E6%88%98/" rel="prev" title="12 月挑战">
                  <i class="fa fa-chevron-left"></i> 12 月挑战
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/06/05/%E6%A0%91/" rel="next" title="树">
                  树 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lsinger</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
