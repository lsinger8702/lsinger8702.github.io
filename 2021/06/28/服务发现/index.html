<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script><script src="/js/config.js"></script>
<meta name="description" content="相关组件 老派的 ZooKeeper Kubernetes 使用的 ETCD 阿里的微服务注册中心 Nacos Spring Cloud 的 Eureka 等等  背景 为了高可用，在生产环境中服务提供方都是以集群的方式对外提供服务，集群里面的这些 IP 随时可能变化，我们也需要用一本“通信录”及时获取到对应的服务节点，这个获取的过程我们一般叫作“服务发现”  对于服务调用方和服务提供方来说，其契">
<meta property="og:type" content="article">
<meta property="og:title" content="服务发现">
<meta property="og:url" content="http://yoursite.com/2021/06/28/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/index.html">
<meta property="og:site_name" content="Lsinger&#39; s blog">
<meta property="og:description" content="相关组件 老派的 ZooKeeper Kubernetes 使用的 ETCD 阿里的微服务注册中心 Nacos Spring Cloud 的 Eureka 等等  背景 为了高可用，在生产环境中服务提供方都是以集群的方式对外提供服务，集群里面的这些 IP 随时可能变化，我们也需要用一本“通信录”及时获取到对应的服务节点，这个获取的过程我们一般叫作“服务发现”  对于服务调用方和服务提供方来说，其契">
<meta property="og:locale">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/b7/68/b78964a2db3adc8080364e9cfc79ca68.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/a1/50/a15be58b32195422bd5a18dba0e68050.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/77/cc/7752081ec658f1d56ac4219f1c07fbcc.jpg">
<meta property="article:published_time" content="2021-06-28T13:08:21.000Z">
<meta property="article:modified_time" content="2022-07-17T16:44:25.434Z">
<meta property="article:author" content="Lsinger">
<meta property="article:tag" content="Interview">
<meta property="article:tag" content="High Concurrency System">
<meta property="article:tag" content="Distributed System">
<meta property="article:tag" content="Microservice Architecture">
<meta property="article:tag" content="Service Discovery">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/b7/68/b78964a2db3adc8080364e9cfc79ca68.jpg">


<link rel="canonical" href="http://yoursite.com/2021/06/28/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;default&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;06&#x2F;28&#x2F;%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;06&#x2F;28&#x2F;服务发现&#x2F;&quot;,&quot;title&quot;:&quot;服务发现&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>服务发现 | Lsinger' s blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lsinger' s blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Lsinger' s blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6"><span class="nav-number">1.</span> <span class="nav-text">相关组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">2.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%91%E6%88%98"><span class="nav-number">3.</span> <span class="nav-text">挑战</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS"><span class="nav-number">4.1.</span> <span class="nav-text">DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="nav-number">4.1.1.</span> <span class="nav-text">基本思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E9%99%B7"><span class="nav-number">4.1.2.</span> <span class="nav-text">缺陷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">4.2.</span> <span class="nav-text">负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">基本思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E9%99%B7-1"><span class="nav-number">4.2.2.</span> <span class="nav-text">缺陷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper"><span class="nav-number">4.3.</span> <span class="nav-text">ZooKeeper</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-2"><span class="nav-number">4.3.1.</span> <span class="nav-text">基本思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.3.2.</span> <span class="nav-text">基本实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E9%99%B7-2"><span class="nav-number">4.3.3.</span> <span class="nav-text">缺陷</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%8C%E6%80%A7%E8%83%BD%E6%9C%89%E9%99%90"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">强一致性，性能有限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA%E5%90%8E%EF%BC%8C%E9%80%89%E4%B8%BE%E6%97%B6%E9%97%B4%E9%95%BF%EF%BC%8C%E6%9C%8D%E5%8A%A1%E9%95%BF%E6%97%B6%E9%97%B4%E4%B8%8D%E5%8F%AF%E7%94%A8"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">主节点宕机后，选举时间长，服务长时间不可用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Eureke"><span class="nav-number">4.4.</span> <span class="nav-text">Eureke</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-3"><span class="nav-number">4.4.1.</span> <span class="nav-text">基本思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84"><span class="nav-number">4.4.2.</span> <span class="nav-text">多级缓存架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-number">4.4.3.</span> <span class="nav-text">自我保护机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nacos"><span class="nav-number">4.5.</span> <span class="nav-text">Nacos</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF"><span class="nav-number">4.6.</span> <span class="nav-text">消息总线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-4"><span class="nav-number">4.6.1.</span> <span class="nav-text">基本思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B"><span class="nav-number">4.6.1.1.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96"><span class="nav-number">4.6.1.2.</span> <span class="nav-text">优化</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%81%A5%E5%BA%B7%E6%A3%80%E6%B5%8B"><span class="nav-number">5.</span> <span class="nav-text">健康检测</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF-1"><span class="nav-number">5.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6"><span class="nav-number">5.2.</span> <span class="nav-text">组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-5"><span class="nav-number">5.3.</span> <span class="nav-text">基本思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E6%8E%A2%E6%B5%8B"><span class="nav-number">5.3.1.</span> <span class="nav-text">主动探测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%B6%B3"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">不足</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%83%E8%B7%B3%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.3.2.</span> <span class="nav-text">心跳模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-1"><span class="nav-number">6.</span> <span class="nav-text">负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF-2"><span class="nav-number">6.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">6.2.</span> <span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%8D%E5%8A%A1"><span class="nav-number">6.2.1.</span> <span class="nav-text">代理类的负载均衡服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">HTTP 应用服务的负载均衡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%8D%E5%8A%A1"><span class="nav-number">6.2.2.</span> <span class="nav-text">客户端负载均衡服务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="nav-number">6.3.</span> <span class="nav-text">负载均衡策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%AD%96%E7%95%A5"><span class="nav-number">6.3.1.</span> <span class="nav-text">静态策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%AD%96%E7%95%A5"><span class="nav-number">6.3.2.</span> <span class="nav-text">动态策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#API-%E7%BD%91%E5%85%B3"><span class="nav-number">7.</span> <span class="nav-text">API 网关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF-3"><span class="nav-number">7.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6-1"><span class="nav-number">7.2.</span> <span class="nav-text">组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Gateway"><span class="nav-number">7.2.1.</span> <span class="nav-text">Gateway</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-number">7.2.1.1.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">7.2.1.2.</span> <span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zuul"><span class="nav-number">7.2.2.</span> <span class="nav-text">Zuul</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%B1%BB-1"><span class="nav-number">7.3.</span> <span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3%E7%BD%91%E5%85%B3"><span class="nav-number">7.3.1.</span> <span class="nav-text">入口网关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1"><span class="nav-number">7.3.1.1.</span> <span class="nav-text">路由</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5"><span class="nav-number">7.3.1.2.</span> <span class="nav-text">容错策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83"><span class="nav-number">7.3.1.3.</span> <span class="nav-text">认证授权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="nav-number">7.3.1.4.</span> <span class="nav-text">日志记录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BA%E5%8F%A3%E7%BD%91%E5%85%B3"><span class="nav-number">7.3.2.</span> <span class="nav-text">出口网关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.4.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">7.4.1.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%80%A7"><span class="nav-number">7.4.2.</span> <span class="nav-text">扩展性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E8%83%BD%E5%8A%9B"><span class="nav-number">7.4.3.</span> <span class="nav-text">并发能力</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5"><span class="nav-number">7.5.</span> <span class="nav-text">如何引入</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5"><span class="nav-number">8.</span> <span class="nav-text">路由策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF-4"><span class="nav-number">8.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6-2"><span class="nav-number">8.2.</span> <span class="nav-text">组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5"><span class="nav-number">8.3.</span> <span class="nav-text">常见策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IP-%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5"><span class="nav-number">8.3.1.</span> <span class="nav-text">IP 路由策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%B7%AF%E7%94%B1"><span class="nav-number">8.3.2.</span> <span class="nav-text">参数路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">8.3.3.</span> <span class="nav-text">其它</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-number">8.4.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E9%94%99"><span class="nav-number">9.</span> <span class="nav-text">容错</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E5%90%AF%E5%81%9C"><span class="nav-number">10.</span> <span class="nav-text">优雅启停</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF-5"><span class="nav-number">10.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">10.2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="nav-number">10.2.1.</span> <span class="nav-text">服务发现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD"><span class="nav-number">10.2.2.</span> <span class="nav-text">优雅关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E5%90%AF%E5%8A%A8"><span class="nav-number">10.2.3.</span> <span class="nav-text">优雅启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E9%A2%84%E7%83%AD"><span class="nav-number">10.2.3.1.</span> <span class="nav-text">启动预热</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6-1"><span class="nav-number">10.3.</span> <span class="nav-text">相关组件</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lsinger</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/28/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lsinger">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lsinger' s blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          服务发现
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-28 21:08:21" itemprop="dateCreated datePublished" datetime="2021-06-28T21:08:21+08:00">2021-06-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-07-18 00:44:25" itemprop="dateModified" datetime="2022-07-18T00:44:25+08:00">2022-07-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Microservice-Architecture/" itemprop="url" rel="index"><span itemprop="name">Microservice Architecture</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件"></a>相关组件</h1><ul>
<li>老派的 ZooKeeper</li>
<li>Kubernetes 使用的 ETCD</li>
<li>阿里的微服务注册中心 Nacos</li>
<li>Spring Cloud 的 Eureka 等等</li>
</ul>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li><p>为了高可用，在生产环境中服务提供方都是以集群的方式对外提供服务，集群里面的这些 IP 随时可能变化，我们也需要用一本“通信录”及时获取到对应的服务节点，这个获取的过程我们一般叫作“服务发现”</p>
</li>
<li><p>对于服务调用方和服务提供方来说，其契约就是接口，相当于“通信录”中的姓名，服务节点就是提供该契约的一个具体实例，服务 IP 集合作为“通信录”中的地址</p>
</li>
<li><p>主要分为两部分</p>
<ul>
<li><p>服务注册</p>
<p>在服务提供方启动的时候，将对外暴露的接口注册到注册中心之中，注册中心将这个服务节点的 IP 和接口保存下来</p>
</li>
<li><p>服务订阅</p>
<p>在服务调用方启动的时候，去注册中心查找并订阅服务提供方的 IP，然后缓存到本地，并用于后续的远程调用</p>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>服务发现的本质，就是完成了接口跟服务提供者 IP 的映射</p>
</li>
<li><p>通常我们可以使用 ZooKeeper、etcd 或者分布式缓存（如 Hazelcast）来解决事件通知问题，但当集群达到一定规模之后，依赖的 ZooKeeper 集群、etcd 集群可能就不稳定了，无法满足我们的需求</p>
</li>
</ul>
<h1 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h1><p>在超大规模的服务集群下，注册中心所面临的挑战就是超大批量服务节点同时上下线，注册中心集群接受到大量服务变更请求，集群间各节点间需要同步大量服务节点数据，最终导致如下问题</p>
<ul>
<li>注册中心负载过高</li>
<li>各节点数据不一致</li>
<li>服务下发不及时或下发错误的服务节点列表</li>
</ul>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>所有的服务提供者节点都配置在同一个域名下，调用方可以通过 DNS 拿到随机的一个服务提供者的 IP，并与之建立长连接</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>服务调用者不能及时感知到服务节点的变化</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>将域名绑定到这台负载均衡设备上，通过 DNS 拿到负载均衡的 IP</li>
<li>服务调用的时候，服务调用方就可以直接跟 VIP 建立连接，然后由 VIP 机器完成 TCP 转发</li>
</ul>
<h3 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h3><ul>
<li>搭建负载均衡设备或 TCP/IP 四层代理，需求额外成本</li>
<li>请求流量都经过负载均衡设备，多经过一次网络传输，会额外浪费些性能</li>
<li>负载均衡添加节点和摘除节点，一般都要手动添加，当大批量扩容和下线时，会有大量的人工操作和生效延迟</li>
<li>我们在服务治理的时候，需要更灵活的负载均衡策略，目前的负载均衡设备的算法还满足不了灵活的需求</li>
</ul>
<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>搭建一个 ZooKeeper 集群作为注册中心集群</li>
<li>服务注册的时候只需要服务节点向 ZooKeeper 节点写入注册信息即可</li>
<li>利用 ZooKeeper 的 Watcher 机制完成服务订阅与服务下发功能</li>
</ul>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><ul>
<li>服务平台管理端先在 ZooKeeper 中创建一个服务根路径，可以根据接口名命名（例如：/service/com.demo.xxService）</li>
<li>在这个路径再创建服务提供方目录与服务调用方目录（例如：provider、consumer），分别用来存储服务提供方的节点信息和服务调用方的节点信息</li>
<li>当服务提供方发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储该服务提供方的注册信息</li>
<li>当服务调用方发起订阅时，则在服务调用方目录中创建一个临时节点，节点中存储该服务调用方的信息</li>
<li>同时服务调用方 watch 该服务的服务提供方目录（/service/com.demo.xxService/provider）中所有的服务节点数据</li>
<li>当服务提供方目录下有节点数据发生变更时，ZooKeeper 就会通知给发起订阅的服务调用方</li>
</ul>
<h3 id="缺陷-2"><a href="#缺陷-2" class="headerlink" title="缺陷"></a>缺陷</h3><h4 id="强一致性，性能有限"><a href="#强一致性，性能有限" class="headerlink" title="强一致性，性能有限"></a>强一致性，性能有限</h4><ul>
<li><p>ZooKeeper 的一大特点就是强一致性，ZooKeeper 集群的每个节点的数据每次发生更新操作，都会通知其它 ZooKeeper 节点同时执行更新</p>
</li>
<li><p>它要求保证每个节点的数据能够实时的完全一致，这也就直接导致了 ZooKeeper 集群性能上的下降</p>
</li>
<li><p>CPU 持续升高，最终宕机</p>
<ul>
<li>当连接到 ZooKeeper 的节点数量特别多，对 ZooKeeper 读写特别频繁，且 ZooKeeper 存储的目录达到一定数量的时候，ZooKeeper 将不再稳定，CPU 持续升高，最终宕机</li>
<li>宕机之后，由于各业务的节点还在持续发送读写请求，刚一启动，ZooKeeper 就因无法承受瞬间的读写压力，马上宕机</li>
</ul>
</li>
</ul>
<h4 id="主节点宕机后，选举时间长，服务长时间不可用"><a href="#主节点宕机后，选举时间长，服务长时间不可用" class="headerlink" title="主节点宕机后，选举时间长，服务长时间不可用"></a>主节点宕机后，选举时间长，服务长时间不可用</h4><ul>
<li>Zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时剩余节点会重新进行leader选举</li>
<li>选举leader的时间大概 30~120s，且选举期间整个 Zookeeper 集群是不可用的</li>
<li>在云部署的环境下，因网络环境使Zookeeper集群失去master节点是较大概率发生的事情，虽然服务能够最终恢复，但是漫长的选举时间导致长期的服务注册不可用是不能容忍的</li>
</ul>
<h2 id="Eureke"><a href="#Eureke" class="headerlink" title="Eureke"></a>Eureke</h2><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>Eureka 在设计的时候遵循的是 <strong>AP原则</strong></li>
<li>Eureka 各个节点（服务）是平等的， 没有主从之分，几个节点  down 掉不会影响正常工作，剩余的节点（服务） 依然可以提供注册与查询服务<ul>
<li>Eureka的客户端在向某个 Eureka 注册或发现连接失败，则会自动切换到其他节点</li>
<li>只要有一台Eureka还在，就能注册可用（保 证可用性）， 只不过查询到的信息不保证是最新的（不保证强一致）</li>
</ul>
</li>
<li>节点都是临时节点，在内存里</li>
</ul>
<h3 id="多级缓存架构"><a href="#多级缓存架构" class="headerlink" title="多级缓存架构"></a>多级缓存架构</h3><h3 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h3><p>Eureka 有自我保护机制，避免服务节点被过度摘除，导致服务集群不足以承担流量的问题</p>
<ul>
<li>如果在 15 分钟内超过 85% 节点都没有正常心跳，那么 eureka 就认为客户端与注册中心出现了网络故障</li>
<li>Eureka 不再从注册列表中移除因为长时间没有收到心跳而过期的服务</li>
<li>Eureka 仍然能够接收新服务的注册和查询请求，但是不会被同步到其它节点上（即保证当前节点可用）</li>
<li>当网络稳定后，当前实例新的注册信息会被同步到其它节点中</li>
</ul>
<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>RPC 框架的服务发现，在服务节点刚上线时，服务调用方是可以容忍在一段时间之后（比如几秒钟之后）发现这个新上线的节点的</li>
<li>所以可以牺牲掉 CP（强制一致性），而选择 AP（最终一致），来换取整个注册中心集群的性能和稳定性</li>
<li>注册数据可以全量缓存在每个注册中心内存中，通过消息总线来同步数据</li>
<li>当有一个注册中心节点接收到服务节点注册时，会产生一个消息推送给消息总线，再通过消息总线通知给其它注册中心节点更新数据并进行服务下发，从而达到注册中心间数据最终一致性</li>
<li>通过消息总线的方式，完成注册中心集群间数据变更的通知，保证数据的最终一致性，并能及时地触发注册中心的服务下发操作</li>
</ul>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>当有服务上线，注册中心节点收到注册请求，服务列表数据发生变化，会生成一个消息，推送给消息总线，每个消息都有整体递增的版本</li>
<li>消息总线会主动推送消息到各个注册中心，同时注册中心也会定时拉取消息</li>
<li>获取到的消息在消息回放模块里面回放，只接受大于本地版本号的消息，小于本地版本号的消息直接丢弃，从而实现最终一致性</li>
<li>消费者订阅可以从注册中心内存拿到指定接口的全部服务实例，并缓存到消费者的内存里面</li>
<li>采用推拉模式，消费者可以及时地拿到服务实例增量变化情况，并和内存中的缓存数据进行合并</li>
<li>可以采用两级缓存，注册中心和消费者的内存缓存，通过异步推拉模式来确保最终一致性</li>
</ul>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li>服务调用方拿到的服务节点不是最新的，所以目标节点存在已经下线或不提供指定接口服务的情况<ul>
<li>在服务调用方发送请求到目标节点后，目标节点会进行合法性验证，如果指定接口服务不存在或正在下线，则会拒绝该请求</li>
<li>服务调用方收到拒绝异常后，会安全重试到其它节点</li>
</ul>
</li>
<li>例如服务节点数据的推送采用增量更新的方式，这种方式提高了注册中心“服务下发”的效率</li>
</ul>
<h1 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><ul>
<li>因为有了集群，所以每次发请求前，RPC 框架会根据路由和负载均衡算法选择一个具体的 IP 地址</li>
<li>为了保证请求成功，我们就需要确保每次选择出来的 IP 对应的连接是健康的</li>
<li>调用方跟服务集群节点之间的网络状况是瞬息万变的，两者之间可能会出现闪断或者网络设备损坏等情况</li>
<li>需要让调用方实时感知到节点的状态变化，才能保证选择出来的连接一定是可用的</li>
<li>健康检测能帮助我们从连接列表里面过滤掉一些存在问题的节点，避免在发请求的时候选择出有问题的节点而影响业务</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>nginx</li>
<li>LVS</li>
<li>Spring Cloud Ribbon</li>
</ul>
<h2 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a>基本思路</h2><ul>
<li>应用健康状况不仅包括 TCP 连接状况，还包括应用本身是否存活，很多情况下 TCP 连接没有断开，但应用可能已经“僵死了”</li>
<li>业内常用的检测方法就是用心跳机制</li>
</ul>
<h3 id="主动探测"><a href="#主动探测" class="headerlink" title="主动探测"></a>主动探测</h3><ul>
<li><p>你的 RPC 服务要打开一个端口，然后由注册中心每隔一段时间（比如 30 秒）探测这些端口是否可用，如果可用就认为服务仍然是正常的，否则就可以认为服务不可用，那么注册中心就可以把服务从列表里面删除了</p>
</li>
<li><p>让每个应用实例提供一个“健康检测”的 URL，检测程序定时通过构造 HTTP 请求访问该 URL，然后根据响应结果来进行存活判断，这样就可以防止僵死状态的误判</p>
</li>
<li><p>正常情况下，我们大概 30S 会发一次心跳请求</p>
<ul>
<li>这个间隔一般不会太短，如果太短会给服务节点造成很大的压力</li>
<li>如果太长，又不能及时摘除有问题的节点</li>
</ul>
</li>
<li><p>服务方的状态一般会有三种情况</p>
<ul>
<li>健康状态：建立连接成功，并且心跳探活也一直成功</li>
<li>亚健康状态：建立连接成功，但是心跳请求连续失败</li>
<li>死亡状态：建立连接失败</li>
</ul>
</li>
<li><p>节点的状态并不是固定不变的，它会根据心跳或者重连的结果来动态变化</p>
</li>
<li><p>判断节点状态的维度</p>
<ul>
<li>心跳检测</li>
<li>业务请求的维度<ul>
<li>可用率=某一个时间窗口内接口调用成功次数的百分比（成功次数 / 总调用次数）<ul>
<li>调用方每个接口的调用频次不一样，有的接口可能 1 秒内调用上百次，有的接口可能半个小时才会调用一次</li>
<li>服务的接口响应时间也是不一样的，有的接口可能 1ms，有的接口可能是 10s</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>减少误判</p>
<ul>
<li>把检测程序部署在多个机器里面，分布在不同的机架，甚至不同的机房</li>
<li>因为网络同时故障的概率非常低，所以只要任意一个检测程序实例访问目标机器正常，就可以说明该目标机器正常</li>
</ul>
</li>
</ul>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul>
<li>所有的 RPC 服务端都需要开放一个统一的端口给注册中心探测，你需要开放的端口很可能已经被占用，这样会造成 RPC 服务启动失败</li>
<li>如果 RPC 服务端部署的实例比较多，那么每次探测的成本也会比较高，探测的时间也比较长，这样当一个服务不可用时，可能会有一段时间的延迟，才会被注册中心探测到</li>
</ul>
<h3 id="心跳模式"><a href="#心跳模式" class="headerlink" title="心跳模式"></a>心跳模式</h3><ul>
<li>注册中心为每一个连接上来的 RPC 服务节点记录最近续约的时间，RPC 服务节点在启动注册到注册中心后，就按照一定的时间间隔（比如 30 秒），向注册中心发送心跳包</li>
<li>注册中心在接收到心跳包之后，会更新这个节点的最近续约时间</li>
<li>然后，注册中心会启动一个定时器定期检测当前时间和节点最近续约时间的差值，如果达到一个阈值（比如说 90 秒），那么认为这个服务节点不可用</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>注册中心网络故障，导致未能及时更新续约时间，所以将所有的节点摘除，从而导致了故障<ul>
<li>给注册中心增加了保护的策略：如果摘除的节点占到了服务集群节点数的 40%，就停止摘除服务节点，并且给服务的开发同学和运维同学报警处理</li>
<li>如果你使用的是 ZooKeeper 或者 ETCD 这种无保护策略的分布式一致性组件，可以考虑在客户端实现保护策略的逻辑，比如说当摘除的节点超过一定比例时，你在 RPC 客户端就不再处理变更通知，你可以依据自己的实际情况来实现</li>
</ul>
</li>
</ul>
<h1 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><ul>
<li><p>当我们的一个服务节点无法支撑现有的访问量时，我们会部署多个节点，组成一个集群，然后通过负载均衡，将请求分发给这个集群下的每个服务节点，从而达到多个服务节点共同分担请求压力的目的</p>
</li>
<li><p>同时，负载均衡服务器作为流量入口，可以对请求方屏蔽服务节点的部署细节，实现对于业务方无感知的扩容</p>
</li>
<li><p>负载均衡主要分为软负载和硬负载</p>
<ul>
<li>软负载就是在一台或多台服务器上安装负载均衡的软件，如 LVS、Nginx 等</li>
<li>硬负载就是通过硬件设备来实现的负载均衡，如 F5 服务器等</li>
</ul>
</li>
<li><p>负载均衡的算法主要有随机法、轮询法、最小连接法等</p>
</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>负载均衡服务大体上可以分为两大类：代理类和客户端类</li>
<li>一般来说，在系统接入层，使用的是代理类负载均衡，而微服务之间的内部调用，使用的是客户端负载均衡</li>
</ul>
<h3 id="代理类的负载均衡服务"><a href="#代理类的负载均衡服务" class="headerlink" title="代理类的负载均衡服务"></a>代理类的负载均衡服务</h3><ul>
<li>代理类的负载均衡服务以单独的服务方式部署，所有的请求都要先经过负载均衡服务，在负载均衡服务中选出一个合适的服务节点后，再由负载均衡服务调用这个服务节点来实现流量的分发</li>
<li>由于这类服务需要承担全量的请求，所以对于性能的要求极高</li>
<li>代理类的负载均衡服务有很多开源实现，比较著名的有 LVS、Nginx 等等</li>
<li>LVS 在 OSI 网络模型中的第四层，传输层工作，所以 LVS 又可以称为四层负载</li>
</ul>
<h4 id="HTTP-应用服务的负载均衡"><a href="#HTTP-应用服务的负载均衡" class="headerlink" title="HTTP 应用服务的负载均衡"></a>HTTP 应用服务的负载均衡</h4><ul>
<li>一般会同时部署 LVS 和 Nginx 来做 HTTP 应用服务的负载均衡</li>
<li>在入口处部署 LVS 将流量分发到多个 Nginx 服务器上，再由 Nginx 服务器分发到应用服务器上</li>
<li>LVS 是在网络栈的四层做请求包的转发，请求包转发之后，由客户端和后端服务直接建立连接，后续的响应包不会再经过 LVS 服务器，所以相比 Nginx 性能会更高，也能够承担更高的并发</li>
<li>可 LVS 缺陷是工作在四层，而请求的 URL 是七层的概念，不能针对 URL 做更细致的请求分发，而且 LVS 也没有提供探测后端服务是否存活的机制</li>
<li>Nginx 虽然比 LVS 的性能差很多，但也可以承担每秒几万次的请求，并且它在配置上更加灵活，还可以感知后端服务是否出现问题</li>
<li>因此，LVS 适合在入口处承担大流量的请求分发，而 Nginx 要部署在业务服务器之前做更细维度的请求分发</li>
<li>我给你的建议是，如果你的 QPS 在十万以内，那么可以考虑不引入 LVS 而直接使用 Nginx 作为唯一的负载均衡服务器，这样少维护一个组件，也会减少系统的维护成本</li>
</ul>
<h3 id="客户端负载均衡服务"><a href="#客户端负载均衡服务" class="headerlink" title="客户端负载均衡服务"></a>客户端负载均衡服务</h3><ul>
<li>客户端负载均衡服务，也就是把负载均衡的服务内嵌在 RPC 客户端中</li>
<li>它一般和客户端应用部署在一个进程中，提供多种选择节点的策略，最终为客户端应用提供一个最佳的、可用的服务端节点</li>
<li>这类服务一般会结合注册中心来使用，注册中心提供服务节点的完整列表，客户端拿到列表之后使用负载均衡服务的策略选取一个合适的节点，然后将请求发到这个节点上</li>
<li>RPC 的负载均衡完全由 RPC 框架自身实现，RPC 的服务调用者会与“注册中心”下发的所有服务节点建立长连接，在每次发起 RPC 调用时，服务调用者都会通过配置的负载均衡插件，自主选择一个服务节点，发起 RPC 调用请求</li>
<li>由于负载均衡机制完全是由 RPC 框架自身实现的，所以它不再需要依赖任何负载均衡设备，自然也不会发生负载均衡设备的单点问题，服务调用方的负载均衡策略也完全可配，同时我们可以通过控制权重的方式，对负载均衡进行治理</li>
<li>RPC 负载均衡策略一般包括随机权重、Hash、轮询</li>
<li>其中的随机权重策略应该是我们最常用的一种了，通过随机算法，我们基本可以保证每个节点接收到的请求流量是均匀的；同时我们还可以通过控制节点权重的方式，来进行流量控制</li>
</ul>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><h3 id="静态策略"><a href="#静态策略" class="headerlink" title="静态策略"></a>静态策略</h3><ul>
<li><p>也就是说负载均衡服务器在选择服务节点时，不会参考后端服务的实际运行的状态</p>
</li>
<li><p>常见的静态策略有几种，轮询策略、带有权重的轮询策略</p>
<ul>
<li>Nginx 提供了 ip_hash 和 url_hash 算法</li>
<li>LVS 提供了按照请求的源地址和目的地址做 Hash 的策略</li>
<li>Dubbo 也提供了随机选取策略以及一致性 Hash 的策略</li>
</ul>
</li>
<li><p>其中使用最广泛的是轮询的策略（RoundRobin，RR），这种策略会记录上次请求后端服务的地址或者序号，然后在请求时按照服务列表的顺序，请求下一个后端服务节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger lastCounter = getLastCounter();<span class="comment">//获取上次请求的服务节点的序号 </span></span><br><span class="line">List&lt;String&gt; serverList = getServerList(); <span class="comment">// 获取服务列表</span></span><br><span class="line"><span class="keyword">int</span> currentIndex = lastCounter.addAndGet(); <span class="comment">//增加序列号</span></span><br><span class="line"><span class="keyword">if</span>(currentIndex &gt;= serverList.size()) &#123;</span><br><span class="line">  currentIndex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">setLastCounter(currentIndex);</span><br><span class="line"><span class="keyword">return</span> serverList.get(currentIndex);</span><br></pre></td></tr></table></figure></li>
<li><p>轮询的策略可以做到将请求尽量平均地分配到所有服务节点上，但是，它没有考虑服务节点的具体配置情况</p>
</li>
<li><p>轮询和带有权重的轮询策略能够将请求尽量平均地分配到后端服务节点上，也就能够做到对于负载的均衡分配</p>
</li>
<li><p>在没有更好的动态策略之前，应该优先使用这两种策略，比如 Nginx 就会优先使用轮询的策略</p>
</li>
</ul>
<h3 id="动态策略"><a href="#动态策略" class="headerlink" title="动态策略"></a>动态策略</h3><ul>
<li><p>也就是说负载均衡服务器会依据后端服务的一些负载特性，来决定要选择哪一个服务节点</p>
</li>
<li><p>从调用方的角度出发，选择负载最小、资源最空闲的服务来调用，以期望能得到更高的服务调用性能，也就能最大化地使用服务器的空闲资源，请求也会响应得更迅速</p>
</li>
<li><p>在负载均衡服务器上会收集对后端服务的调用信息</p>
<ul>
<li>比如从负载均衡端到后端服务的活跃连接数<ul>
<li>Dubbo 提供的 LeastAcive 策略，就是优先选择活跃连接数最少的服务</li>
</ul>
</li>
<li>或者是调用的响应时间<ul>
<li>Spring Cloud 全家桶中的 Ribbon 提供了 WeightedResponseTimeRule 是使用响应时间给每个服务节点计算一个权重，然后依据这个权重，来给调用方分配服务节点</li>
</ul>
</li>
<li>然后从中选择连接数最少的服务，或者响应时间最短的后端服务</li>
</ul>
</li>
<li><p>在实际开发中，优先考虑使用动态的策略</p>
</li>
</ul>
<h1 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h1><h2 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h2><ul>
<li>API 网关（API Gateway）不是一个开源组件，而是一种架构模式，它是将一些服务共有的功能整合在一起，独立部署为单独的一层，用来解决一些服务治理的问题</li>
<li>可以把它看作系统的边界，它可以对出入系统的流量做统一的管控</li>
</ul>
<h2 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h2><ul>
<li>Kong是在 Nginx 中运行的 Lua 程序<ul>
<li>得益于 Nginx 的性能优势，Kong 相比于其它的开源 API 网关来说，性能方面是最好的</li>
<li>由于大中型公司对于 Nginx 运维能力都比较强，所以选择 Kong 作为 API 网关</li>
<li>无论是在性能还是在运维的把控力上，都是比较好的选择</li>
</ul>
</li>
<li>Zuul是 Spring Cloud 全家桶中的成员<ul>
<li>如果你已经使用了 Spring Cloud 中的其他组件，那么也可以考虑使用 Zuul 和它们无缝集成</li>
<li>Zuul1 因为采用同步阻塞模型，所以在性能上并不是很高效</li>
<li>而 Zuul2 推出时间不长，难免会有坑</li>
<li>但是 Zuul 的代码简单易懂，可以很好地把控</li>
<li>系统的量级达不到 Netfix 这样的级别时，所以对于 Java 技术栈的团队，使用 Zuul 也是一个不错的选择</li>
<li>Spring cloud gateway 性能比zuul好一些，并且是异步的</li>
</ul>
</li>
<li>Tyk是一种 Go 语言实现的轻量级 API 网关<ul>
<li>有着丰富的插件资源，对于 Go 语言栈的团队来说，也是一种不错的选择</li>
</ul>
</li>
</ul>
<h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li>满足某个断言（时间、cookie ），才把请求路由到某个地址上去<ul>
<li>注册到注册中心，然后拦截器拦截请求，根据配置规则解析URL转发请求，到正确的服务器上</li>
</ul>
</li>
<li>过滤器</li>
<li>熔断、降级、限流</li>
<li>请求加上参数</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty</li>
</ul>
<h3 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h3><ul>
<li>servlet是一个简单的网络IO模型，当请求进入servlet container时，servlet container就会为其绑定一个线程，在并发不高的场景下这种模型是适用的</li>
<li>一旦并发上升，线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大）严重影响请求的处理时间</li>
<li>在一些简单的业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型没有优势</li>
<li>Zuul 2.0开始，使用了Netty，并且已经有了大规模Zuul 2.0集群部署的成熟案例，但是，Springcloud官方已经没有集成改版本的计划了</li>
<li>Webflux模式替换了旧的Servlet线程模型</li>
<li>用少量的线程处理request和response io操作，这些线程称为Loop线程，而业务交给响应式编程框架处理，响应式编程是非常灵活的，用户可以将业务中阻塞的操作提交到响应式框架的work线程中执行，而不阻塞的操作依然可以在Loop线程中进行处理，大大提高了Loop线程的利用率</li>
</ul>
<h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><p>API 网关可以分为两类：一类叫做入口网关，一类叫做出口网关</p>
<h3 id="入口网关"><a href="#入口网关" class="headerlink" title="入口网关"></a>入口网关</h3><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ul>
<li>它提供客户端一个统一的接入地址，API 网关可以将用户的请求动态路由到不同的业务服务上，并且做一些必要的协议转换工作<ul>
<li>在你的系统中，你部署的微服务对外暴露的协议可能不同：有些提供的是 HTTP 服务；有些已经完成 RPC 改造，对外暴露 RPC 服务；有些遗留系统可能还暴露的是 Web Service 服务</li>
<li>API 网关可以对客户端屏蔽这些服务的部署地址以及协议的细节，给客户端的调用带来很大的便捷。另一方面，在 API 网关中</li>
</ul>
</li>
<li>API 网关还可以做一些与黑白名单相关的事情，比如针对设备 ID、用户 IP、用户 ID 等维度的黑白名单</li>
</ul>
<h4 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h4><ul>
<li>可以植入一些服务治理的策略，比如服务的熔断、降级、流量控制和分流等等</li>
</ul>
<h4 id="认证授权"><a href="#认证授权" class="headerlink" title="认证授权"></a>认证授权</h4><ul>
<li><p>客户端的认证和授权的实现，也可以放在 API 网关</p>
</li>
<li><p>不同类型的客户端使用的认证方式是不同的</p>
<ul>
<li>手机 APP 使用 Oauth 协议认证</li>
<li>HTML5 端和 Web 端使用 Cookie 认证</li>
<li>内部服务使用自研的 Token 认证方式</li>
</ul>
</li>
<li><p>这些认证方式在 API 网关上可以得到统一处理，应用服务不需要了解认证的细节</p>
</li>
</ul>
<h4 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h4><ul>
<li>在 API 网关中也可以做一些日志记录的事情，比如记录 HTTP 请求的访问日志</li>
</ul>
<h3 id="出口网关"><a href="#出口网关" class="headerlink" title="出口网关"></a>出口网关</h3><ul>
<li>在出口网关中，对调用外部的 API 做统一的认证、授权、审计以及访问控制</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>首先要考虑的是它的性能</li>
<li>API 入口网关承担从客户端的所有流量<ul>
<li>假如业务服务处理时间是 10ms，而 API 网关的耗时在 1ms，那么相当于每个接口的响应时间都要增加 10%，这对于性能的影响无疑是巨大的</li>
</ul>
</li>
<li>提升 API 网关性能的关键还是在 I/O 模型<ul>
<li>Netfix 开源的 API 网关 Zuul，在 1.0 版本的时候使用的是同步阻塞 I/O 模型</li>
<li>在 Zuul2.0 中，Netfix 团队将 servlet 改造成了一个 netty server（netty 服务），采用 I/O 多路复用的模型处理接入的 I/O 请求</li>
</ul>
</li>
</ul>
<h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><ul>
<li>API 网关的设计要注意扩展性，可以随时在网关的执行链路上增加一些逻辑，也可以随时下掉一些逻辑（也就是所谓的热插拔）<ul>
<li>API 网关中执行的动作有些是可以预先定义好的，比如黑白名单的设置，接口动态路由；有些则是需要业务方依据自身业务来定义</li>
</ul>
</li>
<li>可以把每一个操作定义为一个 filter（过滤器），然后使用“责任链模式”将这些 filter 串起来。责任链可以动态地组织这些 filter，解耦 filter 之间的关系，无论是增加还是减少 filter，都不会对其他的 filter 有任何的影响，Zuul 就是采用责任链模式<ul>
<li>Zuul1 中将 filter 定义为三类：pre routing filter（路由前过滤器）、routing filter（路由过滤器）和 after routing filter（路由后过滤器）</li>
<li>每一个 filter 定义了执行的顺序，在 filter 注册时，会按照顺序插入到 filter chain（过滤器链）中。这样 Zuul 在接收到请求时，就会按照顺序依次执行插入到 filter chain 中的 filter 了</li>
</ul>
</li>
</ul>
<h3 id="并发能力"><a href="#并发能力" class="headerlink" title="并发能力"></a>并发能力</h3><ul>
<li>为了提升网关对于请求的并行处理能力，我们一般会使用线程池来并行的执行请求</li>
<li>需要针对不同的服务做线程隔离或者保护<ul>
<li>背景<ul>
<li>如果商品服务出现问题造成响应缓慢，那么调用商品服务的线程就会被阻塞无法释放，久而久之，线程池中的线程就会被商品服务所占据，那么其他服务也会受到级联的影响</li>
</ul>
</li>
<li>如果后端的服务拆分得不多，可以针对不同的服务，采用不同的线程池</li>
<li>在线程池内部可以针对不同的服务甚至不同的接口做线程的保护<ul>
<li>比如说，线程池的最大线程数是 1000，那么可以给每个服务设置一个最多可以使用的配额。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="如何引入"><a href="#如何引入" class="headerlink" title="如何引入"></a>如何引入</h2><ul>
<li>再独立出一组网关专门做服务聚合、超时控制方面的事情，我们一般把前一种网关叫做流量网关，后一种可以叫做业务网关</li>
<li>抽取独立的服务层，专门做接口聚合的操作。这样服务层就大概分为原子服务层和聚合服务层。<ul>
<li>可以在系统和第三方支付服务，以及登陆服务之间部署出口网关服务。原先，你会在拆分出来的支付服务中完成对于第三方支付接口所需要数据的加密、签名等操作，再调用第三方支付接口完成支付请求。现在，你把对数据的加密、签名的操作放在出口网关中，这样一来，支付服务只需要调用出口网关的统一支付接口就可以了</li>
</ul>
</li>
</ul>
<h1 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h1><ul>
<li>一般可以内置于API网关或者RPC框架中</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/b7/68/b78964a2db3adc8080364e9cfc79ca68.jpg" alt="img"></p>
<h2 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h2><ul>
<li>服务路由包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用哪些服务提供者</li>
<li>路由本质是节点分组、隔离流量，打标签、分流等特性都天然适合在路由策略里做</li>
<li>灰度发布功能作为 RPC 路由功能的一个典型应用场景，可以通过路由功能完成像定点调用、黑白名单等一些高级服务治理功能</li>
<li>在 RPC 里面，不管是哪种路由策略，其核心思想都是让请求按照我们设定的规则发送到目标节点上，从而实现流量隔离的效果</li>
</ul>
<h2 id="组件-2"><a href="#组件-2" class="headerlink" title="组件"></a>组件</h2><ul>
<li>Dubbo</li>
<li>Zuul</li>
</ul>
<h2 id="常见策略"><a href="#常见策略" class="headerlink" title="常见策略"></a>常见策略</h2><h3 id="IP-路由策略"><a href="#IP-路由策略" class="headerlink" title="IP 路由策略"></a>IP 路由策略</h3><ul>
<li>用于限制可以调用服务提供方的 IP</li>
<li>在 RPC 发起真实请求的时候，有一个步骤就是从服务提供方节点集合里面选择一个合适的节点（就是我们常说的负载均衡），那我们是不是可以在选择节点前加上“筛选逻辑”，把符合我们要求的节点筛选出来</li>
<li>比如我们要求新上线的节点只允许某个 IP 可以调用，那我们的注册中心会把这条规则下发到服务调用方</li>
<li>在调用方收到规则后，在选择具体要发请求的节点前，会先通过筛选规则过滤节点集合</li>
</ul>
<h3 id="参数路由"><a href="#参数路由" class="headerlink" title="参数路由"></a>参数路由</h3><ul>
<li>更细粒度的路由方式</li>
<li>保证某个主题对象的所有请求都使用同一种应用来承接<ul>
<li>假设我们改造的是商品应用，那主题对象肯定是商品 ID，在切流量的过程中，我们必须保证某个商品的所有操作都是用新应用（或者老应用）来完成所有请求的响应</li>
</ul>
</li>
<li>我们可以给所有的服务提供方节点都打上标签，用来区分新老应用节点</li>
<li>在服务调用方发生请求的时候，我们可以很容易地拿到请求参数，也就是我们例子中的商品 ID</li>
<li>根据注册中心下发的规则来判断当前商品 ID 的请求是过滤掉新应用还是老应用的节点</li>
<li>因为规则对所有的调用方都是一样的，从而保证对应同一个商品 ID 的请求要么是新应用的节点，要么是老应用的节点</li>
<li>相比 IP 路由，参数路由支持的灰度粒度更小，他为服务提供方应用提供了另外一个服务治理的手段。</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li>Dubbo 目前提供了三种服务路由实现，分别为条件路由 ConditionRouter、脚本路由 ScriptRouter 和标签路由 TagRouter</li>
</ul>
<h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>虽然在调用方(上游)做路由策略选择可用的提供方(下游)集群，是天然符合RPC调用机制的，但是在团队协作上却是反人性的（难以推动）</li>
<li>后期扩展时业务不需要更新部署(例如Dubbo的条件路由、脚本路由等都是可以从第三方写注册中心更新路由策略而无需业务变更)</li>
</ul>
<h1 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h1><h1 id="优雅启停"><a href="#优雅启停" class="headerlink" title="优雅启停"></a>优雅启停</h1><h2 id="背景-5"><a href="#背景-5" class="headerlink" title="背景"></a>背景</h2><ul>
<li>在服务重启的时候，对于调用方来说，这时候可能会存在以下几种情况<ul>
<li>调用方发请求前，目标服务已经下线。对于调用方来说，跟目标节点的连接会断开，这时候调用方可以立马感知到，并且在其健康列表里面会把这个节点挪掉，自然也就不会被负载均衡选中</li>
<li>调用方发请求的时候，目标服务正在关闭，但调用方并不知道它正在关闭，而且两者之间的连接也没断开，所以这个节点还会存在健康列表里面，因此该节点就有一定概率会被负载均衡选中</li>
</ul>
</li>
<li>在 Java 里面，在运行过程中，JVM 虚拟机会把高频的代码编译成机器码，被加载过的类也会被缓存到 JVM 缓存中，再次使用的时候不会触发临时加载，这样就使得“热点”代码的执行不用每次都通过解释，从而提升执行速度</li>
<li>在 Java 里面，在运行过程中，JVM 虚拟机会把高频的代码编译成机器码，被加载过的类也会被缓存到 JVM 缓存中，再次使用的时候不会触发临时加载，这样就使得“热点”代码的执行不用每次都通过解释，从而提升执行速度，但是这些“临时数据”，都在我们应用重启后就消失了</li>
<li>刚重启的服务提供方因为没有预跑就承担了大流量</li>
</ul>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p><img src="https://static001.geekbang.org/resource/image/a1/50/a15be58b32195422bd5a18dba0e68050.jpg" alt="img"></p>
<ul>
<li>整个关闭过程中依赖了两次 RPC 调用<ul>
<li>一次是服务提供方通知注册中心下线操作</li>
<li>一次是注册中心通知服务调用方下线节点操作</li>
</ul>
</li>
<li>注册中心通知服务调用方都是异步的，我们在“服务发现”一讲中讲过在大规模集群里面，服务发现只保证最终一致性，并不保证实时性，所以注册中心在收到服务提供方下线的时候，并不能成功保证把这次要下线的节点推送到所有的调用方</li>
<li>通过服务发现并不能做到应用无损关闭</li>
</ul>
<h3 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h3><p><img src="https://static001.geekbang.org/resource/image/77/cc/7752081ec658f1d56ac4219f1c07fbcc.jpg" alt="img"></p>
<ul>
<li><p>捕获关闭事件</p>
<ul>
<li>可以通过捕获操作系统的进程信号来获取，在 Java 语言里面，对应的是 Runtime.addShutdownHook 方法，可以注册关闭的钩子</li>
</ul>
</li>
<li><p>在 RPC 启动的时候，我们提前注册关闭钩子，并在里面添加了两个处理程序，一个负责开启关闭标识，一个负责安全关闭服务对象，服务对象在关闭的时候会通知调用方下线节点</p>
</li>
<li><p>同时需要在我们调用链里面加上挡板处理器，当新的请求来的时候，会判断关闭标识，如果正在关闭，则抛出特定异常</p>
<ul>
<li>当服务提供方正在关闭，如果这之后还收到了新的业务请求，服务提供方直接返回一个特定的异常给调用方（比如 ShutdownException）<ul>
<li>这个异常就是告诉调用方“我已经收到这个请求了，但是我正在关闭，并没有处理这个请求”</li>
<li>调用方收到这个异常响应后，RPC 框架把这个节点从健康列表挪出，并把请求自动重试到其他节点</li>
<li>因为这个请求是没有被服务提供方处理过，所以可以安全地重试到其他节点，这样就可以实现对业务无损</li>
</ul>
</li>
</ul>
</li>
<li><p>关闭过程中已经在处理的请求</p>
<ul>
<li>在服务对象加上引用计数器，每开始处理请求之前加一，完成请求处理减一，通过该计数器我们就可以快速判断是否有正在处理的请求</li>
<li>根据引用计数器等待正在处理的请求全部结束之后才会真正关闭</li>
<li>考虑到有些业务请求可能处理时间长，或者存在被挂住的情况，为了避免一直等待造成应用无法正常退出，我们可以在整个 ShutdownHook 里面，加上超时时间控制</li>
<li>当超过了指定时间没有结束，则强制退出应用</li>
<li>超时时间我建议可以设定成 10s，基本可以确保请求都处理完了</li>
</ul>
</li>
<li><p>但如果只是靠等待被动调用，就会让这个关闭过程整体有点漫长，加上主动通知流程，这样既可以保证实时性，也可以避免通知失败的情况</p>
<ul>
<li>在 RPC 里面调用方跟服务提供方之间是长连接，在提供方应用内存里面维护一份调用方连接集合，当服务要关闭的时候，挨个去通知调用方去下线这台机器</li>
<li>这样整个调用链路就变短了，对于每个调用方来说就一次 RPC，可以确保调用的成功率很高</li>
</ul>
</li>
</ul>
<h3 id="优雅启动"><a href="#优雅启动" class="headerlink" title="优雅启动"></a>优雅启动</h3><h4 id="启动预热"><a href="#启动预热" class="headerlink" title="启动预热"></a>启动预热</h4><h2 id="相关组件-1"><a href="#相关组件-1" class="headerlink" title="相关组件"></a>相关组件</h2><ul>
<li>Tomcat 关闭的时候也是先从外层到里层逐层进行关闭，先保证不接收新请求，然后再处理关闭前收到的请求</li>
</ul>
<ul>
<li>如果暴力地停止服务，那么已经发送给服务端的请求，来不及处理服务就被删掉了，就会造成这部分请求失败，服务就会有波动</li>
<li>服务在退出的时候，都需要先停掉流量再停止服务，这样服务的关闭才会更平滑</li>
<li>对于 RPC 服务来说，我们可以先将 RPC 服务从注册中心的服务列表中删除掉，然后观察 RPC 服务端没有流量之后，再将服务端停掉</li>
</ul>
<p>Nginx 定期地探测后端服务的一个指定的接口，然后根据返回的状态码来判断服务是否还存活。当探测不存活的次数达到一定阈值时，就自动将这个后端服务从负载均衡服务器中摘除。</p>
<p>在这个接口中返回的 HTTP 状态码，这个返回的状态码可以存储在配置中心中，这样在变更状态码时，就不需要重启服务了（配置中心在第 33 节课中会讲到）。节点检测的功能，还能够帮助我们实现 Web 服务的优雅关闭</p>
<p>在服务刚刚启动时，可以初始化默认的 HTTP 状态码是 500，这样 Nginx 就不会很快将这个服务节点标记为可用，也就可以等待服务中依赖的资源初始化完成，避免服务初始启动时的波动。在完全初始化之后，再将 HTTP 状态码变更为 200，Nginx 经过两次探测后，就会标记服务为可用。在服务关闭时，也应该先将 HTTP 状态码变更为 500，等待 Nginx 探测将服务标记为不可用后，前端的流量也就不会继续发往这个服务节点。在等待服务正在处理的请求全部处理完毕之后，再对服务做重启，可以避免直接重启导致正在处理的请求失败的问题。这是启动和关闭线上 Web 服务时的标准姿势，你可以在项目中参考使用。</p>
<!-- more -->


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Interview/" rel="tag"># Interview</a>
              <a href="/tags/High-Concurrency-System/" rel="tag"># High Concurrency System</a>
              <a href="/tags/Distributed-System/" rel="tag"># Distributed System</a>
              <a href="/tags/Microservice-Architecture/" rel="tag"># Microservice Architecture</a>
              <a href="/tags/Service-Discovery/" rel="tag"># Service Discovery</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="prev" title="计算机网络">
                  <i class="fa fa-chevron-left"></i> 计算机网络
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/06/28/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" rel="next" title="Java 内存模型">
                  Java 内存模型 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lsinger</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
